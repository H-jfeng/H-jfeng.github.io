<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++语法知识</title>
      <link href="/2023/08/19/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/08/19/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-开始学习C"><a href="#第2章-开始学习C" class="headerlink" title="第2章 开始学习C++"></a>第2章 开始学习C++</h1><h2 id="2-1-进入C"><a href="#2-1-进入C" class="headerlink" title="2.1 进入C++"></a>2.1 进入C++</h2><h3 id="2-1-6-使用cout进行C-输出"><a href="#2-1-6-使用cout进行C-输出" class="headerlink" title="2.1.6 使用cout进行C++输出"></a>2.1.6 使用cout进行C++输出</h3><h1 id="第6章-分支语句和逻辑运算符"><a href="#第6章-分支语句和逻辑运算符" class="headerlink" title="第6章 分支语句和逻辑运算符"></a>第6章 分支语句和逻辑运算符</h1><h2 id="6-8-简单文件输入输出"><a href="#6-8-简单文件输入输出" class="headerlink" title="6.8 简单文件输入输出"></a>6.8 简单文件输入输出</h2><h1 id="第11章-使用类"><a href="#第11章-使用类" class="headerlink" title="第11章 使用类"></a>第11章 使用类</h1><h2 id="11-6类的自动转换和强制类型转换"><a href="#11-6类的自动转换和强制类型转换" class="headerlink" title="11.6类的自动转换和强制类型转换"></a>11.6类的自动转换和强制类型转换</h2><ol><li><p>数据类型的转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> tine = <span class="number">11</span>;  </span><br><span class="line"><span class="type">int</span> side = <span class="number">3.33</span>;  都是正确的，将进行自动类型转换</span><br><span class="line"><span class="type">int</span> *p = <span class="number">10</span>;    不会进行自动转换，是不兼容的类型，可进行强制类型转换</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>下面的构造函数用于将double类型的值转换为Stonewt类类型，介绍的是转换构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs)   只能是接受一个参数的构造函数才能这样   Stonewt::<span class="built_in">Stonewt</span>(<span class="type">int</span> stn,<span class="type">double</span> lbs=<span class="number">0</span>)可以</span><br><span class="line">&#123;</span><br><span class="line">stone = <span class="built_in">int</span>(lbs)/<span class="number">14</span>;</span><br><span class="line">pounds = lbs; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt myCat;</span><br><span class="line">myCat = <span class="number">19.6</span>;</span><br><span class="line">先创建一个临时的Stonewt的对象，并将<span class="number">19.2</span>作为初始值，然后将临时对象的内容复制到myCat中,为类的隐式转换，是自动进行的</span><br></pre></td></tr></table></figure></li><li><p>explicit是关闭隐式转换，但仍然允许显式强制类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Stonewt</span><span class="params">(<span class="type">double</span> lbs)</span></span>;</span><br><span class="line">Stonewt myCat;</span><br><span class="line">myCat = <span class="number">19.6</span>;  NO</span><br><span class="line"></span><br><span class="line">myCat = <span class="built_in">Stonewt</span>(<span class="number">19.6</span>);   Yes</span><br><span class="line">myCat = (Stonewt)<span class="number">19.6</span>;</span><br></pre></td></tr></table></figure></li><li><p>转换还存在二义性，还可以用于将double值传递给接受Stonewt参数的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> Stonewt &amp; st,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Wow&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">display</span>(<span class="number">422</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果提供了Stonewt(double)构造函数,并且是成员函数的加法函数则可以这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt <span class="title">jennySt</span><span class="params">(<span class="number">9</span>,<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> kennyD = <span class="number">176.0</span>;</span><br><span class="line">Stonewt total;</span><br><span class="line">total = jennySt+kennyD;</span><br></pre></td></tr></table></figure><p>但只有友元函数才允许这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt <span class="title">jennySt</span><span class="params">(<span class="number">9</span>,<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> kennyD = <span class="number">176.0</span>;</span><br><span class="line">Stonewt total;</span><br><span class="line">total = kennyD+jennySt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="11-6-1转换函数"><a href="#11-6-1转换函数" class="headerlink" title="11.6.1转换函数"></a>11.6.1转换函数</h3><ol><li><p>转换函数的概念：是将类类型转换为某种类型，是用户定义的强制类型转换</p></li><li><p>转换函数必须是类方法，不能指定返回类型，不能有参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;    转换为<span class="type">double</span>类型的函数</span><br><span class="line"><span class="function">Stonewt::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pounds;   返回一个<span class="type">double</span>数</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Stonewt <span class="title">wolfe</span><span class="params">(<span class="number">285.7</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> honst = <span class="built_in">double</span>(wolfe);</span><br><span class="line"><span class="type">double</span> honst = (<span class="type">double</span>)wolfe;</span><br><span class="line"><span class="type">double</span> honst = wolfe;</span><br></pre></td></tr></table></figure><p>注意虽然没有声明返回类型，但也将返回所需的值，是四舍五入的方式而不是去掉小数部分</p></li><li><p>类类型转换为某种类型也会存在二义性</p></li><li><p>explicit 不能用于转换函数，但可以使用非转换函数替换，只能进行强制转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stonewt::Stone_to_Int</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">int</span> (pounds+<span class="number">0.5</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> plb = poppins;    是非法的</span><br><span class="line"><span class="type">int</span> plb = poppins.<span class="built_in">Stone_to_Int</span>();   可以</span><br></pre></td></tr></table></figure></li><li><p>警告：应谨慎地使用隐式转换函数。通常使用显式的强制类型转换</p></li></ol><h3 id="11-6-2转换函数和友元函数"><a href="#11-6-2转换函数和友元函数" class="headerlink" title="11.6.2转换函数和友元函数"></a>11.6.2转换函数和友元函数</h3><ol><li>实现加法时的选择，要将double量和Stonewt量相加可以有两种方法</li></ol><h1 id="第12章-类和动态内存分配"><a href="#第12章-类和动态内存分配" class="headerlink" title="第12章 类和动态内存分配"></a>第12章 类和动态内存分配</h1><h2 id="12-1动态内存和类"><a href="#12-1动态内存和类" class="headerlink" title="12.1动态内存和类"></a>12.1动态内存和类</h2><h3 id="12-1-1开发一个动态内存类"><a href="#12-1-1开发一个动态内存类" class="headerlink" title="12.1.1开发一个动态内存类"></a>12.1.1开发一个动态内存类</h3><ol><li><p>使用动态内存分配来开发类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str;   </span><br></pre></td></tr></table></figure><p>使用char指针，而不是char数组，这意味着类声明没有为字符串分配存储空间</p></li><li><p>静态类成员特点：<br>无论创建了多少对象，所有对象共享同一个静态成员，例如，num_strings成员可以记录所创建的对象数目</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> num_strings;</span><br><span class="line"><span class="type">int</span> StringBad::num_strings = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>不能在类声明中初始化静态成员变量，只能在.c文件中初始化，类外也不可以初始化，但如果静态成员是const整数类型或枚举类型(见第十章)，则可以在类声明中初始化<br>创建构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">len = <span class="built_in">strlen</span>(s);   不会包括末尾的空字符<span class="string">&#x27;\0&#x27;</span></span><br><span class="line">str = <span class="keyword">new</span> <span class="type">char</span>[len+<span class="number">1</span>];  </span><br><span class="line"><span class="built_in">strcpy</span>(str,s);</span><br><span class="line">num_strings++;  记录对象的数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串并不保存在对象中，而是保存在堆内存中，对象仅保存了指出到哪里去查找字符串的信息。不能这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = s;</span><br></pre></td></tr></table></figure><p>这只保存了地址，而没有创建字符串副本</p></li><li><p>析构函数的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">StringBad knot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象声明放在一个内部代码块中，因为析构函数将在定义对象的代码块执行完毕时调用，对象的删除的顺序与创建顺序相反</p></li><li><p>在进行输出类时，是运用了重载运算符&lt;&lt;，注意查看重载运算符&lt;&lt;函数中输出的是什么内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBad knot;</span><br><span class="line">cout &lt;&lt; knot &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p>编译器会自动生成成员函数和自动使用你不使用函数：构造函数，析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp;);   为复制构造函数，会创建对象的一个副本</span><br><span class="line">StringBad sailor=sports《《 StringBad sailor=<span class="built_in">StringBad</span>(sports);  调用了一个函数</span><br></pre></td></tr></table></figure></li></ol><h3 id="12-1-2-特殊成员函数"><a href="#12-1-2-特殊成员函数" class="headerlink" title="12.1.2 特殊成员函数"></a>12.1.2 特殊成员函数</h3><ol><li><p>特殊成员函数是自动定义的，有：<br>默认构造函数，如果没有定义<br>默认析构函数，如果没有定义<br>复制构造函数，如果没有定义<br>赋值运算符，如果没有定义<br>地址运算符，如果没有定义，返回调用对象的地址(即this指针的值)<br>c++11新增：<br>移动构造函数<br>移动运算符</p></li><li><p>默认构造函数<br>如果定义了构造函数，c++将不会定义默认构造函数。如果希望在创建对象时不显示地对它进行初始话，则必须显示地定义默认构造函数，它还可以来设定特定的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Klunk::<span class="built_in">Klunk</span>()</span><br><span class="line">&#123;</span><br><span class="line">klunk_ct = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Klunk lunk;     在创建对象时不显示地对它进行初始话</span><br></pre></td></tr></table></figure><p>带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值，但只有一个默认构造函数，不然会造成二义性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Klunk</span>(<span class="type">int</span> n=<span class="number">0</span>)&#123;klunk_ct = n&#125;;</span><br></pre></td></tr></table></figure></li><li><p>复制构造函数<br>1.它用于初始化过程，而不是常规的赋值过程，每当程序生成了对象副本时，编译器都将使用复制构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StirngBad * pStringBad = <span class="keyword">new</span> <span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp;);</span><br></pre></td></tr></table></figure><p>使用motto初始化一个匿名对象，并将新对象的地址赋给pstring指针<br>2.当按值传递和返回对象时以及编译器生成临时对象，例如将3个Vectir对象相加时，编译器可能生成临时的Vector对象来保存中间结果，都将调用复制构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme1</span><span class="params">(StringBad n)</span></span>;    复制构造函数初始化<span class="built_in">callme2</span>()函数的StringBad形参</span><br><span class="line"><span class="built_in">callme2</span>(headline2);</span><br></pre></td></tr></table></figure><p>3.由于按值传递对象将调用复制构造函数，在用类为函数的参数时应该按引用传递对象<br>4.如果成员本身就是类对象，则将使用这个类的复制函数来复制成员对象。静态成员不受影响，因为它们属于整个类</p></li><li><p>显示复制构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">num_string++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类中包含这样的静态数据成员，即其值将在对象被创建时发生变化，则应该提供一个显示复制构造函数来处理计数问题</p></li></ol><h3 id="12-1-3-回到Stringbad-复制构造函数的哪里出了问题"><a href="#12-1-3-回到Stringbad-复制构造函数的哪里出了问题" class="headerlink" title="12.1.3 回到Stringbad: 复制构造函数的哪里出了问题"></a>12.1.3 回到Stringbad: 复制构造函数的哪里出了问题</h3><ol><li><p>这里复制的并不是字符串，而是一个指向字符串的指针，得到两个指向同一个字符串的指针，相当于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sailor.str = sport.str;(由于私有成员是无法访问的，因此这些代码是不能通过编译的)</span><br></pre></td></tr></table></figure></li><li><p>sports.str指向的内容已经被sailor的析构函数释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] sailor.str;</span><br><span class="line"><span class="keyword">delete</span> [] sports.str;</span><br></pre></td></tr></table></figure></li><li><p>定义一个显式复制构造函数以解决问题(深度复制)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">num_string++;</span><br><span class="line">len = st.len;</span><br><span class="line">str = <span class="keyword">new</span> <span class="type">char</span> [len+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str,st.str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该复制构造函数应当复制字符串并将副本的地址赋给str成员,如果类中包含了使用new初始化的指针成员，应当定义一个深度复制函数</p></li></ol><h3 id="12-1-4-StringBad的其他问题：赋值运算符"><a href="#12-1-4-StringBad的其他问题：赋值运算符" class="headerlink" title="12.1.4 StringBad的其他问题：赋值运算符"></a>12.1.4 StringBad的其他问题：赋值运算符</h3><ol><li><p>赋值运算符的功能以及何时使用它<br>将已有的对象赋给另一个对象时，将使用重载的赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBad &amp; StringBad::<span class="keyword">operator</span>=(<span class="type">const</span> StringBad &amp;);</span><br><span class="line">so = s1;</span><br><span class="line">使用函数表示法时：</span><br><span class="line">so.<span class="built_in">operator</span>(s1);</span><br></pre></td></tr></table></figure><p>与复制构造函数相似，赋值运算符也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响</p></li><li><p>赋值的问题与复制的问题的一样的</p></li><li><p>解决赋值的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringBad &amp; StringBad::<span class="keyword">operator</span>=(<span class="type">const</span> StringBad &amp;st)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>==&amp;st)     </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">delete</span> [] str;</span><br><span class="line">len = st.len;</span><br><span class="line">str = <span class="keyword">new</span> <span class="type">char</span> [len+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str,st.str);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.函数返回一个指向调用对象的引用(即this指针)<br>2.代码首先检查自我复制，这是通过查看赋值运算符右边的地址(&amp; s)是否与接收对象的地址(this)相同来完成的<br>3.赋值操作并不创建新的对象，因此不需要调整静态数据成员num_strings的值</p></li></ol><h2 id="改进后的新Stirng类"><a href="#改进后的新Stirng类" class="headerlink" title="改进后的新Stirng类"></a>改进后的新Stirng类</h2><ol><li><p>标准字符串函数库cstring的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span>  </span>&#123;<span class="keyword">return</span> len&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="built_in">operator</span>&lt;(<span class="type">const</span> String &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> String &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> String &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;&gt;(istream &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="type">const</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="type">const</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">HowMany</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>c++11空指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>nullptr用于表示空指针</p></li><li><p>重载&gt;&gt;运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is,String &amp; st)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">80</span>];</span><br><span class="line">is.<span class="built_in">get</span>(temp,<span class="number">80</span>)</span><br><span class="line"><span class="keyword">if</span>(is)</span><br><span class="line">str = temp;</span><br><span class="line"><span class="keyword">while</span>(is&amp;&amp;is.<span class="built_in">get</span>()!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为对象数组输入内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String saying[n];</span><br><span class="line"><span class="type">char</span> temp[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin.<span class="built_in">get</span>(temp,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">while</span>(cin&amp;&amp;cin.<span class="built_in">get</span>()!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cin)</span><br><span class="line">saying[i] = temp;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为对象数组输出到屏幕上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;saying[i][<span class="number">0</span>]&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;saying[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找到对象数组中最短的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> shortest = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(saying[i].<span class="built_in">length</span>()&lt;saying[shortest].length)</span><br><span class="line">shortest = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="12-2-2比较成员函数"><a href="#12-2-2比较成员函数" class="headerlink" title="12.2.2比较成员函数"></a>12.2.2比较成员函数</h3><ol><li>将比较函数作为友元，有助于String对象与常规的c字符串进行比较<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;love&quot;</span>==answer)</span><br><span class="line">将被转换为：</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="string">&quot;love&quot;</span>,answer))</span><br><span class="line">然后，编译器将使用某个构造函数将代码转换为：</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="built_in">String</span>(<span class="string">&quot;love&quot;</span>),answer))</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> String &amp; st1,<span class="type">const</span> String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(st1.str,st2.str)&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> String &amp; st1,<span class="type">const</span> String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(st1.str,st2.str)&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> String &amp; st1,<span class="type">const</span> String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(st1.str,st2.str)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="12-2-3使用中括号表示法访问字符"><a href="#12-2-3使用中括号表示法访问字符" class="headerlink" title="12.2.3使用中括号表示法访问字符"></a>12.2.3使用中括号表示法访问字符</h3><ol><li><p>一般是在String类这种数组中，opera[4]不是指它包含有四个对象，而是第四个字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">opera</span><span class="params">(<span class="string">&quot;The Magic Flute&quot;</span>)</span></span>;</span><br><span class="line">opera[<span class="number">4</span>];</span><br><span class="line"><span class="type">char</span> &amp; String::opera[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将r赋给指向means.str[0]的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">means</span><span class="params">(<span class="string">&quot;might&quot;</span>)</span></span>;</span><br><span class="line">means[<span class="number">0</span>]=<span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">means.<span class="keyword">operator</span>[](<span class="number">0</span>)=<span class="string">&#x27;r</span></span><br><span class="line"><span class="string">means.str[0]=&#x27;</span>r<span class="number">&#x27;</span>   访问的是私有数据，但由于<span class="keyword">operator</span>[]()是类的一个方法，因此能够修改数组的内容</span><br></pre></td></tr></table></figure><p>后三者是等同的</p></li><li><p>answer是常量，只能使用常量函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> String <span class="title">answer</span><span class="params">(<span class="string">&quot;futile&quot;</span>)</span></span>;     </span><br><span class="line">如果只有<span class="keyword">operator</span>[]()定义，则下面的代码将出错：</span><br><span class="line">cout&lt;&lt;answer[<span class="number">1</span>];</span><br><span class="line">因此提供常量版本：</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp; String::opera[](<span class="type">int</span> i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="12-2-4-静态类成员函数"><a href="#12-2-4-静态类成员函数" class="headerlink" title="12.2.4 静态类成员函数"></a>12.2.4 静态类成员函数</h3><ol><li><p>不能通过对象调用静态成员函数，甚至不能使用this指针，它不属于对象，属于类，调用它的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = String::<span class="built_in">HowMany</span>();</span><br></pre></td></tr></table></figure><p>可以使用类名和作用域解析运算符调用它，可以访问静态成员num_string，但不能访问str</p></li><li><p>两种的差别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> num_strings;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> CLNLIM = <span class="number">80</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="12-2-5-进一步重载赋值运算符"><a href="#12-2-5-进一步重载赋值运算符" class="headerlink" title="12.2.5 进一步重载赋值运算符"></a>12.2.5 进一步重载赋值运算符</h3><ol><li>将常规字符串复制到String对象中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] str;</span><br><span class="line">len = <span class="built_in">strlen</span>(s);</span><br><span class="line">str = <span class="keyword">new</span> <span class="type">char</span> [len+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str,s);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>一般来说，必须释放str指向的内存</li></ol><h2 id="12-3-在构造函数中使用new时应注意的事项"><a href="#12-3-在构造函数中使用new时应注意的事项" class="headerlink" title="12.3 在构造函数中使用new时应注意的事项"></a>12.3 在构造函数中使用new时应注意的事项</h2><ol><li>如果有多个构造函数，则必须以相同的方式使用new，要么带中括号，要么不带中括号。因为只有一个析构函数，然而将指针初始化为空，两种都兼容</li></ol><h3 id="12-3-1-包含类成员的类的逐成员复制"><a href="#12-3-1-包含类成员的类的逐成员复制" class="headerlink" title="12.3.1 包含类成员的类的逐成员复制"></a>12.3.1 包含类成员的类的逐成员复制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magazine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String title;</span><br><span class="line">string publisher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String和string都使用动态内存分配，但不需要为Magazine类编写复制构造函数和赋值运算符，会将使用成员类定义的复制构造函数和赋值运算符</p><h2 id="12-4-有关返回对象的说明"><a href="#12-4-有关返回对象的说明" class="headerlink" title="12.4 有关返回对象的说明"></a>12.4 有关返回对象的说明</h2><h3 id="12-4-1-返回指向const对象的引用"><a href="#12-4-1-返回指向const对象的引用" class="headerlink" title="12.4.1 返回指向const对象的引用"></a>12.4.1 返回指向const对象的引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Vector &amp; <span class="title">Max</span><span class="params">(<span class="type">const</span> Vector &amp; v1;<span class="type">const</span> Vector &amp; v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v1.<span class="built_in">magval</span>()&gt;v2.<span class="built_in">magval</span>())</span><br><span class="line"><span class="keyword">return</span> v1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个const与返回有关，返回的是v1或v2，v1和v2都被声明为const引用，所有才使用const</p><h3 id="12-4-2-返回指向非const对象引用"><a href="#12-4-2-返回指向非const对象引用" class="headerlink" title="12.4.2 返回指向非const对象引用"></a>12.4.2 返回指向非const对象引用</h3><p>operator&lt;&lt;()的返回类型必须是ostream &amp;，而不能仅仅是ostream。如果使用返回类型ostream，将调用ostream类的复制构造函数，而ostream类没有公有的复制构造函数</p><h3 id="12-4-3-返回对象"><a href="#12-4-3-返回对象" class="headerlink" title="12.4.3 返回对象"></a>12.4.3 返回对象</h3><p>如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，只能是返回对象</p><h2 id="12-5-使用指向对象的指针"><a href="#12-5-使用指向对象的指针" class="headerlink" title="12.5 使用指向对象的指针"></a>12.5 使用指向对象的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String * shortest = &amp;sayings[<span class="number">0</span>];</span><br><span class="line">shortest-&gt;<span class="built_in">length</span>()</span><br></pre></td></tr></table></figure><p>使用结构体的方式来使用成员</p><ol><li>使用new初始化对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String *favorite = <span class="keyword">new</span> <span class="built_in">String</span>(saying[choice]);</span><br><span class="line">将调用复制构造函数：</span><br><span class="line"><span class="built_in">String</span>()</span><br></pre></td></tr></table></figure>这里指针favorite指向new创建的未被命名对象，但复制构造函数会给它创建内容</li></ol><h3 id="12-5-1-再谈定位new运算符"><a href="#12-5-1-再谈定位new运算符" class="headerlink" title="12.5.1 再谈定位new运算符"></a>12.5.1 再谈定位new运算符</h3><p>内存缓冲区实则指的是数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JustTesting</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string words;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *buffer = <span class="keyword">new</span> <span class="type">char</span> [BUF];</span><br><span class="line">JustTesting *pc1,*pc2;，*pc3</span><br><span class="line">pcl = <span class="built_in">new</span> (buffer) JustTesting</span><br><span class="line">pc2 = <span class="keyword">new</span> <span class="built_in">JustTesting</span>(<span class="string">&quot;Heap&quot;</span>,<span class="number">10</span>);</span><br><span class="line">pc3 = <span class="built_in">new</span> (buffer+<span class="built_in">sizeof</span>(JustTesting)) <span class="built_in">JustTesting</span>()</span><br><span class="line"><span class="keyword">delete</span> [] buffer;   要这样做的原因在于：<span class="keyword">delete</span>不能与定位<span class="keyword">new</span>运算符配合使用</span><br><span class="line"><span class="keyword">delete</span> pc2;</span><br></pre></td></tr></table></figure><p>将delete用于pc2，将自动调用为pc2指向的的对象调用析构函数，用于buffer时，不会为使用定位new运算符创建的对象调用析构函数，而是需要显示的调用析构函数<br>，一般情况下将自动调用析构函数，这是需要显示调用析构函数的少数几种情况之一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1-&gt;~<span class="built_in">JustTesting</span>();</span><br></pre></td></tr></table></figure><ol><li><p>cout对地址输出的不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;(<span class="type">void</span> *)buffer&lt;&lt;pc1&lt;&lt;pc2&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>buffer输出地址的方式不同</p></li><li><p>定位new运算符创建的对象的删除顺序与创建的顺序相反。原因在于晚创建的对象可能依赖于早创建的对象，另外当所有对象都被消除后，才能释放缓冲区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p3-&gt;~<span class="built_in">JustTesting</span>();</span><br><span class="line">p1-&gt;~<span class="built_in">JustTesting</span>();</span><br><span class="line"><span class="keyword">delete</span> [] buffer; </span><br></pre></td></tr></table></figure></li></ol><h1 id="第13章-类继承"><a href="#第13章-类继承" class="headerlink" title="第13章 类继承"></a>第13章 类继承</h1><p>面向对象编程的主要目的之一是提供可重用的代码</p><ol><li>通过继承完成的一些工作：<br>可以在已有的基础上添加功能。例如，对于数组类，可以添加数学运算。<br>可以给类添加数据。例如，对于字符串类，可以添加显示颜色的数据成员。<br>可以修改类方法的行为。例如，提供给飞机乘客的服务的类，可以提供更高级别服务的类。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Table::<span class="built_in">Table</span>(<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht):<span class="built_in">firstname</span>(fn),<span class="built_in">lastname</span>(ln),<span class="built_in">hasTable</span>(ht)&#123;&#125;</span><br><span class="line">Table::<span class="built_in">Table</span>(<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht)</span><br><span class="line">&#123;</span><br><span class="line">firstname = fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>初始化列表语法可以减少一个步骤，它直接使用string的复制构造函数将firstname初始化为fny</li></ol><h2 id="13-1-一个简单的基类"><a href="#13-1-一个简单的基类" class="headerlink" title="13.1 一个简单的基类"></a>13.1 一个简单的基类</h2><h3 id="13-1-1"><a href="#13-1-1" class="headerlink" title="13.1.1"></a>13.1.1</h3><p>构造函数必须给新成员和继承的成员提供数据。第二个构造函数使用一个类为参数，包含firstname，lastname，hasTable</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RatePlayer</span>(<span class="type">int</span> r=<span class="number">0</span>,<span class="type">const</span> string &amp; fn=<span class="string">&quot;none&quot;</span>);</span><br><span class="line"><span class="built_in">RatePlayer</span>(<span class="type">int</span> r=<span class="number">0</span>,<span class="type">const</span> TableTennishPlayer &amp; tp);</span><br></pre></td></tr></table></figure><p>继承类的构造函数的写法</p><h3 id="13-1-2-构造函数：访问权限的考虑"><a href="#13-1-2-构造函数：访问权限的考虑" class="headerlink" title="13.1.2 构造函数：访问权限的考虑"></a>13.1.2 构造函数：访问权限的考虑</h3><ol><li><p>派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。列如，RatePlayer构造函数不能直接设置继承的成员，派生类构造函数必须使用基类构造函数</p></li><li><p>创建派生类对象时，程序首先创建基类对象。使用成员初始化列表来完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r,<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht):<span class="built_in">TableTennisPalyer</span>(fn,ln,ht)</span><br><span class="line">&#123;</span><br><span class="line">rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了TableTennisPalyer的构造函数</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r,<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht)</span><br><span class="line">&#123;</span><br><span class="line">rating = r;</span><br><span class="line">&#125;</span><br><span class="line">省略了成员初始化列表，程序将调用默认的基类构造函数，等效有：</span><br><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r,<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht)：<span class="built_in">TableTennisPalyer</span>()</span><br><span class="line">&#123;</span><br><span class="line">rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.第二个构造函数的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r=<span class="number">0</span>,<span class="type">const</span> TableTennishPlayer &amp; tp):<span class="built_in">TableTennishPlayer</span>(tp),<span class="built_in">rating</span>(r) &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>上述方法声明是在类外声明的，与在类内声明的形式有很大的不一样</p></li><li><p>释放对象的顺序与创建对象的顺序相反，先执行派生类的析构函数</p></li></ol><h3 id="13-1-4-派生类和基类之间的特殊关系"><a href="#13-1-4-派生类和基类之间的特殊关系" class="headerlink" title="13.1.4 派生类和基类之间的特殊关系"></a>13.1.4 派生类和基类之间的特殊关系</h3><ol><li><p>基类指针或引用可以指向和引用派生类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">TableTennisPlayer &amp; rt = rplayer;</span><br><span class="line">TableTennisPlayer * pt = &amp;rplayer;</span><br><span class="line">rt.<span class="built_in">Name</span>();</span><br><span class="line">pt-&gt;<span class="built_in">Name</span>();</span><br></pre></td></tr></table></figure><p>基类指针或引用只能用于调用基类方法，不能使用基类指针或引用来调用派生类的方法</p></li><li><p>对于形参为指向基类的指针或引用的函数，也可以使用派生类作为实参，按值传递将派生类对象的基类部分传递给函数 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">const</span> TableTennisPlayher &amp; rt)</span></span></span><br><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="built_in">Show</span>(rplayer1);</span><br><span class="line"><span class="built_in">Show</span>(player1);</span><br></pre></td></tr></table></figure></li><li><p>引用兼容性属性让你能够将基类对象初始化为派生类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(rplayer1)</span></span>;</span><br></pre></td></tr></table></figure><p>要初始化player1,基类要调用构造函数的原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TableTennisPlayer</span>(<span class="type">const</span> RatedPlayer &amp; );</span><br></pre></td></tr></table></figure><p>基类定义中没有这样的构造函数，但存在隐式复制构造函数</p></li><li><p>同样，也可以将派生类对象赋给基类对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">TableTennisPlayer player1;</span><br><span class="line">player1 = rplayer1;</span><br></pre></td></tr></table></figure><p>将使用隐式重载赋值运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TableTennisPlayher &amp; <span class="keyword">operator</span>=(<span class="type">const</span> TableTennisPlayher &amp; )<span class="type">const</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="13-2-继承：is-a关系"><a href="#13-2-继承：is-a关系" class="headerlink" title="13.2 继承：is-a关系"></a>13.2 继承：is-a关系</h2><ol><li><p>公有继承是最常用的方式，它建立一种is-a关系，新类将继承原始类的所有数据成员</p></li><li><p>公有继承不建立has-a关系，has-a关系：午餐有水果，将水果的对象作为午餐类的数据成员</p></li><li><p>公有继承不建立is-like-a关系,即律师就像鲨鱼，不应从鲨鱼类派生出律师类，继承可以在基类的基础上添加基础，但不能删除基类的属性</p></li><li><p>公有继承不建立is-implemented-as-a关系,即作为···来实现，使用数组来实现栈，不可以因为栈不是数组</p></li><li><p>所以坚持使用is-a的关系，当满足is-a的关系，就可以使用公有继承</p></li></ol><h2 id="13-3-多态公有继承"><a href="#13-3-多态公有继承" class="headerlink" title="13.3 多态公有继承"></a>13.3 多态公有继承</h2><ol><li><p>概念：同一个方法在派生类和基类中的行为是不同的即称为多态–具有多种形态</p></li><li><p>两种实现方法：<br>在派生类中重新定义基类的方法<br>使用虚方法</p></li></ol><h3 id="13-3-1-开发Brass类和BrassPlus类"><a href="#13-3-1-开发Brass类和BrassPlus类" class="headerlink" title="13.3.1 开发Brass类和BrassPlus类"></a>13.3.1 开发Brass类和BrassPlus类</h3><ol><li><p>虚方法的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrassPlus</span>:<span class="keyword">public</span> Brass </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在派生类中重新定义基类的方法,但函数名一样的，关键字virtual只用于类声明的方法原型中</p></li><li><p>引用类型或指针类型选择方法在继承类中的使用<br>方法没有使用virtual将根据引用类型或指针类型选择方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">dom</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">dot</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">Brass &amp; bl_ref = dom;   本应该这样定义的</span><br><span class="line">Brass &amp; b2_ref = dot;</span><br><span class="line">bl_ref.<span class="built_in">ViewAcct</span>();</span><br><span class="line">b2_ref.<span class="built_in">ViewAcct</span>();</span><br></pre></td></tr></table></figure><p>引用变量的类型为Brass,所以都为Brass::ViewAcct()</p></li></ol><p>方法使用virtual将根据引用类型或指针类型选择方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">dom</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">dot</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">Brass &amp; bl_ref = dom;   本应该这样定义的</span><br><span class="line">Brass &amp; b2_ref = dot;</span><br></pre></td></tr></table></figure><p>第二个是BrassPlus::ViewAcct()</p><ol start="3"><li><p>可以在派生类方法中调用基类的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::ViewAcct</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Brass::<span class="built_in">ViewAcct</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;df&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该方法是虚方法，是使用作用域解析运算符来调用基类方法，而不是派生类对象来调用方法；如果不是虚方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::ViewAcct</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ViewAcct</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;df&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则不必使用作用域解析运算符</p></li><li><p>使用格式化方法setf()和precision()将浮点值的输出模式设置为定点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建指向Brass的指针数组，可以使用一个数组来表示多种类型的对象，这也是多态，Brass指针既可以指向Brass对象，也可以指向BrassPlus对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Brass * p_clients[<span class="number">4</span>];       与一般的数组定义是完全不一样的</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">p_clients[i]=<span class="keyword">new</span> <span class="built_in">Brass</span>(temp,tempnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是Brass的指针数组,所以可以进行new分配内存</p></li><li><p>类对象的输入与一般的数据输入是不一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string temp;</span><br><span class="line"><span class="type">long</span> tempnum;</span><br><span class="line"><span class="built_in">getline</span>(cin,temp);</span><br><span class="line">cin&gt;&gt;tempnum;</span><br></pre></td></tr></table></figure></li><li><p>多态是由下述代码提供的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">p_clients[i]-&gt;ViewAcct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p_clients[i]指的是指针不是值</p></li><li><p>为何需要虚构函数</p></li></ol><h2 id="13-4-静态联编和动态联编"><a href="#13-4-静态联编和动态联编" class="headerlink" title="13.4 静态联编和动态联编"></a>13.4 静态联编和动态联编</h2><ol><li>在编译过程就知道使用哪一个函数，是静态联编。因为虚函数的存在编译器不知道用户将选择哪种类型的对象，只能在程序运行的时候确定正确的虚函数方法<br>叫动态联编，总之，编译器对虚方法使用动态联编，根据对象类型将ViewAcct()关联到Brass::ViewAcct()或BrassPlus::ViewAcct()</li></ol><h3 id="13-4-1-指针和引用类型的兼容性"><a href="#13-4-1-指针和引用类型的兼容性" class="headerlink" title="13.4.1 指针和引用类型的兼容性"></a>13.4.1 指针和引用类型的兼容性</h3><ol><li><p>c++不允许将一种类型地址或引用赋给另一种类型的指针或引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">2.5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x;</span><br><span class="line"><span class="type">long</span> &amp; rl = x;</span><br></pre></td></tr></table></figure><p>但基类和派生类可以，而不必进行类型转换</p></li><li><p>虚函数的工作原理：<br>给每个对象添加一个隐藏成员，隐藏成员是一个指向函数地址数组的指针，被称为虚函数表</p></li><li><p>虚析构函数<br>析构函数应当是虚函数，即使它不执行任何操作，除非类不用做基类，析构函数不应进行delete操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">BaseClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Employee *pe = <span class="keyword">new</span> Singer;</span><br><span class="line"><span class="keyword">delete</span> pe;</span><br></pre></td></tr></table></figure><p>如果没有虚析构函数，delete语句将调用<del>Employer()析构函数，将释放派生类对象中的基类部分指向的内存，但不会释放新的类成员指向的内存，如果有虚析构函<br>数则先调用</del>Singer析构函数，在调用~Employer()析构函数</p></li><li><p>虚函数的参数要相同，但返回值可以不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Dwelling &amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span>:<span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Hovel &amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新定义将隐藏方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">long</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">两个都将被隐藏</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span>:<span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span>  <span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新定义继承的方法并不是重载，将隐藏所有的同名基类的方法</p></li></ol><h2 id="13-5-访问控制：protected"><a href="#13-5-访问控制：protected" class="headerlink" title="13.5 访问控制：protected"></a>13.5 访问控制：protected</h2><ol><li>protected与private相似，在类外只能用公有类成员来访问protected部分中的类成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">doubloe balance;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">doubloe balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>区别在于继承方面：派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员，在派生类中与公有成员相识。例如可以编写<br>BrassPlus::Withdraw()<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(amt&lt; balance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>只有在派生类中可以这样使用，保护数据成员可以简化代码的编写工作，但又使保护数据成员balance成为公有变量，被轻易修改</li></ol><h2 id="13-6-抽象基类-ABC"><a href="#13-6-抽象基类-ABC" class="headerlink" title="13.6 抽象基类(ABC)"></a>13.6 抽象基类(ABC)</h2><ol><li><p>前面已经接受了简单继承和多态继承</p></li><li><p>另一种建立继承的方法：Ellipse类和Circle类有共点，可以建立拥有他们共同点的类BaseEllipse，这个类还包含Ellipse类和Circle类不的同的方法，应<br>被声明为虚函数，但至少应有一个纯虚函数</p></li><li><p>抽象函数通过使用纯虚函数来提供未实现的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseEllipse</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类声明中包含纯虚函数时，则不能创建该类的对象，只能用做基类，因此可以从BaseEllipse类派生出Ellipse类和Circle类</p></li><li><p>Ellipse类和Circle类被称为具体类，具有相同的基类，可以用BaseEllipse指针数组同时管理这两种对象</p></li><li><p>BaseEllipse类的纯虚函数也应该定于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BaseEllipse::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">balance -= amt; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">balance -= amt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="13-6-1-应用ABC概念"><a href="#13-6-1-应用ABC概念" class="headerlink" title="13.6.1 应用ABC概念"></a>13.6.1 应用ABC概念</h3><ol><li>ABC是一种必须实施的接口，这种模式在基于组件的编程模式中很常见，每个ABC或者派生类是组件</li></ol><h2 id="13-7-继承和动态内存分配"><a href="#13-7-继承和动态内存分配" class="headerlink" title="13.7 继承和动态内存分配"></a>13.7 继承和动态内存分配</h2><h2 id="13-7-1-第一种情况：派生类不使用new"><a href="#13-7-1-第一种情况：派生类不使用new" class="headerlink" title="13.7.1 第一种情况：派生类不使用new"></a>13.7.1 第一种情况：派生类不使用new</h2><ol><li>基类使用动态内存分配，包含特殊方法：析构函数，复制构造函数，重载赋值运算符，而派生类不需要</li></ol><h2 id="13-7-2-第二种情况：派生类使用new"><a href="#13-7-2-第二种情况：派生类使用new" class="headerlink" title="13.7.2 第二种情况：派生类使用new"></a>13.7.2 第二种情况：派生类使用new</h2><ol><li>必须为派生类定义特殊方法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">派生类的析构函数：</span><br><span class="line">baseDMA::~<span class="built_in">baseDMA</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> [] label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::~<span class="built_in">hasDMA</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> [] style;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>派生类的复制构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hasDMA::<span class="built_in">hasDMA</span>(<span class="type">const</span> hasDMA &amp;hs)</span><br><span class="line">         ：<span class="built_in">baseDMA</span>(hs)     是基类的引用可以指向派生类型</span><br><span class="line">&#123;</span><br><span class="line">style = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(style,hs.style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派生类的重载赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hasDMA &amp; hasDMA::<span class="keyword">operator</span>=(<span class="type">const</span> hasDMA &amp;hs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;hs)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">baseDMA::<span class="keyword">operator</span>=(hs);    显示调用基类赋值运算符</span><br><span class="line"><span class="keyword">delete</span> [] style;</span><br><span class="line">style = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(style,hs.style);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;    对<span class="keyword">this</span>指针的返回，返回类型也是引用</span><br><span class="line">&#125;</span><br><span class="line">baseDMA::<span class="keyword">operator</span>=(hs)不可用*<span class="keyword">this</span> = hs代替不然编译器会hasDMA::<span class="keyword">operator</span>=()，从而形成递归调用</span><br></pre></td></tr></table></figure><h3 id="13-7-3-友元的继承"><a href="#13-7-3-友元的继承" class="headerlink" title="13.7.3 友元的继承"></a>13.7.3 友元的继承</h3><ol><li>hasDMA类的友元访问label和rating的方法：使用强制类型转换<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">baseDMA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *label;</span><br><span class="line"><span class="type">int</span> rating;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> baseDMA &amp; rs)</span><br><span class="line">&#123;</span><br><span class="line">os &lt;&lt; rs.rating &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> hasDMA &amp; hs)</span><br><span class="line">&#123;</span><br><span class="line">os &lt;&lt; (<span class="type">const</span> baseDMA &amp;)hs;</span><br><span class="line">os &lt;&lt; hs.style &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="第14章-c-中的代码重用"><a href="#第14章-c-中的代码重用" class="headerlink" title="第14章 c++中的代码重用"></a>第14章 c++中的代码重用</h1><ol><li>可以定义一个通用的栈模板，然后创建表示int或double值栈的类</li></ol><h2 id="14-1-包含对象成员的类"><a href="#14-1-包含对象成员的类" class="headerlink" title="14.1 包含对象成员的类"></a>14.1 包含对象成员的类</h2><ol><li>对于考试分数，可以使用一个定长数组，这限制了数组的长度；可以使用动态内存分配的指针，并提供大量的支持代码；也可以使用动态内存分配的类表示该数组；<br>还可以在标准c++库中查找一个表示这种数据的类，自己开发这样的类一点问题也没有</li></ol><h3 id="14-1-1-valarray类简介"><a href="#14-1-1-valarray类简介" class="headerlink" title="14.1.1 valarray类简介"></a>14.1.1 valarray类简介</h3><ol><li><p>它支持将数组中所有元素的值相加以及在数组中找出最大和最小的值的操作，提供的算术支持比vector和array的多</p></li><li><p>几个使用其构造函数的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="type">double</span> gpa[<span class="number">5</span>] = &#123;<span class="number">3.1</span>,<span class="number">3.5</span>,<span class="number">3.8</span>,<span class="number">2.9</span>,<span class="number">3.3</span>&#125;;</span><br><span class="line">valarray &lt;<span class="type">double</span>&gt; v1;</span><br><span class="line">valarray &lt;<span class="type">int</span>&gt; <span class="built_in">v2</span>(<span class="number">8</span>);  指定长度的空数组</span><br><span class="line">valarray &lt;<span class="type">int</span>&gt; <span class="built_in">v3</span>(<span class="number">10</span>,<span class="number">8</span>);</span><br><span class="line">valarray &lt;<span class="type">double</span>&gt; <span class="built_in">v4</span>(gpa,<span class="number">4</span>);</span><br><span class="line">valarray &lt;<span class="type">int</span>&gt; v5 = &#123;<span class="number">12</span>,<span class="number">32</span>,<span class="number">34</span>&#125;;    初始化列表</span><br></pre></td></tr></table></figure><p>先有长度再有数值，长度放后面</p></li><li><p>这个类的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()   返回数组的长度</span><br><span class="line"><span class="built_in">length</span>()     返回字符串的长度</span><br><span class="line"><span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">min</span>()</span><br></pre></td></tr></table></figure></li></ol><h3 id="14-1-2-Student类的设计"><a href="#14-1-2-Student类的设计" class="headerlink" title="14.1.2 Student类的设计"></a>14.1.2 Student类的设计</h3><ol><li><p>可以从string和valarray这两个类，派生出Student类，这是多重公有继承(一种is-a关系),但这里并不合适，学生类与这些类不是is-a的关系</p></li><li><p>模板类一般使用自定义的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">privatef:</span><br><span class="line"><span class="keyword">typedef</span> std::valarray&lt;<span class="type">double</span>&gt; ArrayDb;     也在<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放在私有部分意味着可以在Student类的实现中使用它，当在Student类外面不能使用</p></li><li><p>在Student类中，可以直接使用string和valarray这两个类的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>():<span class="built_in">name</span>(<span class="string">&quot;Null Student&quot;</span>),<span class="built_in">scores</span>()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">const</span> string &amp; s)</span>:name(s),scores()&#123;</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">int</span> n)</span>:name(<span class="string">&quot;Nully&quot;</span>),scores(n)&#123;</span>&#125;</span><br><span class="line"><span class="built_in">Studeent</span>(<span class="type">const</span> string &amp; s,<span class="type">int</span> n):<span class="built_in">name</span>(s),<span class="built_in">scores</span>(n)&#123;&#125;</span><br><span class="line"><span class="built_in">Studeent</span>(<span class="type">const</span> string &amp; s,<span class="type">const</span> ArrayDb &amp; a):<span class="built_in">name</span>(s),<span class="built_in">scores</span>(a)&#123;&#125;</span><br><span class="line"><span class="built_in">Studeent</span>(<span class="type">const</span> <span class="type">char</span> *str,<span class="type">const</span> <span class="type">double</span> *pd,<span class="type">int</span> n):<span class="built_in">name</span>(str),<span class="built_in">scores</span>(pd,n)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化被包含的对象时，构造函数将使用成员名，因为初始化的是成员对象，而不是继承的对象</p></li><li><p>在构造函数有一个参数时，考虑隐式转换函数，没有使用explicit可以写如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> n):<span class="built_in">name</span>(<span class="string">&quot;Nully&quot;</span>),<span class="built_in">scores</span>(n)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">doh</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>将创建一个Nully,5个元素的doh对象，但着一般是不允许的</p></li></ol><p>如果使用了explicit：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">int</span> n)</span>:name(<span class="string">&quot;Nully&quot;</span>),scores(n)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">doh</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>将会发生错误</p><ol start="5"><li><p>初始化顺序：它们被声明的顺序，而不是它们在初始化列表中的顺序  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Studeent</span>(<span class="type">const</span> string &amp; s,<span class="type">int</span> n):<span class="built_in">scores</span>(n),<span class="built_in">name</span>(s)&#123;&#125;</span><br></pre></td></tr></table></figure><p>先初始化name成员而不是scores成员，在一个成员的值作为另一个成员的初始化表达式的一部分使，初始化的顺序就非常重要</p></li><li><p>stu.name是一个string对象，所以调用函数operator&lt;&lt;(ostream &amp;,const string &amp;)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="type">const</span> Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">os&lt;&lt;stu.name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scores.<span class="built_in">sum</span>()</span><br><span class="line">scores.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><p>可以使用scores类的方法，同样该函数也可以实现valarray的输出，但scores没有&lt;&lt;重载运算符，因此，Student类定义了一个私有辅助方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp; <span class="title">Student::arr_out</span><span class="params">(ostram &amp; os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> lim = scores.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span>(lim&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lim;i++)</span><br><span class="line">&#123;</span><br><span class="line">os&lt;&lt;scores[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">4</span>) os&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">5</span>!=<span class="number">0</span>)</span><br><span class="line">os&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="type">const</span> Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">os&lt;&lt;stu.name&lt;&lt;endl;</span><br><span class="line">stu.<span class="built_in">arr_out</span>(os);</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> &amp; Student::<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> scores[i];    引用返回的更快</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在包含main()函数的文件中一般还自定义函数</p></li></ol><h2 id="14-2-私有继承"><a href="#14-2-私有继承" class="headerlink" title="14.2 私有继承"></a>14.2 私有继承</h2><ol><li><p>另一种实现has-a关系的途径–私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，可以在派生类的成员函数中使用它们，<br>即只能在派生类的方法中使用基类的方法,has-a是使用接口，与包含的特性一致,也是将另外两个类的对象做为Student的成员，is-a是使用实现</p></li><li><p>访问限定符的默认类型是私有private</p></li><li><p>Student类应从两个类派生而来,使用多个基类的继承被称为多重继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">private</span> string,<span class="keyword">private</span> valarray&lt;<span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>包含与私有继承的区别：包含提供了两个对象成员，而私有继承提供了两个无名的子对象成员</p></li></ol><h3 id="14-2-1-初始化基类组件"><a href="#14-2-1-初始化基类组件" class="headerlink" title="14.2.1 初始化基类组件"></a>14.2.1 初始化基类组件</h3><ol><li><p>有隐式地继承组件和显式地包含组件</p></li><li><p>私有继承类的构造函数将使用类名来初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">const</span> <span class="type">double</span> * pd,<span class="type">int</span> n) ：<span class="built_in">string</span>(str),<span class="built_in">ArrayDb</span>(pd,n) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="14-2-2-访问基类的方法"><a href="#14-2-2-访问基类的方法" class="headerlink" title="14.2.2 访问基类的方法"></a>14.2.2 访问基类的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Student::Average</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ArrayDb::<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ArrayDb::<span class="built_in">sum</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有确定对象时可以使用类名和作用域解析运算符来调用基类的方法，但函数的作用域与方法的作用域不一致时，就使用解析运算符</p><h3 id="14-2-3-访问基类对象"><a href="#14-2-3-访问基类对象" class="headerlink" title="14.2.3 访问基类对象"></a>14.2.3 访问基类对象</h3><ol><li>使用强制类型转换，将Student对象转换为string对象，*this表示Student对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp; <span class="title">Student::Name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">const</span> string &amp;) *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>为避免调用构造函数创建新的对象，可使用强制类型转换来创建一个引用</li></ol><h3 id="14-2-3-访问基类的友元函数"><a href="#14-2-3-访问基类的友元函数" class="headerlink" title="14.2.3 访问基类的友元函数"></a>14.2.3 访问基类的友元函数</h3><p>用类名显式地限定函数名不合适于友元函数，可以使用显示地转换为基类来调用正确的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="type">const</span> Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">os&lt;&lt;(<span class="type">const</span> string &amp;)stu;      不修改的强制类型转换</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">cout&lt;&lt;plato;    调用时并不是输出Student类的全部成员，而只是string要进入函数里面去看过程</span><br></pre></td></tr></table></figure><h3 id="14-2-4-使用修改后的Student类"><a href="#14-2-4-使用修改后的Student类" class="headerlink" title="14.2.4 使用修改后的Student类"></a>14.2.4 使用修改后的Student类</h3><ol><li><p>两个版本的Student类的公有接口(方法)完全相同，因此可以使用同一个程序测试它们</p></li><li><p>使用包含比私有继承好，如果某个类需要3个string对象，可以使用包含声明3个独立的string成员，如果新类需要访问原有类的保护成员，<br>或需要重新定义虚函数，则应使用私有继承</p></li></ol><h3 id="14-2-5-保护继承"><a href="#14-2-5-保护继承" class="headerlink" title="14.2.5 保护继承"></a>14.2.5 保护继承</h3><p>第三代类体现出保护继承和私有继承的区别</p><h3 id="14-2-6-使用using重新定义访问权限"><a href="#14-2-6-使用using重新定义访问权限" class="headerlink" title="14.2.6 使用using重新定义访问权限"></a>14.2.6 使用using重新定义访问权限</h3><p>1.在派生类类外调用基类对象的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Student::sum</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> valarray&lt;<span class="type">double</span>&gt;::<span class="built_in">sum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用一个using声明来指出派生类可以使用特定的基类成员，即使采用的是私有派生<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">private</span> string,<span class="keyword">private</span> valarray&lt;<span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> valarray&lt;<span class="type">double</span>&gt;::min;</span><br><span class="line"><span class="keyword">using</span> valarray&lt;<span class="type">double</span>&gt;::max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stu.min;  可以这样使用</span><br></pre></td></tr></table></figure>using声明只使用成员名——没有圆括号，函数特征标和返回类型</li></ol><h2 id="14-3-多重继承"><a href="#14-3-多重继承" class="headerlink" title="14.3 多重继承"></a>14.3 多重继承</h2><h2 id="14-4-类模板"><a href="#14-4-类模板" class="headerlink" title="14.4 类模板"></a>14.4 类模板</h2><ol><li>不如编写一个泛型栈，然后将具体的类型作为参数传递给这个类，这样就可以使用不同类型的栈，例如int栈和string栈</li></ol><h3 id="14-4-1-定义模板类"><a href="#14-4-1-定义模板类" class="headerlink" title="14.4.1 定义模板类"></a>14.4.1 定义模板类</h3><ol start="2"><li>templat为函数名，尖括号中的内容相当于函数的参数列表，class&#x2F;typename看作是变量的类型名，Type看作变量的名称<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br></pre></td></tr></table></figure>可以使用模板成员函数替换原有类的类方法。每个函数头都将以相同模板声明打头</li></ol><p>应改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Item items[MAX];--&gt;Type items[MAX];</span><br><span class="line">Stack::--&gt;Stack&lt;type&gt;::       作用域解析符与类名也要改</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;Type&gt;::<span class="built_in">isEmpty</span>(<span class="type">const</span> Type &amp; item) &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果在类声明中定义了方法(内联定义)，则可以省略模板前缀和类限定符</p><ol start="3"><li>不能将模板成员函数放在独立的实现文件中，由于模板不是函数，它们不能单独编译</li></ol><h3 id="14-4-2-使用类模板"><a href="#14-4-2-使用类模板" class="headerlink" title="14.4.2 使用类模板"></a>14.4.2 使用类模板</h3><ol><li>使用的算法必须与类型一致，一般int与string是可以用在同一个模板类中的，string栈与指针栈有相同的功能，但不能用在同一个模板类中</li></ol><h3 id="14-4-3-指针栈-x2F-指针模板"><a href="#14-4-3-指针栈-x2F-指针模板" class="headerlink" title="14.4.3 指针栈&#x2F;指针模板"></a>14.4.3 指针栈&#x2F;指针模板</h3><ol><li><p>使用一个指针数组，其中每个指针都指向不同的字符串，用使用动态数组</p></li><li><p>返回类型为类时也要使用Stack<Type></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Stack &amp; st);   这是缩写，只能在类中使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> Stack &amp; st) &#123;&#125;   </span><br></pre></td></tr></table></figure></li></ol><h3 id="14-4-4-数组模板示例和非类型参数"><a href="#14-4-4-数组模板示例和非类型参数" class="headerlink" title="14.4.4 数组模板示例和非类型参数"></a>14.4.4 数组模板示例和非类型参数</h3><ol><li><p>模板常用作容器类，主要是为容器类提供可重用代码</p></li><li><p>数组模板的成员是数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br></pre></td></tr></table></figure><p>为类型参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayTP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T ar[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为非类型或表达式参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">double</span>,<span class="number">12</span>&gt;eqqweights;</span><br></pre></td></tr></table></figure><p>编译器将使用double替换T，使用12替换n</p></li><li><p>表达式参数可以是整型，枚举，引用或指针，因此，double m是不合法的，但double *rm是合法的<br>模板代码不能修改参数的值，也不能使用参数的地址，如n++和&amp;n<br>用作参数的值必须是常量表达式</p></li><li><p>介绍一个允许指定数组大小的简单数组模板：<br>第一种：使用动态数组和构造函数参数来提供元素数目<br>第二种：使用模板参数来提供常规数组的大小，array就是这样做的</p></li><li><p>表达式参数方法的缺点：每种数组大小都将生成自己的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">double</span>,<span class="number">12</span>&gt; eqqweights;</span><br><span class="line">ArrayTP&lt;<span class="type">double</span>,<span class="number">13</span>&gt; donuts;</span><br></pre></td></tr></table></figure><p>将生成两个独立的类声明</p></li><li><p>使用动态数组和构造函数参数的方法的优点：更通用，数组大小是作为类成员存储在定义中的，可以将一种大小的数组赋给另一种大小的数组</p></li></ol><h3 id="14-4-4-模板的多功能性"><a href="#14-4-4-模板的多功能性" class="headerlink" title="14.4.4 模板的多功能性"></a>14.4.4 模板的多功能性</h3><ol><li><p>模板类可用作基类，也可用作组件类，还可用作其他模板的类型参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T entry;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrowArray</span> : <span class="keyword">public</span> Array&lt;Type&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">Array&lt;Tp&gt; ar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array&lt; Stack&lt;<span class="type">int</span>&gt; &gt; asi;</span><br></pre></td></tr></table></figure></li><li><p>递归使用模板：对于前面的数组模板定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt; ArrayTP&lt;<span class="type">int</span>,<span class="number">5</span>&gt; <span class="number">10</span>&gt; twodee;</span><br></pre></td></tr></table></figure><p>这使得twodee是一个包含10个元素的数组，其中每个元素都是一个包含5个int元素的数组，与之等价的常规数组声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> towdee[<span class="number">10</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>即使没有这样的函数也可以这样使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">twodee[i][j]=<span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制输出宽度的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">width</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用多个类型参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Pair&lt;string,<span class="type">int</span>&gt;</span><br></pre></td></tr></table></figure><p>模板类的类名是Pair&lt;string,int&gt;，而不是Pair</p></li><li><p>默认类型模板参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Top&#123;...&#125;</span><br><span class="line">Top&lt;<span class="type">double</span>&gt; m1;    T2为<span class="type">int</span>型</span><br><span class="line">Top&lt;<span class="type">double</span> <span class="type">double</span>&gt; m2;  T2为<span class="type">double</span>型</span><br></pre></td></tr></table></figure></li></ol><h3 id="14-4-6-模板的具体化"><a href="#14-4-6-模板的具体化" class="headerlink" title="14.4.6 模板的具体化"></a>14.4.6 模板的具体化</h3><ol><li><p>隐式实例化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">int</span>,<span class="number">100</span>&gt; stuff;</span><br></pre></td></tr></table></figure></li><li><p>显式实例化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">ArrayTP</span>&lt;string,<span class="number">100</span>&gt;;</span><br></pre></td></tr></table></figure><p>之后将生成一个类</p></li><li><p>显式具体化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortedArray</span> &#123;....&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设模板使用&gt;运算符来对值进行比较，对于数字，这管用;如果T是const char *，将不管用，这将要求类定义使用strcmp()，而不是&gt;来对值进行比较，这种情况下<br>可以提供一个显式模板具体化，即为一种具体类型定义的模板，而不是泛型定义的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">class</span> <span class="title class_">SortedArray</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;</span><br><span class="line"></span><br><span class="line">SortedArray&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line">SortedArray&lt;<span class="type">const</span> <span class="type">char</span> *&gt;dates;</span><br></pre></td></tr></table></figure></li></ol><p>4.部分具体化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Feed</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>*&gt; <span class="keyword">class</span> <span class="title class_">Feed</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">Feed&lt;<span class="type">char</span>&gt; fb1;</span><br><span class="line">Feed&lt;<span class="type">char</span> *&gt; fb2;</span><br></pre></td></tr></table></figure><p>第二个声明使用通用模板时，将T转换为char *类型，如果是部分具体化，T将转换为char</p><ol start="5"><li>模板该考虑的类型：常规类型，char，char *a， string，ArrayTP，ArrayTP&lt;int,5&gt;</li></ol><h3 id="14-4-7-成员模板"><a href="#14-4-7-成员模板" class="headerlink" title="14.4.7 成员模板"></a>14.4.7 成员模板</h3><p>模板可用作结构，类或模板类的成员</p><ol><li>在beta模板外定义hold类和blah方法，模板是嵌套的，还必须指出hold和blab是beta<T>类的成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">beta</span>&lt;T&gt;::hold &#123;...&#125;</span><br></pre></td></tr></table></figure>而不能使用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> V&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="14-4-8-将模板用作参数"><a href="#14-4-8-将模板用作参数" class="headerlink" title="14.4.8 将模板用作参数"></a>14.4.8 将模板用作参数</h3><p>是可以将类进行更改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Thing</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crab</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Thing&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Crab&lt;Stack&gt; nebula;</span><br></pre></td></tr></table></figure><h3 id="14-4-8-模板类和友元"><a href="#14-4-8-模板类和友元" class="headerlink" title="14.4.8 模板类和友元"></a>14.4.8 模板类和友元</h3><h3 id="14-4-8-模板别名"><a href="#14-4-8-模板别名" class="headerlink" title="14.4.8 模板别名"></a>14.4.8 模板别名</h3><h1 id="第15章-友元、异常和其他"><a href="#第15章-友元、异常和其他" class="headerlink" title="第15章 友元、异常和其他"></a>第15章 友元、异常和其他</h1><h2 id="15-1-友元"><a href="#15-1-友元" class="headerlink" title="15.1 友元"></a>15.1 友元</h2><p>友元类的所有方法都可以访问原始类的私有成员和保护成员</p><h3 id="15-1-1-友元类"><a href="#15-1-1-友元类" class="headerlink" title="15.1.1 友元类"></a>15.1.1 友元类</h3><ol><li>编写一个模拟电视机和遥控器的简单程序，遥控器可以改变电视机的状态，而不是is-a,has-a的关系，因此将Romote类作为Tv类的一个友元，必须先定义Tv<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Remote</span>;</span><br><span class="line">...    </span><br><span class="line">&#125;;   放在公有位置</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">volup</span><span class="params">(Tv &amp; t)</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">volup</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>满足的是一种先有电视再有遥控器的关系</li></ol><h3 id="15-1-2-友元成员函数"><a href="#15-1-2-友元成员函数" class="headerlink" title="15.1.2 友元成员函数"></a>15.1.2 友元成员函数</h3><ol><li><p>让特定是类成员成为另一个类的友元，而不必让整个类成为友元</p></li><li><p>让Remote::set_chan()成为Tv类的友元的方法是，在Tv类声明中将其声明为友元,set_chan()使用的是Tv类的成员，所以必须是友元</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span></span>;</span><br><span class="line">...    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>必须使用前向声明(forward declaration)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span>;</span><br></pre></td></tr></table></figure></li><li><p>Remote声明中只包含方法声明，并将实际的定义放在Tv类之后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_mode</span><span class="params">(Tv &amp;t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span> </span>&#123;t.channel = c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Remote::set_mode</span><span class="params">(Tv &amp;t)</span> </span>&#123;t.<span class="built_in">set_mode</span>();&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="15-1-3-其他友元关系"><a href="#15-1-3-其他友元关系" class="headerlink" title="15.1.3 其他友元关系"></a>15.1.3 其他友元关系</h3><h3 id="15-1-4-共同的友元"><a href="#15-1-4-共同的友元" class="headerlink" title="15.1.4 共同的友元"></a>15.1.4 共同的友元</h3><h2 id="15-2-嵌套类"><a href="#15-2-嵌套类" class="headerlink" title="15.2 嵌套类"></a>15.2 嵌套类</h2><ol><li><p>对类进行嵌套与包含并不同，包含意味着将类对象作为另一个类成员，而对类进行嵌套不创建类成员，而是定义了一种类型程序的其他部分</p></li><li><p>在方法文件中定义构造函数，则定义必须指出Node类是在Queue类中定义的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue::Node::<span class="built_in">Node</span>(<span class="type">const</span> Item &amp;i) : <span class="built_in">item</span>(i),<span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="15-2-1-嵌套类和访问权限"><a href="#15-2-1-嵌套类和访问权限" class="headerlink" title="15.2.1 嵌套类和访问权限"></a>15.2.1 嵌套类和访问权限</h2><ol><li><p>类的默认访问权限是私有的，Queue队列类是嵌套类</p></li><li><p>嵌套类是在另一个类的私有部分声明的，只有类成员可以使用对象和指向嵌套类对象的指针，派生类和外部世界不知道它的存在<br>如果是保护部分声明的，派生类可见并且可以创建这种类型的对象，但对于外部是不可见的<br>如果是公有部分声明的，允许派生类和外部世界使用它<br>嵌套结构和枚举的作用也是相同的</p></li><li><p>有一个失业的教练，他不属于任何球队，可以在Team类的外面创建Coach对象,是这种关系的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Team</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coach</span> &#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Team::Coach forhire;</span><br></pre></td></tr></table></figure></li><li><p>Queue类对象只能显示地访问Node节点类对象的公有成员，因为Node类的所有成员都被声明为公有的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Item item;</span><br><span class="line">Node *next:</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">const</span> Item &amp;i) : <span class="built_in">item</span>(i),<span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node *front;</span><br><span class="line">Node *rear;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="15-2-2-模板中的嵌套"><a href="#15-2-2-模板中的嵌套" class="headerlink" title="15.2.2 模板中的嵌套"></a>15.2.2 模板中的嵌套</h2><p>Queue类定义转换为模板，是一种容器类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueueTp&lt;<span class="type">double</span>&gt; dq;</span><br><span class="line"></span><br><span class="line"><span class="function">QueueTp&lt;string&gt; <span class="title">cs</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">//可以连续输入5次</span></span><br><span class="line">string temp;</span><br><span class="line"><span class="keyword">while</span>(!cs.<span class="built_in">isfull</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">getline</span>(cin,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Node被定义成用于存储double的值</p><h2 id="15-3异常"><a href="#15-3异常" class="headerlink" title="15.3异常"></a>15.3异常</h2><h2 id="15-4-RTTI"><a href="#15-4-RTTI" class="headerlink" title="15.4 RTTI"></a>15.4 RTTI</h2><ol><li>RTTI是运行阶段类型识别的简称，旨在为程序在运行阶段确定对象的类型提供一种标准方式</li></ol><h2 id="15-4-1-RTTI的用途"><a href="#15-4-1-RTTI的用途" class="headerlink" title="15.4.1 RTTI的用途"></a>15.4.1 RTTI的用途</h2><p>有一个类层次结构，其中的类都是从同一个基类派生而来的，则可以让基类指针指向其中任何一个类的对象</p><h2 id="15-4-2-RTTI的工作原理"><a href="#15-4-2-RTTI的工作原理" class="headerlink" title="15.4.2 RTTI的工作原理"></a>15.4.2 RTTI的工作原理</h2><ol><li><p>RTTI只适用于包含虚函数的类，是用于基类指针与派生类的转换</p></li><li><p>dynamic_cast运算符，使一个基类指针指向一个派生类的指针，如果失败将空指针赋给指针，使得进行向上转换(is-a的关系)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grand</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Supeerd</span> : <span class="keyword">public</span> Grand;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Magnificent</span> : <span class="keyword">public</span> Supeerd;</span><br><span class="line"></span><br><span class="line">Grand *pg = <span class="keyword">new</span> Grand;</span><br><span class="line">Superd *ps = <span class="keyword">new</span> Supeerd;</span><br><span class="line"></span><br><span class="line">pg = <span class="built_in">GetOne</span>();</span><br><span class="line">ps = <span class="built_in">dynamic_cast</span>&lt;Superd *&gt;(pg);</span><br><span class="line">ps-&gt;<span class="built_in">Say</span>();</span><br></pre></td></tr></table></figure><p>这样ps可以在pg的基础上使用Say()成员(Grand类并没有这个函数，Superd有这个函数)</p></li><li><p>typeid运算符和type_info类</p></li></ol><h2 id="15-5-类型转换运算符"><a href="#15-5-类型转换运算符" class="headerlink" title="15.5 类型转换运算符"></a>15.5 类型转换运算符</h2><ol><li><p>在c语言中都是允许的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> data[<span class="number">200</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Junk</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> junk[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Data d = &#123;<span class="number">2.5e33</span>,<span class="number">3.5e-19</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *pch = (<span class="type">char</span> *) (&amp;d);  <span class="comment">//可以将结构里的成员类型发生转换，转换为字符串</span></span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">char</span> (&amp;d);       <span class="comment">//将地址转换为字符</span></span><br><span class="line">Junk *pj = (Junk *) (&amp;d);  <span class="comment">//将结构里的成员类型发生转换，转换为整型</span></span><br></pre></td></tr></table></figure></li><li><p>const_cast运算符将改变值为const或volatile，类型的其他方面不能被修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">High bar;</span><br><span class="line"><span class="type">const</span> High *pbar = &amp;bar;</span><br><span class="line">High *pb = <span class="built_in">const_cast</span>&lt;High *&gt;(pbar);</span><br></pre></td></tr></table></figure></li><li><p>static_cast运算符是进行向下转换的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">High bar;</span><br><span class="line">Low blow;</span><br><span class="line"></span><br><span class="line">Low *pl = <span class="built_in">static_cast</span>&lt;Low *&gt;(&amp;bar);</span><br></pre></td></tr></table></figure></li><li><p>reinterpret_cast运算符将进行重新解释，将一种类型转换为另一种类型</p></li></ol><h1 id="第16章-string类和标准模板库"><a href="#第16章-string类和标准模板库" class="headerlink" title="第16章 string类和标准模板库"></a>第16章 string类和标准模板库</h1><ol><li>STL编程是一种泛型编程，STL(标准模板库)是用于处理各种容器对象的模板</li></ol><h2 id="16-1-string类"><a href="#16-1-string类" class="headerlink" title="16.1 string类"></a>16.1 string类</h2><ol><li>头文件string.h和cstring支持对c风格字符串进行操纵，不支持string类</li></ol><h3 id="16-1-1-构造字符串"><a href="#16-1-1-构造字符串" class="headerlink" title="16.1.1 构造字符串"></a>16.1.1 构造字符串</h3><ol><li>string类的构造函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">one</span><span class="params">(<span class="string">&quot;Lottery&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">two</span><span class="params">(<span class="number">20</span>,<span class="string">&#x27;s&#x27;</span>)</span></span>;   <span class="comment">//初始化为ssssssssssssssssss</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">three</span><span class="params">(one)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> alsfs[<span class="number">20</span>] = <span class="string">&quot;Alsfsaell&quot;</span>;</span><br><span class="line">one += <span class="string">&quot;oops&quot;</span>;    <span class="comment">//+=运算符被多次重载，可以使用C-风格字符串或char值</span></span><br><span class="line">one += alsfs;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">four</span><span class="params">(one,<span class="number">3</span>,<span class="number">6</span>)</span></span>;   <span class="comment">//从one中取出从第3个到第6个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> alls[<span class="number">20</span>] = <span class="string">&quot;Allwell&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">five</span><span class="params">(alls,<span class="number">20</span>)</span></span>;   <span class="comment">//取前20字母</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">six</span><span class="params">(alls+<span class="number">2</span>,alls+<span class="number">4</span>)</span></span>;  <span class="comment">//取alls[2]到alls[4]</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">seven</span><span class="params">(&amp;five[<span class="number">2</span>],&amp;five[<span class="number">4</span>])</span></span>;  <span class="comment">//取five[2]到five[4]</span></span><br><span class="line">不可<span class="function">string <span class="title">seven</span><span class="params">(five+<span class="number">2</span>,five+<span class="number">4</span>)</span></span>;  <span class="comment">//five不是指针地址</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure></li><li>C++11 新增的构造函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> (string &amp;&amp; str);  <span class="comment">//移动构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> (initializer_list&lt;<span class="type">char</span>&gt; il);  <span class="comment">//列表初始化</span></span><br><span class="line">string piano_man = &#123;<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="16-1-2-string类输入"><a href="#16-1-2-string类输入" class="headerlink" title="16.1.2 string类输入"></a>16.1.2 string类输入</h3><ol><li><p>C-风格字符串的输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> info[<span class="number">100</span>];</span><br><span class="line">cin &gt;&gt; info;</span><br><span class="line">cin.<span class="built_in">getline</span>(info,<span class="number">100</span>);</span><br><span class="line">cin.<span class="built_in">get</span>(info,<span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p>string对象,可以自动调整对象的大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string stuff;</span><br><span class="line">cin &gt;&gt; stuff;</span><br><span class="line"><span class="built_in">getline</span>(cin,stuff);</span><br><span class="line"><span class="built_in">getline</span>(cin,stuff[<span class="number">2</span>]);  <span class="comment">//可以这两种使用</span></span><br></pre></td></tr></table></figure></li><li><p>两个版本都有一个可选参数，用于指定使用哪个字符来确定输入的边界</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(info,<span class="number">100</span>,<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"><span class="built_in">getline</span>(stuff,<span class="string">&#x27;:&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>string对象输入的限制<br>1.string对象的最大允许长度，由常量string::npos指定，通常最大值为unsigned int,如果你将整个文件的内容读取到单个string对象中，这是一个限制</p></li></ol><h3 id="16-1-3-使用字符串"><a href="#16-1-3-使用字符串" class="headerlink" title="16.1.3  使用字符串"></a>16.1.3  使用字符串</h3><ol><li><p>length()成员来自string类，而size()是为STL提供的，可以计算数组的大小</p></li><li><p>成员函数find()方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">find</span><span class="params">(<span class="type">char</span> c,size_type pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//从pos开始查找字符c，找到返回索引</span></span><br><span class="line"><span class="function">size_type <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s,size_type pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//从pos开始查找字符串s</span></span><br><span class="line"><span class="function">size_type <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str,size_type pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//从pos开始查找字符串str</span></span><br></pre></td></tr></table></figure></li><li><p>删除字符串的内容</p></li><li><p>capacity()返回当前分配给字符串的内存块的大小，resize()能够请求内存块的最小长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string stuff;</span><br><span class="line">stuff.<span class="built_in">resize</span>(<span class="number">10</span>);  <span class="comment">//分配10个字符的内存</span></span><br><span class="line"><span class="type">int</span> n = stuff.<span class="built_in">capacity</span>();</span><br></pre></td></tr></table></figure></li></ol><h2 id="16-2-智能指针模板类"><a href="#16-2-智能指针模板类" class="headerlink" title="16.2 智能指针模板类"></a>16.2 智能指针模板类</h2><ol><li><p>智能指针定义了类似于指针的类对象，可以帮助管理动态内存分配的智能指针模板，将new获得的地址赋给这种对象</p></li><li><p>ps是一个常规指针，不是一个类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string* ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="16-2-1-使用智能指针"><a href="#16-2-1-使用智能指针" class="headerlink" title="16.2.1 使用智能指针"></a>16.2.1 使用智能指针</h3><ol><li><p>必须包含头文件<memory></p></li><li><p>模板auto_ptr，unique_ptr，shared_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>(auto_ptr&amp; rhs);</span><br><span class="line">auto_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&amp; rhs);</span><br><span class="line">~<span class="built_in">auto_ptr</span>();</span><br><span class="line">X&amp; <span class="keyword">operator</span>*() <span class="type">const</span>;</span><br><span class="line">X* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">X* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(s))</span></span>;</span><br><span class="line">str = *p1;</span><br><span class="line"></span><br><span class="line">p1-&gt;<span class="built_in">find</span>();</span><br></pre></td></tr></table></figure><p>new string是new返回的指针，p1可以使用string的成员函数</p></li><li><p>每一个智能指针都放在代码块中，当离开作用域时，指针自动释放</p></li><li><p>auto_ptr放弃对象的所有权，变成空指针，unique_ptr放弃对象所有权，shared_ptr共享对象所有权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(s))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;  <span class="comment">//放弃p1的所有权</span></span><br><span class="line">p2 = p1;  <span class="comment">//放弃p2的所有权，p1变为空指针，是不被允许的,unique_ptr这样做会直接编译出错</span></span><br><span class="line"></span><br><span class="line">shared_ptr&lt;string&gt; p3;</span><br><span class="line">p3 = p1;  <span class="comment">//p1和p3指向同一个对象，p1和p3共享对象的所有权</span></span><br></pre></td></tr></table></figure></li><li><p>使用new分配内存时，才能使用auto_ptr和shared_ptr，使用new[]时，使用unique_ptr</p></li></ol><h3 id="16-2-3-unique-ptr优于auto-ptr"><a href="#16-2-3-unique-ptr优于auto-ptr" class="headerlink" title="16.2.3 unique_ptr优于auto_ptr"></a>16.2.3 unique_ptr优于auto_ptr</h3><ol><li>函数返回的临时unique_ptr会被销毁<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">demo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> string(s))</span></span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;string&gt; p1;</span><br><span class="line">p1 = <span class="built_in">demo</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//编译出错，unique_ptr不能被赋值</span></span><br><span class="line"></span><br><span class="line">unique_ptr&lt;string&gt; p3；</span><br><span class="line">p3 =  <span class="built_in">unique_ter</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>));  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>不会编译出错</li></ol><h3 id="16-2-4-选择智能指针"><a href="#16-2-4-选择智能指针" class="headerlink" title="16.2.4 选择智能指针"></a>16.2.4 选择智能指针</h3><ol><li><p>选择shared_ptr的情况：<br>1.有一个指针数组，并使用一些辅助指针来标识特定的元素<br>2.两个对象包含都指向第三个对象的指针<br>3.STL容器包含指针</p></li><li><p>STL算法都支持赋值和复制操作，可用于shared_ptr，只要不调用将一个unique_ptr复制和赋值给另一个的方法或算法，但不能用于unique_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;unique_ptr&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vp</span>(size);</span><br><span class="line">vp.<span class="built_in">push_back</span>(unique_ptr&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure><p>push_back()调用没有问题，因为它返回一个临时unique_ptr，被赋给vp中的一个unique_ptr</p></li><li><p>unique_ptr为右值时，可将其赋给dhared_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt;)</span></span>;</span><br></pre></td></tr></table></figure><p>shared_ptr包含一个显示构造函数，可将右值unique_ptr转换为shared_ptr</p></li></ol><h2 id="16-3-标准模板库"><a href="#16-3-标准模板库" class="headerlink" title="16.3 标准模板库"></a>16.3 标准模板库</h2><ol><li><p>迭代器能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针</p></li><li><p>容器：数组，队列，链表，是选择一种能存储多种数据类型的数据类型成为容器</p></li><li><p>操作：搜索，排列和随机排列,适用于所有容器类的非成员函数，省去了大量重复的工作</p></li><li><p>STL不是面向对象编程，而是一种不同的编程模式——泛型编程</p></li><li><p>数学矢量与计算矢量不一样</p></li><li><p>能够分配容器的对象大小的容器，都使用了动态内存分配</p></li></ol><h3 id="16-3-1-模板类vector"><a href="#16-3-1-模板类vector" class="headerlink" title="16.3.1 模板类vector"></a>16.3.1 模板类vector</h3><ol><li><p>分配器：管理内存分配和释放的类</p></li><li><p>各种STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vectorr&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>这个类使用new和delete来分配和释放内存， allocator<T>为分配器</p></li></ol><h3 id="16-3-2-可执行的操作"><a href="#16-3-2-可执行的操作" class="headerlink" title="16.3.2 可执行的操作"></a>16.3.2 可执行的操作</h3><ol><li><p>所有的STL容器都提供了一些基本方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">swap</span>()交换对象的内容</span><br><span class="line"><span class="built_in">begin</span>()返回一个指向容器中第一个元素</span><br><span class="line"><span class="built_in">end</span>()超过容器尾的迭代器</span><br></pre></td></tr></table></figure></li><li><p>迭代器解除引用和递增</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>*()返回指向当前元素的指针</span><br><span class="line"><span class="keyword">operator</span>++()递增迭代器</span><br></pre></td></tr></table></figure></li></ol><p>3.每个容器类都定义了一个合适的迭代器，该迭代器是一个名为iterator的模板类，作用域为整个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pd = scores.<span class="built_in">begin</span>(); <span class="comment">//C++11自动类型推断</span></span><br></pre></td></tr></table></figure><p>声明了一个迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line">pd = scores.<span class="built_in">begin</span>();</span><br><span class="line">*pd = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>一般带有指针的名字都会有指针的性质，只不过在取地址这里有点不一样</p></li><li><p>迭代器遍历容器内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(pd = scores.<span class="built_in">begin</span>();pd!=scores.<span class="built_in">end</span>();pd++)</span><br></pre></td></tr></table></figure></li><li><p>vector类的才有的push_back()，在矢量末尾添加元素,它将负责内存管理，增加矢量的长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">scores.<span class="built_in">push_back</span>(<span class="number">100</span>);</span><br><span class="line">scores.<span class="built_in">push_back</span>(a);</span><br></pre></td></tr></table></figure><p>erase()方法删除矢量中给定区间的元素</p></li><li><p>vector提供了随机访问功能，因此可以有begin()+2操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.<span class="built_in">erase</span>(scores.<span class="built_in">begin</span>(),scores.<span class="built_in">begin</span>()+<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>insert()方法将元素插入到矢量中的指定位置，该区间是另一个容器对象的一部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; old_v;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; new_v;</span><br><span class="line">...</span><br><span class="line">old_v.<span class="built_in">insert</span>(old_v.<span class="built_in">begin</span>()+<span class="number">2</span>,new_v.<span class="built_in">begin</span>(),new_v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li><li><p>swap()交换两个对象的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; old_v;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; new_v;</span><br><span class="line">old_v.<span class="built_in">swap</span>(new_v);</span><br></pre></td></tr></table></figure></li><li><p>8个容器类，需要支持10中操作，都有自己的成员函数，则要定义80个成员函数，但采用STL方式时，只需要10个非成员函数即可</p></li><li><p>即使有执行相同任务的非成员函数，STL有时也会定义一个成员函数，因为类特定算法的效率比通用算法高，vector成员函数swap()效率比非成员函数swap()高，但非成员函数让你能够交换两个不同容器的内容</p></li><li><p>STL函数：for_each(),random_shuffle()和sort()，必须包含<algorithm></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Review&gt;::iterator pr;</span><br><span class="line"><span class="keyword">for</span> (pr = books.<span class="built_in">begin</span>(); pr != books.<span class="built_in">end</span>(); pr++)</span><br><span class="line"><span class="built_in">ShowReview</span>(*pr);</span><br><span class="line">替换为：</span><br><span class="line">for_each(books.<span class="built_in">begin</span>(),books.<span class="built_in">end</span>(),ShowReview);</span><br></pre></td></tr></table></figure><p>最后一个参数是指向函数的指针(函数对象)，该函数不可以修改容器元素的值</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">random_shuffle</span>(books.<span class="built_in">begin</span>(),books.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>随机排列该区间中的元素，要求容器类允许随机访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Review&amp; r1,<span class="type">const</span> Review&amp; r2) <span class="type">const</span>;   <span class="comment">//注意是使用的是布尔类型的返回值，现在函数总是用布尔类型的返回值和循环是否结束</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(r1.title&lt;r2.title)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r1.title==r2.title &amp;&amp; r1.rating&lt;r2.rating)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(books.<span class="built_in">begin</span>(),books.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>sort()第一个版本使用为存储在容器中的类型元素定义的&lt;运算符，如果容器元素类型是用户定义的，则要使用sort()，必须定义能够该类型对象的operator&lt;()函数，为Review提供了成员或非成员函数operator&lt;()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorseThan</span><span class="params">(<span class="type">const</span> Review&amp; r1,<span class="type">const</span> Review&amp; r2)</span> <span class="type">const</span></span>;  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(r1.title&lt;r2.title)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r1.title==r2.title &amp;&amp; r1.rating&lt;r2.rating)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(books.<span class="built_in">begin</span>(),books.<span class="built_in">end</span>(),WorseThan);</span><br></pre></td></tr></table></figure><p>第二种版本的sort()</p><h3 id="16-3-4-基于范围的for循环"><a href="#16-3-4-基于范围的for循环" class="headerlink" title="16.3.4 基于范围的for循环"></a>16.3.4 基于范围的for循环</h3><ol><li>基于范围的for循环是为用于STL而设计的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">10.0</span>,<span class="number">20.0</span>,<span class="number">30.0</span>,<span class="number">40.0</span>,<span class="number">50.0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> x: prices)</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li></ol><p>2.循环将依次将books中的每个Review对象传递给ShowReview()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : books)</span><br><span class="line"><span class="built_in">ShowReview</span>(x);</span><br></pre></td></tr></table></figure><ol start="3"><li>不同于for_each()，基于范围的for循环可以修改容器中的元素，但要指定一个引用参数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InflateReview</span><span class="params">(Review&amp; r)</span></span>&#123;r.rating++;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : books)                                                        <span class="comment">//两个地方必须要有引用</span></span><br><span class="line"><span class="built_in">InflateReview</span>(x);</span><br></pre></td></tr></table></figure></li></ol><h2 id="16-4-泛型编程"><a href="#16-4-泛型编程" class="headerlink" title="16.4 泛型编程"></a>16.4 泛型编程</h2><ol><li><p>STL是一种泛型编程，面向对象编程关注的是编程的数据方面，使任何数据类型能存在容器中，而泛型编程关注的是算法，使任何容器能运用于算法，共同特定是抽象和创建可重用代码</p></li><li><p>模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型</p></li><li><p>定义一种链表类型的迭代器类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> item;</span><br><span class="line">Node* p_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">&#123;</span><br><span class="line">Node* pt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">iterator</span>(<span class="number">0</span>) : <span class="built_in">pt</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"><span class="built_in">iterator</span>(Node* pn) : <span class="built_in">pt</span>(pn) &#123;&#125;;</span><br><span class="line"><span class="type">double</span> <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> pt-&gt;item;&#125;</span><br><span class="line">iterator <span class="keyword">operator</span>++()                                                     <span class="comment">//是返回的是类对象</span></span><br><span class="line">&#123;</span><br><span class="line">pt = pt-&gt;p_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">pt = pt-&gt;p_next;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>find_ar()与find_ll几乎相同，区别在于结束的条件不同，这就需要不同的容器了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span>* iterator;</span><br><span class="line"><span class="function">iterator <span class="title">find_ar</span><span class="params">(iterator begin,iterator end,<span class="type">double</span> &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iterator ar;</span><br><span class="line"><span class="keyword">for</span>(ar = begin;ar!=end;ar++)</span><br><span class="line"><span class="keyword">if</span>(*ar == val)</span><br><span class="line"><span class="keyword">return</span> ar;</span><br><span class="line"><span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">find_ll</span><span class="params">(iterator head,<span class="type">const</span> <span class="type">double</span> &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">interator start;</span><br><span class="line"><span class="keyword">for</span>(start = head;start!=<span class="number">0</span>;start++)</span><br><span class="line"><span class="keyword">if</span>(*start == val)</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find()函数的实现方法</p></li><li><p>每个容器类定义了相应的迭代器类型，可能是指针，可能是对象，每个容器类都有begin()和end()方法，都使用++，让迭代器递增</p></li><li><p>C++11新增的自动类型推断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pr = scores.<span class="built_in">begin</span>();pr != scores.<span class="built_in">end</span>();pr++)</span><br><span class="line">cout &lt;&lt; *pr &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>最好避免直接使用迭代器，而尽量使用for_each()，和基于范围的for循环</p></li><li><p>有了迭代器算法才能通用，基于算法的要求，设计基本迭代器的特征和容器的特征</p></li></ol><h3 id="16-4-2-迭代器类型"><a href="#16-4-2-迭代器类型" class="headerlink" title="16.4.2 迭代器类型"></a>16.4.2 迭代器类型</h3><ol><li><p>不同的算法对迭代器的要求也不同，排序算法需要能够随机访问，可以通过定义+运算符来实现,迭代器也是一个类，含有构造函数</p></li><li><p>如果两个迭代器相同，则解除引用操作得到的值将相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter1 == iter2</span><br><span class="line">*iter1 == *iter2</span><br></pre></td></tr></table></figure></li><li><p>输出迭代器只能修改容器值，而不能读取，程序的输出就是容器的输入，输入和输出迭代器都是单通行，不能保证第二次遍历容器时，顺序不变，也不能保证其先前值仍然可以被解除引用</p></li><li><p>正向迭代器可以对前面的迭代器值解除引用，可以读取和修改数据，也可以只读取数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pirw;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pirw;</span><br></pre></td></tr></table></figure></li><li><p>双向迭代器中，reverse函数可以交换第一个元素和最后一个元素，将指向第一个元素的指针加1，指向第一个元素的指针减1</p></li><li><p>sort()函数需要随机访问迭代器，所以只能用于支持这种迭代器的容器，随机访问迭代器实现为一个常规指针，正向迭代器实现为一个类</p></li><li><p>一种迭代器的类型是不一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator</span><br><span class="line">vector&lt;<span class="type">double</span>&gt;::iterator         <span class="comment">//两种类型的迭代器</span></span><br></pre></td></tr></table></figure></li><li><p>每个容器类都定义了一个类级typedef名称——iterator</p></li></ol><p>9.如果所设计的容器类需要迭代器，可考虑STL，它包含用于标准种类的迭代器模板</p><h3 id="16-4-4-概念，改进和模型"><a href="#16-4-4-概念，改进和模型" class="headerlink" title="16.4.4 概念，改进和模型"></a>16.4.4 概念，改进和模型</h3><ol><li><p>将指针用作迭代器，使得STL算法用于常规数组</p></li><li><p>将一个数组复制到一个矢量中copy()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> casts[<span class="number">10</span>] = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dice[<span class="number">10</span>];                                        <span class="comment">//copy()不能自动根据发送值调整目标容器的长度</span></span><br><span class="line"><span class="built_in">copy</span>(casts,casts+<span class="number">10</span>,dice.<span class="built_in">begin</span>())</span><br></pre></td></tr></table></figure><p>前两个参数必须是输入迭代器，最后一个必须是输出迭代器</p></li><li><p>输出流迭代器，STL为这种迭代器提供了ostream_iterator模板，是输出迭代器的一个模型，也是一个适配器——类或函数，可以将一些其他接口转换为STL使用的接口(使得cout可以在算法中使用)，迭代器就是STL的接口，要包含头文件iterator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>,<span class="type">char</span>&gt; <span class="title">out_iter</span><span class="params">(cout,<span class="string">&quot; &quot;</span>)</span></span>;    <span class="comment">//构造函数的第一个参数指出了要使用的输出流，第二个参数指出了要使用的分隔符</span></span><br><span class="line">out_iter++ = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>out_iter才是迭代器，意味着将15和有空格组成的字符串发送到输出流中，并为下一个输出做准备</p></li><li><p>copy()函数的另一种用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(dice.<span class="built_in">begin</span>(),dice.<span class="built_in">end</span>(),out_iter);</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(dice.<span class="built_in">begin</span>(),dice.<span class="built_in">end</span>(),<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>,<span class="type">char</span>&gt;(cout,<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>,<span class="type">char</span>&gt;(cin),istream_iterator&lt;<span class="type">int</span>,<span class="type">char</span>&gt;,dice.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><p>将dice的内容复制到cout输出流中，即显示容器的内容</p></li><li><p>其他有用的迭代器(reverse_iterator,back_insert_iterator,frint_insert_iterator)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(dice.<span class="built_in">rbegin</span>(),dice.<span class="built_in">rend</span>(),out_iter);</span><br></pre></td></tr></table></figure><p>这样不必声明反向迭代器reverse_iterator，rbegin()和end()返回的值相同，但类型不同(reverse_iterator,iterator)</p></li><li><p>反向指针先通过递减，再解除引用来解决rbegin()的超尾的问题，rp指向位置6，则*rp将是位置5的值 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::reverse_iterator ri;</span><br><span class="line"><span class="keyword">for</span>(ri = dice.<span class="built_in">rbegin</span>();ri != dice.<span class="built_in">rend</span>();ri++)</span><br><span class="line">cout &lt;&lt; *ri &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>三种插入迭代器：back_insert_iterator,front_insert_iterator,insert_iterator</p></li><li><p>back_insert_iterator只能于允许在尾部快速插入的容器(快速插入指的是一个小时固定的算法)，vector满足，将容器类型作为模板参数，将实际的容器标识符作为构造函数参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">back_insert_iterator&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">back_iter</span>(dice);     </span><br></pre></td></tr></table></figure><p>构造函数将假设传递给它的类型有一个push_back()方法</p></li><li><p>front_insert_iterator，满足queue，不满足vector，完成任务很快</p></li><li><p>insert_iterator没有这些限制，还需要一个指示插入位置的构造函数参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert_iterator&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">insert_iter</span>(dice,dice.<span class="built_in">begin</span>());     </span><br></pre></td></tr></table></figure></li><li><p>二维数组也是同样的运用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1[<span class="number">2</span>] = &#123;<span class="string">&quot;fsdaf&quot;</span>,<span class="string">&quot;ffsadfds&quot;</span>&#125;</span><br><span class="line">vector&lt;string&gt; <span class="built_in">s2</span>(<span class="number">4</span>);        </span><br><span class="line"><span class="built_in">copy</span>(s1,s1+<span class="number">2</span>,s2.<span class="built_in">begin</span>());                                      <span class="comment">//stirng没有迭代器</span></span><br></pre></td></tr></table></figure></li><li><p>可以用insert_iterator将复制数据的算法转换为插入数据的算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(s1,s1+<span class="number">2</span>,back_insert_iterator&lt;vector&lt;string&gt; &gt;(words));</span><br></pre></td></tr></table></figure></li><li><p>这些预定义迭代器增加了函数的功能，比如copy()函数</p></li></ol><h3 id="16-4-5-容器的种类"><a href="#16-4-5-容器的种类" class="headerlink" title="16.4.5 容器的种类"></a>16.4.5 容器的种类</h3><ol><li><p>STL具有容器概念和容器类型，容器类型是可用于创建具体容器对象的模板，有deque,list,queue,priority_queue,stack,vector,map,multimap,set,multiset,bitset</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;deque&quot;</span>: <span class="string">&quot;双端队列（double-ended queue），可以从中端和末端插入和删除元素，是可以随机访问的&quot;</span>,</span><br><span class="line"><span class="string">&quot;list&quot;</span>: <span class="string">&quot;链表（list）是一个双向链表，可以随时在任何位置插入或删除元素。&quot;</span>,</span><br><span class="line"><span class="string">&quot;queue&quot;</span>: <span class="string">&quot;队列（queue）是一种先进先出（FIFO）的数据结构，只能在末端添加元素，在前端删除元素。&quot;</span>,</span><br><span class="line"><span class="string">&quot;priority_queue&quot;</span>: <span class="string">&quot;优先队列（priority queue）是一种特殊的队列，每个元素都有一个优先级，优先级最高的元素最先出队。&quot;</span>,</span><br><span class="line"><span class="string">&quot;stack&quot;</span>: <span class="string">&quot;栈（stack）是一种后进先出（LIFO）的数据结构，只能在顶端添加或删除元素。&quot;</span>,</span><br><span class="line"><span class="string">&quot;vector&quot;</span>: <span class="string">&quot;向量（vector）是动态数组，可以动态地增加和减少元素，在尾部添加和删除元素的时间是固定的，但在头部或中间插入和删除元素为线性时间，还是一种反转容器&quot;</span>,</span><br><span class="line"><span class="string">&quot;map&quot;</span>: <span class="string">&quot;映射（map）是一种关联数组，它存储的是键值对（key-value pairs）。&quot;</span>,</span><br><span class="line"><span class="string">&quot;multimap&quot;</span>: <span class="string">&quot;多重映射（multimap）类似于映射，但允许存在多个相同的键。&quot;</span>,</span><br><span class="line"><span class="string">&quot;set&quot;</span>: <span class="string">&quot;集合（set）是一种不包含重复元素的无序集合。&quot;</span>,</span><br><span class="line"><span class="string">&quot;multiset&quot;</span>: <span class="string">&quot;多重集合（multiset）类似于集合，但允许存在重复的元素。&quot;</span>,</span><br><span class="line"><span class="string">&quot;bitset&quot;</span>: <span class="string">&quot;位集（bitset）是一种特殊的数组，它存储的是位（0或1）。&quot;</span></span><br></pre></td></tr></table></figure><p>C++11新增的容器类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map：基于哈希表的关联容器，用于存储键值对，查找、插入和删除操作的平均时间复杂度为<span class="built_in">O</span>(<span class="number">1</span>)。</span><br><span class="line">std::unordered_set：基于哈希表的集合容器，用于存储唯一的键，查找、插入和删除操作的平均时间复杂度为<span class="built_in">O</span>(<span class="number">1</span>)。</span><br><span class="line">std::forward_list：单向链表容器，只支持正序遍历，插入和删除操作在链表头部和尾部速度很快。</span><br></pre></td></tr></table></figure></li><li><p>一些基本的容器特征</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X a;</span><br><span class="line">(&amp;a)-&gt;~<span class="built_in">X</span>();       <span class="comment">//线性时间</span></span><br><span class="line"></span><br><span class="line">a.<span class="built_in">size</span>();         <span class="comment">//固定时间</span></span><br><span class="line"></span><br><span class="line">a.<span class="built_in">swap</span>();         <span class="comment">//固定时间</span></span><br></pre></td></tr></table></figure></li><li><p>“复杂度”，从快到慢：<br>1.编译时间，在编译时执行，指向时间为0<br>2.固定时间，在运行时执行，指向时间为O(1)，独立于对象中的元素数目<br>3.线性时间，时间与元素数目成正比，指向时间为O(n)</p></li><li><p>序列是基本的容器概念的改进，包括deque,list,vector,forward_list,queue,stack,priority_queue，要求是正向迭代器，保证了元素将按特定顺序排序，即除了第一和最后，每个元素前后都分别有一个元素</p></li><li><p>为list,deque定义了push_front，而没有为vector定义，是因为在矢量前插入一个元素，需要移动大量的元素，而list和deque的允许将元素添加到前端，而不移动其他元素，以固定时间来完成，所以vector没有必要定义push_front</p></li><li><p>deque和vector都对元素进行随机访问和在中部执行线性时间的插入和删除，但vector容器执行的更快，因为vector的内存是连续的，而deque的内存不是连续的，所以vector的访问速度更快，deque更复杂</p></li><li><p>双向链表可以双向遍历链表，可以从后面往前面遍历，也是反转容器 </p></li><li><p>list成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(list&lt;T,Alloc&gt;&amp;x)</span></span>;        <span class="comment">//将两个链表合并，两个链表必须是已经排序，合并后x为空，为线性时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp;value)</span></span>;         <span class="comment">//删除所有值为value的元素，线性时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unique</span><span class="params">()</span></span>;                      <span class="comment">//将连续的相同(即相邻的相同值)的元素压缩为单个元素，可以结合sort()来使用，线性时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;                        <span class="comment">//使用&lt;运算给发，将元素排序，线性时间为NlogN</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator pos,list&lt;T,Alloc&gt; x)</span>     <span class="comment">//将x中的元素插入到pos之前，x将为空，为固定时间</span></span></span><br></pre></td></tr></table></figure><p>非成员函数sort()，需要随机访问迭代器，不能用于链表，所以只能使用类中的成员函数版本</p></li><li><p>list工具箱：list方法组成了一个方便的工具箱，例如有两个邮件列表要整理，则可以对每个列表进行排序，合并它们，然后使用unique()来删除重复的元素</p></li><li><p>C++11新增的forward_list，实现单链表，无反向迭代器，因为每个节点都只链接到下一个节点，而没有链接到前一个节点</p></li><li><p>queue模板类是一个适配器类，让底层类(deque)展示典型的队列接口，既不允许随机访问，也不允许遍历队列，只允许队列的基本操作，使用这个值与栈一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push：在队列的末尾添加一个元素。</span><br><span class="line">pop：从队列的开头移除一个元素，并返回该元素。</span><br><span class="line">front：返回队列的第一个元素，但不移除该元素。</span><br><span class="line">back：返回队列的最后一个元素，但不移除该元素。</span><br><span class="line">empty：检查队列是否为空，如果为空则返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">size：返回队列中的元素个数。</span><br></pre></td></tr></table></figure></li><li><p>priority_queue是另一个适配器类，与queue操作相同，主要是priority_queue最大的元素被移到队首，底层类是vector，可以修改用于确定哪个元素放到队首的比较方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq1;</span><br></pre></td></tr></table></figure><p>这用到了构造函数</p></li><li><p>stack模板类，与queue相同，也是适配器类，底层类是vector，给底层类提供了典型的栈接口，既不允许随机访问，也不允许遍历栈，只允许栈的基本操作：将压入推到栈顶，从栈顶弹出元素，查看栈顶的值，检查元素数目和测试栈是否为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span>：判断栈是否为空，如果为空则返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="type">const</span>：返回栈的元素个数。</span></span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span>：返回栈顶元素，并弹出该元素。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span>：将元素压入栈中。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span>：弹出栈顶元素。</span></span><br></pre></td></tr></table></figure><p>如果要使用栈值，必须首先使用top()来检索这个值，然后使用pop()将它从栈中删除</p></li><li><p>array模板类并非STL容器，因为其长度是固定的，没有定义调整容器大小的操作，如push_back()和insert()，可将标准STL算法用于array对象，如copy()和for_each()</p></li></ol><h3 id="16-4-6-关联容器"><a href="#16-4-6-关联容器" class="headerlink" title="16.4.6 关联容器"></a>16.4.6 关联容器</h3><ol><li><p>关联容器将值与键冠梁在一起，并使用键来查找值，优点在于它提供了对元素的快速访问，允许插入元素新元素，但不能指定元素的插入位置原因是关联容器通常有用于确定数据放置位置的算法，而不是使用迭代器，以便能够快速找到元素</p></li><li><p>关联容器通常是使用某种树实现的，4种关联容器：set，multiset,map,multimap，前两种是在头文件set中定义，后两种是在map中定义的</p></li><li><p>set其值类型与键相同，键是唯一的，不会有多个相同的键，multimap可能有多个值的键相同</p></li><li><p>map中，值与键的类型不同，键是唯一的，每个键只对应一个值，multimap可能有一个键可以与多个值关联</p></li><li><p>set模板类可反转，可排序，且键是唯一的，所以不能存储多个相同的值,第二个模板参数，可用于指示用来对键进行的比较函数对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; A;</span><br><span class="line">set&lt;stirng less&lt;string&gt; &gt; A;</span><br><span class="line"></span><br><span class="line">cconst <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line">string s1[N] = &#123;<span class="string">&quot;adsf&quot;</span>, <span class="string">&quot;bwe&quot;</span>, <span class="string">&quot;cfdsf&quot;</span>, <span class="string">&quot;dzv&quot;</span>, <span class="string">&quot;ev&quot;</span>, <span class="string">&quot;fbn&quot;</span>&#125;;</span><br><span class="line"><span class="function">set&lt;string&gt; <span class="title">A</span><span class="params">(s1, s1 + N)</span></span>;</span><br><span class="line"><span class="function">ostream_iterator&lt;string, <span class="type">char</span>&gt; <span class="title">out</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), out);</span><br></pre></td></tr></table></figure><p>set有一个将迭代器区间作为参数的构造函数，键是唯一的，所以”for”在数组两次出现，但在集合中只出现一次，且集合被排序</p></li><li><p>数学为集合定义了一些标准操作，如并集，交集，这些操作的算法，是通用函数，不是类方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_union</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>(), ostream_iterator&lt;string,<span class="type">char</span>&gt; <span class="built_in">out</span>(cout, <span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure><p>显示集合A和B的并集，并进行了排序</p></li><li><p>multimap的模板参数指定键的类型和存储的值的类型，为将信息结合在一起，实际的值的类型将键类型与数据类型结合为一对，STL使用模板类pair&lt;class T,call U&gt;将两种值存储到一个对象中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>,string&gt; codes;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">const</span> <span class="type">int</span>,string&gt;</span><br></pre></td></tr></table></figure><p>codes对象的值类型为pair&lt;const int,string&gt;</p></li><li><p>用区号作为键来存储城市名，这恰好与codes值类型一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">const</span> <span class="type">int</span>,string&gt; <span class="title">iteam</span><span class="params">(<span class="number">231</span>, <span class="string">&quot;New York&quot;</span>)</span></span>;</span><br><span class="line">codes.<span class="built_in">insert</span>(iteam);</span><br></pre></td></tr></table></figure><p>因为数据项是按键排序的，所以不需要指出插入位置</p></li></ol><h3 id="16-4-7-无序关联容器"><a href="#16-4-7-无序关联容器" class="headerlink" title="16.4.7 无序关联容器"></a>16.4.7 无序关联容器</h3><ol><li>无序关联容器也将值与键关联起来，并使用键来查找值，是基于哈希表，旨在提高添加和删除元素的速度以及查找算法的效率：unordered_set,unordered_multiset,unordered_map,unordered_multimap</li></ol><h2 id="16-5-函数对象"><a href="#16-5-函数对象" class="headerlink" title="16.5 函数对象"></a>16.5 函数对象</h2><ol><li>很多STL算法使用了函数对象，包括函数名，指向函数的指针和重载了()运算符的类对象(即定义了函数operator()()的类)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Linear</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> slope;</span><br><span class="line"><span class="type">double</span> y0;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> x)</span>  </span>&#123;<span class="keyword">return</span> y0+slope*x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Linear f1;</span><br><span class="line"><span class="type">double</span> y1 = <span class="built_in">f1</span>(<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="16-5-1-函数符概念"><a href="#16-5-1-函数符概念" class="headerlink" title="16.5.1 函数符概念"></a>16.5.1 函数符概念</h3><ol><li><p>生成器是不用参数就可以调用的函数符，一元函数是用一个参数就可以调用的函数符，例如，for_each()是一元函数，因为它每次用于一个容器元素，返回bool值的一元函数是谓词</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorseThan</span><span class="params">(<span class="type">const</span> Review&amp; r1, <span class="type">const</span> Review&amp; r2)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(books.<span class="built_in">begin</span>(),books.<span class="built_in">end</span>(),WorseThan);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tooBig</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="keyword">return</span> n &gt; <span class="number">100</span>;&#125;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line">scores.<span class="built_in">remove_if</span>(tooBig);      <span class="comment">//删除链表中所有大于100的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tooBig2</span><span class="params">(<span class="type">const</span> T &amp; val,<span class="type">const</span> T &amp; lim)</span>         <span class="comment">//可以将两个参数的模板函数转换为单个参数的函数对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; lim;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tempalte&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TooBig</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T cutoff;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TooBig</span>(<span class="type">const</span> T &amp; t) : <span class="built_in">cutoff</span>(t) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> &amp; v)</span></span>&#123;<span class="keyword">return</span> v &gt; cutoff;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TooBig&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">scores.<span class="built_in">remove_if</span>(p);                  <span class="comment">//直接使用类对象</span></span><br></pre></td></tr></table></figure><p>n的值来自链表中，设计一个TooBing类，来控制大于多少的元素将被删除</p></li><li><p>函数对象是一种适配器，使函数或类成员函数能够满足不同的接口(接口就是函数或类成员函数)</p></li></ol><h3 id="16-5-2-预定义的函数符"><a href="#16-5-2-预定义的函数符" class="headerlink" title="16.5.2 预定义的函数符"></a>16.5.2 预定义的函数符</h3><ol><li><p>STL定义了多个基本函数符，它们执行诸如将两个值相加，比较两个值是否相等操作，transform()有两个版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v.<span class="built_in">begin</span>(),sqrt);         <span class="comment">//计算每个元素的平方根</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v1.<span class="built_in">begin</span>(),v.<span class="built_in">begin</span>(),mean);      <span class="comment">//计算v所有元素和v1的第一个元素的平均值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v1.<span class="built_in">begin</span>(),v.<span class="built_in">begin</span>(),<span class="built_in">plus</span>&lt;<span class="type">double</span>&gt;());     <span class="comment">//()可有可无，函数对象不会带参数的</span></span><br></pre></td></tr></table></figure><p>头文件functional定义了多个模板类函数对象，其中包括plus类</p></li><li><p>对于所有内置的算术运算符，关系运算符和逻辑运算符，STL都提供了函数对象，例如，+ plus<int>()和 - minus<int>()是两个函数对象</p></li></ol><h3 id="16-5-3-自适应函数符和函数适配器"><a href="#16-5-3-自适应函数符和函数适配器" class="headerlink" title="16.5.3 自适应函数符和函数适配器"></a>16.5.3 自适应函数符和函数适配器</h3><ol><li><p>表16.12列出的预定义函数符都是自适应的，函数符自适应性的意义在于：函数适配器对象可以使用函数对象，使函数能匹配不同的接口</p></li><li><p>函数适配器将接受两个参数的函数符转换为接受1个参数的函数符，前面的TooBig2示例提供了一种方法，但STL使用binder1st和binder2nd类自动完成这个过程，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">binder1st</span>(f2,val) f1;     <span class="comment">//f2是一个自适应二元函数</span></span><br></pre></td></tr></table></figure><p>f1对象将与f2的第一个参数val相关联</p></li><li><p>函数binder1st()与binder1st类的作用相同，binder2st，只是将常数赋给第二个参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(gr8.<span class="built_in">begin</span>(),gr8.<span class="built_in">end</span>(),out,<span class="built_in">bind1st</span>(<span class="built_in">multiplies</span>&lt;<span class="type">int</span>&gt;(),<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>将二元函数multiplies()转换为将参数乘以2的一元函数</p></li></ol><h2 id="16-6-算法"><a href="#16-6-算法" class="headerlink" title="16.6 算法"></a>16.6 算法</h2><ol><li><p>STL的非成员函数：sort(),copy(),find(),random_shuffle(),set_union(),set_intersection(),set_difference(),transform()，有些函数接受一个函数对象</p></li><li><p>统一的容器设计使得不同类型的容器之间具有明显的关系，例如可以使用copy()将vector对象中的值复制到list对象中，用&#x3D;&#x3D;来比较不同类型的容器，如deque和vector，之所以能这样做是容器都使用迭代器来提供访问容器中的数据</p></li></ol><h3 id="16-6-1-算法组"><a href="#16-6-1-算法组" class="headerlink" title="16.6.1 算法组"></a>16.6.1 算法组</h3><ol><li>通用数字运算的算法在头文件numeric中定义，vector最有可能使用这些操作的容器</li></ol><h3 id="16-6-2-算法的通用特征"><a href="#16-6-2-算法的通用特征" class="headerlink" title="16.6.2 算法的通用特征"></a>16.6.2 算法的通用特征</h3><ol><li><p>sort()的结果被存放在原始数据的位置上，copy()将结果发送到另一个位置，transform()可以以这两种方式完成工作</p></li><li><p>copy()的原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>,<span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">copy</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span>;</span><br></pre></td></tr></table></figure><p>这包含了两种迭代器</p></li><li><p>有些算法有两个版本：就地版本和复制版本，复制版本的名称将以_copy()结尾，将接受一个多的输出迭代器参数</p></li></ol><h1 id="第17章-泛型编程注意的事项"><a href="#第17章-泛型编程注意的事项" class="headerlink" title="第17章 泛型编程注意的事项"></a>第17章 泛型编程注意的事项</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Review</span> &#123;</span><br><span class="line">string title;</span><br><span class="line"><span class="type">int</span> rating;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FillReview</span><span class="params">(Review&amp; rr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowReview</span><span class="params">(<span class="type">const</span> Review&amp; rr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Review&gt; books;</span><br><span class="line">Review temp;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">FillReview</span>(temp))                                                 <span class="comment">//FillReview()函数的返回值为true或false</span></span><br><span class="line">books.<span class="built_in">push_back</span>(temp);                                               <span class="comment">//添加在后面</span></span><br><span class="line"><span class="type">int</span> num = books.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;You enter the following:\n&quot;</span> &lt;&lt; <span class="string">&quot;Rating Book\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line"><span class="built_in">ShowReview</span>(books[i]);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Reprising:\n&quot;</span> &lt;&lt; <span class="string">&quot;Rating book&quot;</span> &lt;&lt; endl;</span><br><span class="line">vector&lt;Review&gt;::iterator pr;</span><br><span class="line"><span class="keyword">for</span> (pr = books.<span class="built_in">begin</span>(); pr != books.<span class="built_in">end</span>(); pr++)</span><br><span class="line"><span class="built_in">ShowReview</span>(*pr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FillReview</span><span class="params">(Review&amp; rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter book title: &quot;</span>;</span><br><span class="line"><span class="built_in">getline</span>(cin, rr.title);</span><br><span class="line"><span class="keyword">if</span> (rr.title == <span class="string">&quot;quit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter book rating: &quot;</span>;</span><br><span class="line">cin &gt;&gt; rr.rating;</span><br><span class="line"><span class="keyword">if</span> (!cin)                                                                <span class="comment">//判断是否输入了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">cin.<span class="built_in">get</span>();                                                               <span class="comment">//在连续输入时要考虑&quot;\n&quot;的存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowReview</span><span class="params">(<span class="type">const</span> Review&amp; rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; rr.rating &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; rr.title &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>string对象初始化<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string s1[<span class="number">2</span>] = &#123;<span class="string">&quot;fsdaf&quot;</span>,<span class="string">&quot;ffsadfds&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">s2</span><span class="params">(<span class="number">4</span>)</span></span>;                                <span class="comment">//两个不同表示数组大小的方式</span></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> STL中的类，对象和通常函数都要处理空间名称</span><br><span class="line">```c++</span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">B</span><span class="params">(s2,s2+N)</span></span>;</span><br><span class="line"><span class="function">std::ostream_iterator&lt;std::string,<span class="type">char</span>&gt; <span class="title">out</span><span class="params">(std::cout,<span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">copy</span>(B.<span class="built_in">begin</span>(),B.<span class="built_in">end</span>(),out);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2023/08/11/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/08/11/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown总结</title>
      <link href="/2023/05/18/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/05/18/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown总结"><a href="#Markdown总结" class="headerlink" title="Markdown总结"></a>Markdown总结</h1><h2 id="一、Markdown常用语法😀"><a href="#一、Markdown常用语法😀" class="headerlink" title="一、Markdown常用语法😀"></a>一、Markdown常用语法😀</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#文字样式</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line">&#123;% span red, 红色 %&#125;    #彩色文字</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;    #超大号文字</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">#本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">#在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">#表格</span></span><br><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br><span class="line"></span><br><span class="line"><span class="section">#键盘样式的文本</span></span><br><span class="line">&#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">#密码样式的文本</span></span><br><span class="line">&#123;% psw 这里没有验证码 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">#折叠框</span></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"><span class="bullet">-</span> 我</span><br><span class="line"><span class="bullet">-</span> 你</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">#分栏</span></span><br><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 第二个Tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 第三个Tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">#音频</span></span><br><span class="line">&#123;% audio 音频链接 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">#单张图片</span></span><br><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br><span class="line"><span class="section">#视频</span></span><br><span class="line">&#123;% video 视频链接 %&#125;</span><br><span class="line"><span class="section">#隐藏块</span></span><br><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><h2 id="二、分栏举例😂"><a href="#二、分栏举例😂" class="headerlink" title="二、分栏举例😂"></a>二、分栏举例😂</h2><ol><li>红框+链接<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">源码</button></li><li class="tab"><button type="button" data-href="#test1-2">演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>[<span class="string">百度</span>](<span class="link">https://www.baidu.com</span>)<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><table><tr><td bgcolor=MistyRose><p><a href="https://www.baidu.com/">百度</a></p></td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></div></li></ol><h2 id="三、应用实列😊"><a href="#三、应用实列😊" class="headerlink" title="三、应用实列😊"></a>三、应用实列😊</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><table><tr><td bgcolor=MistyRose>随着交通工具普及，道路交通事故频发，威胁人们的生命和财产安全。基于北斗的智慧行车安全预警系统是一种智能驾驶辅助系统，通过车联网和人工智能技术提供实时监测和预警服务，以降低道路交通事故发生率，提高行驶安全性和舒适度。</td></tr></table><h3 id="2-系统框架"><a href="#2-系统框架" class="headerlink" title="2. 系统框架"></a>2. 系统框架</h3><p><strong>基于北斗的智慧行车安全预警系统的框架包括以下部分：</strong></p><ol><li>车辆本身对车辆信息的监控：每辆车搭载北斗卫星定位设备，实时上传车辆位置、速度、状态等信息到平台。</li><li>车辆信息监控异常数据共享：平台共享车辆信息，识别异常数据，并通过车载终端及时提醒周边车辆。</li><li>预判前方突发情况提前预警：利用道路监控摄像头、雷达等设备获取前方道路情况和历史数据分析，提前判断可能发生的异常情况，并进行预警提示，如前方车道堵塞等。</li><li>预判周边车辆预警提示：通过北斗卫星精准定位周边车辆位置，预测周边车辆的行驶意向，提前提示可能发生的危险。</li><li>预判前后车辆密度情况：根据车辆行驶速度等数据，计算并预判周边车辆密度，及时调整车速、车道等策略，避免交通事故的发生。</li><li>紧急救援避让预警：发现救援车辆时，通知周边车辆避让，以便救援车辆快速应对事故现场。</li><li>紧急报警、位置同步、救援措施：当车辆遭遇紧急情况，如故障或被劫持，车载终端发出紧急报警信号，平台接收报警后查看车辆位置并采取救援措施。</li></ol><h3 id="3-应用场景与技术整合"><a href="#3-应用场景与技术整合" class="headerlink" title="3. 应用场景与技术整合"></a>3. 应用场景与技术整合</h3><p><strong>智慧行车安全预警系统可广泛应用于不同场景和车辆类型，并与其他先进技术整合，提高系统的智能水平和实用性。</strong></p><ul><li>城市交通：实时监测周边车辆信息，预判交通状况，提供安全驾驶建议，降低交通事故概率。</li><li>高速公路：通过监测车辆信息，预判前方道路状况，提醒驾驶员注意安全，避免追尾事故等。</li><li>乡村道路：根据实时道路信息，为驾驶员提供行驶建议，提高乡村道路行驶安全性。</li><li>不同类型车辆：适用于私家车、公交车、货车等各类型车辆，提供定制化的安全驾驶服务。</li><li>技术整合方面：<ul><li>自动驾驶：与自动驾驶技术结合，实现车辆的自主驾驶，提高安全性和舒适度。</li><li>车联网：通过车联网技术实现车辆之间的信息互联互通，提升道路交通智能化水平。</li><li>人工智能：利用人工智能技术分析车辆数据，为驾驶员提供精准的安全驾驶建议。</li></ul></li></ul><h3 id="4-用户体验与社会影响"><a href="#4-用户体验与社会影响" class="headerlink" title="4. 用户体验与社会影响"></a>4. 用户体验与社会影响</h3><ul><li>安全感：提高驾驶员的安全感，降低交通事故发生概率。</li><li>舒适度：通过实时监测和预警，提高驾驶员应对复杂道路状况的能力，提升行驶舒适度。</li><li>简化操作：系统提供实时建议，简化驾驶操作，使驾驶更轻松。</li><li>减少交通事故：通过实时监测和预警，降低交通事故发生率，确保行驶安全。</li><li>缓解交通拥堵：预判交通状况，引导驾驶员选择合适的路线，有效缓解交通拥堵。</li><li>降低能耗和排放：提供合理的行驶建议，帮助驾驶员更节能地驾驶，降低能耗和排放。</li></ul><h3 id="5-商业模"><a href="#5-商业模" class="headerlink" title="5. 商业模"></a>5. 商业模</h3><ul><li>合作伙伴：与汽车制造商、北斗卫星定位服务提供商、道路监控设备供应商建立合作关系，共同推广系统。</li><li>盈利模式：通过向汽车制造商提供系统集成服务、向车主提供增值服务等方式盈利。</li><li>市场推广：通过广告宣传、线上线下活动等提高系统的知名度和认可度。</li></ul><h3 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h3><p><strong>基于北斗的智慧行车安全预警系统具有重要它能够提高道路行驶的安全性和舒适度，通过实时监测和预警服务，有效降低道路交通事故发生率。</strong></p><h2 id="四、注意事项😁"><a href="#四、注意事项😁" class="headerlink" title="四、注意事项😁"></a>四、注意事项😁</h2><table><tr><td bgcolor=MistyRose>1. 前面多出来的的空格对文本没有影响。<br>2. 文本的符号要用中文。<br>3. 语法结合使用的时候注意使用空格。<br>4. markdown语法只能表示分支关系，无法表示合并与递进关系。</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>英语单词</title>
      <link href="/2023/05/18/%E7%AC%AC%E5%8D%81%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/05/18/%E7%AC%AC%E5%8D%81%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="英语单词"><a href="#英语单词" class="headerlink" title="英语单词"></a>英语单词</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">accuse 指责,归咎于,控告</span><br><span class="line">ache 疼痛,渴望</span><br><span class="line">acid 酸的,酸的东西</span><br><span class="line">abolish 废除,取消</span><br><span class="line">abrupt 突然的,唐突的</span><br><span class="line">absolution 绝对的,完全的,独立的</span><br><span class="line">accent 强调,口头,重读</span><br><span class="line">accord 一致的,调解,给予</span><br><span class="line">acquaint 使认识</span><br><span class="line">acute 尖的,敏锐的</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 单词 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言</title>
      <link href="/2023/02/19/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/02/19/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><p>1.while((a[i]&#x3D;getchar()!&#x3D;’\n’)一定要写a[i]不可a[]</p><p>2.字母大小写转换<br>是<br>for(j&#x3D;0;str[j]!&#x3D;’\0’;j++){<br>        if(str[j]&gt;&#x3D;’A’&amp;&amp;str[j]&lt;&#x3D;’Z’){<br>            str[j]&#x3D;str[j]-‘A’+’a’;<br>        }else if(str[j]&gt;&#x3D;’a’&amp;&amp;str[j]&lt;&#x3D;’z’){<br>                str[j]&#x3D;str[j]-‘a’+’A’;<br>        }<br>    }<br>不是<br>for(j&#x3D;0;str[j]!&#x3D;’\0’;j++){<br>        if(str[j]&gt;&#x3D;’A’&amp;&amp;str[j]&lt;&#x3D;’Z’){<br>            str[j]&#x3D;str[j]-‘A’+’a’;<br>        }<br>        if(str[i]&gt;&#x3D;’a’&amp;&amp;str[i]&lt;&#x3D;’z’){<br>            str[j]&#x3D;str[j]-‘a’+’A’;<br>        }</p><p>3.void型函数声明与int型函数的声明不一样<br>void fan(int n)<br>int fan(n)</p><p>4.数组作为函数参数时<br>void fan(int a[])只能使用a[]<br>void fan(int *a)只能使用地址a</p><p>5.输入字符串一般用gets()加n&#x3D;strlen(a),而不用a[i]&#x3D;getchar()</p><p>6.一定注意提示内容,不然很容易出现错误</p><p>7.int型函数声明要放在在主函数里并且要有数据类型的单位，void可以省略</p><p>8.字符’1’的ASCLL码不是1,所以在运用数字字符时要使用偏移量a[i]-‘0’</p><p>9.十六进制转化为十进制<br>数字字符 number&#x3D;number<em>10+a[i]-‘0’<br>大小写字母 number&#x3D;number</em>10+a[i]-‘a’+10</p><p>10.数组的长度限定可能会影响得分，要往大得方向调</p><p>11.记得用for(i&#x3D;0;i&lt;strlen(a);i++)</p><p>12.函数的形参可以与实参不一样<br>int a(int b,int c)<br>int d,int e;</p><p>13.数字数组的n为长度即可,而字符数组的长度要为n+1,因为存在’\0’,数组字符没有,所以new char[n+1]</p><p>14.使用字符串动态内存分配后一定要给上’&#x2F;0’,char a[5]长度为6,因为还有一个’&#x2F;0’;</p><p>15.对数字字符进行处理时要转化数字,a[i]-‘0’</p><p>16.链表一定要考虑链表头部和尾部的操作的情况和链表为空</p><p>17.ptr2!&#x3D;NULL    ptr2-&gt;next!&#x3D;NULL<br>都是表示到达了链尾,ptr2 !&#x3D; NULL判断ptr2指针本身是否为空.ptr2-&gt;next !&#x3D; NULL判断ptr2指针所指向节点的下一个节点是否存在.</p><p>ptr1 &#x3D; ptr2;    把节点里的全部内容给到1，包括节点指针也给ptr1,这个操作将ptr2的值赋给ptr1，使得它们指向相同的节点。这意味着ptr1和ptr2将指向链表中的同一个节点，它们指向的节点的地址是相同的。</p><p>有head-&gt;next的形式</p><p>p-&gt;num  p是地址结构指针不可以使用*p</p><p>18.typedef struct{<br>    short level;<br>    char fd;<br>} FILE;<br>FILE是结构名，还没有结构变量名<br>typedef是自定义类型</p><p>19.自定义数组名<br>typedef int a[10];<br>typedef a NUM;<br>int a[10]可简化为NUM a;<br>文件指针不可以进行fp++或*fp </p><ol start="20"><li>scanf(“%s%s”, su.username, su.password);<br>使用一行输入的话要打一个空格就行，两行输入也行</li></ol><p>21.字符方式文件读写函数:fgetc()和fputc();  ch&#x3D;fgetc(fp)  fputc(ch,fp)<br>字符串方式文件读写函数:fputs(),fgets();    fgets(s,n,fp)有很多注意的地方;<br>数据块方式文件读写函数:fwrite(),fread();   fread(buffer,size,count,fp)</p><p>22.文件中设置了文件结束符EOF是一个值为-1的常量</p><p>23.strcpy(usr, psu-&gt;username);<br>    strcpy(pwd, pus-&gt;password);<br>    encrypt(pwd);<br>    strcat(usr, “ “);<br>    strcat(usr, pwd);<br>    strcat(usr, “\n”);<br>连接usr,空格,pwd,和\n构成新字符串usr</p><p>读出文章不会一下读到屏幕上，而是通过打印</p><p>题目中每一个功能对应一个函数</p><p>fseek(cfptr, logcount-1, SEEK_SET);文件位置指针是从零开始的</p><p>考虑文件内容是否为空的情况</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络编程</title>
      <link href="/2023/02/19/%E7%AC%AC%E4%B8%83%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/02/19/%E7%AC%AC%E4%B8%83%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络编程"><a href="#计算机网络编程" class="headerlink" title="计算机网络编程"></a>计算机网络编程</h2><p>在C++中对数组的定义必须在栈区,即使用new，但为了有更多的功能可以使用string,对于指针的定义可以是常量指针，尤其是作为函数的参数时<br>int a&#x3D;10,int *p&#x3D;&amp;a;<br>void a(const *p,int c);</p><p>在C++中一般的地址可以像数组一样使用<br>char *a&#x3D;new char[7];<br>a[1]&#x3D;’a’;</p><p>C++中的while循环用处很大可以<br>int a;<br>while(cin&gt;&gt;a)也可以使用地址作为判断条件<br>int s[12];<br>while(m&lt;&#x3D;n&amp;&amp;a[]) 相当于a[]!&#x3D;’\0’表示当s数组有元素时继续循环</p><p>在类中 Time operator+(const Time &amp; t) const的第二个const的在参数为类时使用的</p><p>关于cout如果有double a;cout&lt;&lt;a;a是整数则会输出没有小数点</p><p>cout&lt;&lt;’a’也会是a不会是数字</p><p>二维数组作为函数的参数时的写法<br>int a[2][2];<br>void a(int a[][2]);</p><p>模板类vector类似于string类,也是一种动态数组,你可以在运行阶段设置vector对象的长度,它是使用new创建动态数组的替代品,它是用new和delete来管理内,必须包含头文件<vector>,其次vector包含在名称空间std中<br>vector<int>vi   vi的长度为0,在你插入或添加值时自动调整长度<br>vector<int>vi(n)或者vi(2),括号中可以是常量也可以是变量 </p><p>模板类array与数组一样,array对象的长度是固定的,也使用栈,不是堆<br>array&lt;int,4&gt;a1;<br>array&lt;int,3&gt;a2&#x3D;{2,3,4};<br>a1&#x3D;a2;</p><p>struct a{<br>  int b;<br>}<br>a *p&#x3D;new a;<br>不需定义结构变量就能使用结构了</p><p>使用string类,必须包含头文件<string>,str.size()是用来计算string对象的长度的,可以将关系运算符用于string对象</p><p>const int *p&#x3D;&amp;a<br>p指向一个const int,*p的值为const不能修改 *p++,a++都不可以，但可以这样<br>a&#x3D;12;cout&lt;&lt;*p;<br>在声明函数的指针形参时或数组形参时,一定要声明为指向const的指针<br>int * const p&#x3D;&amp;a</p><p>强制类型转换运算符有<br>1.const_cast</p><span class='p red'>14.</span>字符函数库cctype<p>1.isalphaw(ch)<br>2.isspace(ch)</p><p>二维数组作为函数时的使用<br>int sum(int a[][2],int size)or int sum(int (*a)[2],int size) 列数是固定的,函数可变</p><p>16.返回引用时最重要的一点是,应避免返回函数终止时不再存在的内存单元引用<br>const free_throws &amp; clone2(free_throws &amp; ft){<br>  free_throws newguy;<br>  newguy&#x3D;ft;<br>  return nreguy;<br>}</p><p>17.可以返回在函数中new的成员作为返回值,因为是在堆中,而不是栈中<br>char* left(const char* str, int n &#x3D; 1);<br>{<br>    if (n &lt; 0) {<br>        n &#x3D; 0;<br>    }<br>    char* p &#x3D; new char[n + 1];<br>    int i;<br>    for (i &#x3D; 0; i &lt; n &amp;&amp; str[i]; i++) {<br>        p[i] &#x3D; str[i];<br>    }<br>    while (i &lt;&#x3D; n) {<br>        p[i++] &#x3D; ‘\0’;<br>    }<br>    return p;<br>}</p><p>18.函数模板的用途,进行数值的交换<br>char* left(const char* str, int n &#x3D; 1);<br>{<br>    if (n &lt; 0) {<br>        n &#x3D; 0;<br>    }<br>    char* p &#x3D; new char[n + 1];<br>    int i;<br>    for (i &#x3D; 0; i &lt; n &amp;&amp; str[i]; i++) {<br>        p[i] &#x3D; str[i];<br>    }<br>    while (i &lt;&#x3D; n) {<br>        p[i++] &#x3D; ‘\0’;<br>    }<br>    return p;<br>}</p><p>19.函数重载的作用是在不同的参数如数组和结构与普通的常量时,使得方法不一样,而导致要重新写方法,但要达到的目的是一致的<br>void Swap(AnyType&amp; a, AnyType&amp; b) {<br>    AnyType temp;<br>    temp &#x3D; a;<br>    a &#x3D; b;<br>    b &#x3D; temp;<br>}</p><p>template <typename T><br>void Swap(T* a, , T* b,int n) {<br>    T temp;<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        temp &#x3D; a[i];<br>        a[i] &#x3D; b[i];<br>        b[i] &#x3D; temp;<br>    }<br>}<br>这是模板与重载的结合使用,使得Swap的功能更丰富</p><p>20.交换了结构体的成员,运用了显式具体化<br>template <typename T><br>void Swap(T &amp; a, , T &amp; b, int n);<br>template &lt;&gt; void Swap<job>(job&amp; j1, job&amp; j2) {<br>    double t1;<br>    int t2;<br>    t1 &#x3D; j1.salary;<br>    j1.salary &#x3D; j2.salary;<br>}</p><p>template void Swap<job>(job&amp; j1, job&amp; j2)；则运用了显式实列化,没有自己的方法</p><p>21.定位new运算符<br>char buffer1[50];<br>char buffer2[500];<br>chaff* p2 &#x3D; new(buffer1) chaff;<br>chaff* p2&#x3D; new(buffer1+N<em>sizeof(char)) char;    第二次分配的用法<br>int</em> p1 &#x3D; new(buffer2) int[20];<br>delete [] p1;<br>不可使用delete,一般的new才可以</p><p>22.都是输出字符串地址的方法<br>char buffer[4] &#x3D; “asd”;<br>    cout &lt;&lt; (void*)buffer &lt;&lt; endl;   强制转换为void*<br>    cout &lt;&lt; &amp;buffer[i] &lt;&lt; endl;</p><p>23.静态变量的用法<br>int global&#x3D;1000;   链接性为外部的静态变量<br>extern int global&#x3D;1000;  链接性为外部的静态变量,并且让内部使用<br>static int one&#x3D;12;  链接性为内部的静态变量<br>int main()<br>{<br> …..<br>}<br>void funct(int n)<br>{<br>    static int count&#x3D;9   无链接性的静态变量<br>}</p><p>24.创建新的名称空间<br>namespace Jack{<br>    double pail;<br>    void fetch();<br>}</p><p>25.所创建的每个新对象都有自己的存储空间,用于存储其内部变量和类成员,<br>但同一个类的所有对象共享同一组类方法,即每种方法只有一个副本,在OOP中，<br>调用成员函数被称为发送消息,因此将同样的消息发送给两个不同的对象将调用<br>同一个方法,但该方法被用于两个不同的对象</p><p>26.为对象动态分配存储空间,在这种情况下,对象没有名称,但可以使用指针来管理该对象,叫对象指针<br>stock* p &#x3D; new stock(“qwe”, 2);  构造函数与new的结合</p><p>27.在构造函数构造出对象之前,对象是不存在的,因此构造函数被用来创建对象,而不是用对象调用的</p><p>28.定义默认构造函数的两种方法<br>c++提供的默认构造函数,它创建对象,但不初始化其成员</p><p>stock::stock()<br>{<br>    company&#x3D;”ad”;<br>    shares&#x3D;0;<br>}</p><p>stock(const stock &amp;s&#x3D;”asd,int n&#x3D;1)<br>{<br>    ….      这样创建后,可以不用显示初始化    stock first,不需要打()<br>}<br>29.ifndef 技术用来防止多重包含</p><p>30.b对象已经存在,因此这条语句不是进行初始化,而是将新值赋给它<br>stock b;<br>b &#x3D; stock(“zxc”, 3);<br>会创建一个新的临时的对象,然后调用析构函数</p><p>31.这是错误的,show()无法保证调用的对象不被修改<br>const stock b(“asd”, 3);<br>b.show();<br>而是void show() const;意思是不修改调用的对象<br>只要类方法不修改调用的对象,就应将其声明为const</p><p>32.一个方法涉及到两个对象并返回一个对象时就要使用this指针,this设置为a对象的地址</p><p>33.由于该函数返回了两个const对象之一,因此返回类型也应为const引用<br>const stock &amp; topval(const  stock &amp; s) const;<br>使用a.topval(b),则s是b的引用,但a没有引用</p><p>34.在VS中构造函数只能在类定义中定义,不可在类外定义<br>class stock<br>{<br>private:<br>    string company&#x3D;”asd”;<br>    int shares;<br>public:<br>    stock() { company &#x3D; “zxc”; shares &#x3D; 0; };   不可以使用stock()这种默认构造函数了,但可以这样写stock(){}<br>    stock(const string&amp; oc, int n) { company &#x3D; oc; shares &#x3D; n; }    这个结束号可加可不加<br>    ~stock() { cout &lt;&lt; “Bye” &lt;&lt; endl; }<br>    void show() const;<br>    void gai();<br>    const stock &amp; topval(const  stock &amp; s) const;<br>};</p><p>35.指针对象就该这样使用<br>const stock* top &#x3D; &amp;mystuff[1];<br>top &#x3D; &amp;top-&gt;topval(mystuff[2]);<br>top-&gt;show();</p><p>36.因为声明类,并没有创建对象,将没有用于存储的空间<br>class stock<br>{<br>private:<br>    string company&#x3D;”asd”;<br>    int shares&#x3D;1;   这是正确的<br>    const int Months &#x3D; 1;   这是错误的,不能使用它<br>    double costs[Months];   数据成员是数组时,必须使用枚举<br>}</p><p>37.在类声明中声明的枚举的作用域为整个类<br>enum {Months&#x3D;1};<br>double costs[Months];<br>该常量与其他静态变量存储在一起,而不是存储在对象中<br>static const int a &#x3D; 1;</p><ol start="38"><li>bool stock::isempty() const<br>{<br> return top &#x3D;&#x3D; 0;  top&#x3D;&#x3D;0表示的是返回真假<br>}</li></ol><p>39.要重载运算符,需使用被称为运算符函数的特殊函数形式<br>operator<a href=""></a>将重载[]是数组索引运算符<br>将两个数组相加可以定义一个表示数组的类,并重载+运算符<br>运算符重载的目的是使运算符能对类产生作用<br>40.一个是对整个成员数据相加,一个是对一个成员数据相加<br>stock stock::Sum(const stock&amp; t)const<br>{<br>    stock sum;<br>    sum.minutes &#x3D; minutes + t.minutes;<br>    sum.hour &#x3D; hour + t.hour + sum.minutes &#x2F; 60;<br>    sum.minutes %&#x3D; 60;<br>    return sum;<br>}</p><p>void stock::AddHor(int h)<br>{<br>    hour +&#x3D; h;<br>}</p><p>41.operator+   相当函数名<br>stock stock::operator+(const stock&amp; t)const</p><p>42.友元函数不是成员函数,不能由对象调用,一般是对重载运算符函数进行友元操作,不能使用成员运算符来调用  a &#x3D; operator*(2.75, b);<br>在定义时不用::,只是与成员函数有相同的访问权限</p><ol start="43"><li>cout &lt;&lt; trip   是友元函数重载<br>trip &lt;&lt; cout   是成员函数重载</li></ol><p>ostream &amp; operator&lt;&lt;(ostream&amp; os, const stock&amp; t)<br>{<br>    os &lt;&lt; t.hour &lt;&lt; “ “ &lt;&lt; t.minutes &lt;&lt; endl;<br>}</p><p>void operator&lt;&lt;(ostream&amp; os, const stock&amp; t)<br>{<br>    os &lt;&lt; t.hour &lt;&lt; “ “ &lt;&lt; t.minutes &lt;&lt; endl;<br>}<br>可以这样使用 cout&lt;&lt; trip&lt;&lt; “dfs”</p><p>44.int *p&#x3D;10   p表示的是int *类型的,int *表示指针也即地址</p><p>45.这个构造函数用于将double类型的值转换为stock类类型,将构造函数用作隐式转换函数<br>stock::stock(double lbs)<br>{<br>    hour &#x3D; int(lbs);<br>    minutes &#x3D; int(lbs);<br>}</p><p>stock a;<br>a &#x3D; 19.9;   把一个值赋给对象</p><p>explicit stock(double lbs)  只能使用显示强制类型转换<br>stock a;<br>a&#x3D;stock(19.9);</p><p>void display(const stock &amp; st,int n);<br>disfplay(422,4);   可以这样写</p><p>46.转换函数<br>operator int() const<br>{<br>    return int (pounds+0.5);<br>}<br>stock v;<br>int a&#x3D;(int)v;   没有声明返回类型,但将返回所需的值,也不使用调用的形式<br>int a&#x3D;v;   这是隐式转换</p><p>explicit operator int() const;    显示转换函数</p><p>int stock::a(){return int(pound+0.5);}  功能相同的非转换函数<br>int plb&#x3D;对象.a();</p><p>stock t(6,7);<br>int r&#x3D;9;<br>stock e;<br>e&#x3D;t+r;   将r转换为类对象进行相加</p><p>47.类的动态内存分配不仅可以及时删除内存,还可以改变数组的长度,在创建多个对象数组时而不浪费内存<br>在类成员中使用char指针</p><p>48.字符串并不保存在对象中,而是被单独保存在堆内存中，对象保存了指到哪里去查找字符串的信息,只是保存了指针<br>String::String(const char* s)<br>{<br>    len &#x3D; strlen(s);<br>    str &#x3D; new char[len + 1];<br>    str&#x3D;nullptr;<br>    str&#x3D;0;<br>    str[1]&#x3D;’\0’;<br>    strcpy(str, s);    将字符串复制到内存中即创建字符串的副本<br>    str&#x3D;s;  这是错误的,这只保存了地址,而没有创建字符串的副本<br>    cout &lt;&lt; num_strings &lt;&lt; str &lt;&lt; endl;<br>}</p><p>49.这个使用的是复制构造函数,而不是一般的构造函数<br>String sailor&#x3D;sports;   一个对象初始化另一个对象,但调用了赋值运算符<br>String sailor&#x3D;String(sports);   复制构造函数的原型为<br>String(const &amp; string);  它创建对象的一个副本(指针)</p><p>String *a&#x3D;new String (motto)<br>String b&#x3D;String(c)<br>String c(s)      都会调用复制构造函数,都是生成一个临时对象</p><p>sailor&#x3D;sports   一个对象赋给另一个对象,这个对象也是sailor对象的一个副本(指针)</p><p>如果类中包含这样的静态数据成员,即其值将在新对象被创建时发生改变,则应该提供一个显示复制构造函数来处理计数问题</p><p>sailor.str&#x3D;sports.str   这里复制的并不是字符串,而是一个指向字符串的指针</p><p>显示复制构造函数<br>String::String(const char* s)<br>{<br>    len &#x3D; s.len;<br>    str &#x3D; new char[len + 1];<br>    strcpy(str, s.str);<br>    str&#x3D;s;<br>    cout &lt;&lt; num_strings &lt;&lt; str &lt;&lt; endl;<br>}</p><p>赋值运算符也是用了成员的复制</p><p>String &amp; String:: operator&#x3D;(const String &amp; s)<br>{<br>    if(thi&#x3D;&#x3D;&amp;s) return *this;<br>    delete [] str;<br>    len&#x3D;s.len;<br>    str&#x3D;new char[len+1];<br>    strcpy(str, s.str);<br>    return *this;<br>}</p><p>50.[]的重载<br>char &amp; String::operator[](int i)<br>{<br>    return str[i];<br>}</p><p>静态成员函数使用<br>static int HowMany() {return num_String}<br>int String::HowMany()<br>int count&#x3D;String::HowMany();</p><p>把字符串赋值给类<br>String &amp; String:: operator&#x3D;(const char*s)    对指针一般不使用引用<br>{<br>    if(thi&#x3D;&#x3D;&amp;s) return *this;<br>    delete [] str;<br>    len&#x3D;s.len;<br>    str&#x3D;new char[len+1];<br>    strcpy(str, s.str);<br>    return *this;<br>}</p><p>输入运算符的重载<br>istream &amp; operator&gt;&gt;(istream &amp; is, String &amp; s)<br>{<br>    char temp[2];<br>    is.get(temp,2);<br>    if(is){<br>        s&#x3D;temp;   必须要有把字符串赋值给类的赋值函数<br>    }<br>    while(is&amp;&amp;is.get()!&#x3D;’\n’)   continue;<br>    return is;<br>}</p><p>51.类库是可以修改的,函数库是不能修改的</p><p>52.TableTennisPlayer类表示俱乐部的乒乓球成员,RatedPlayer类表示一些成员参加过乒乓球锦标赛,公有继承对象包括基类对象<br>创建派生类对象时,程序首先创建基类对象派生类构造函数必须使用基类构造函数,派生类更具体一些</p><p>53.构造函数列表初始化<br>String(const string&amp; fn &#x3D; “none”, const string&amp; In &#x3D; “none”, bool ht &#x3D; false);<br>String::String(const string&amp; fn, const string&amp; In, bool ht) :firstname(fn), lastname(In), hasTable(ht) { }</p><p>54.派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数<br>derived::derived(typee1 x,type2 y):base(x,y)   它有两个参数,括号就包含两个参数</p><p>Stringn(const string&amp; fn &#x3D; “none”, const string&amp; In &#x3D; “none”, bool ht &#x3D; false,int g&#x3D;0);<br>Stringn::Stringn(const string&amp; fn, const string&amp; In, bool ht, int g) :String(fn, In, ht)<br>{<br>    rating &#x3D; g;<br>}<br>Stringn::Stringn(const string&amp; fn, const string&amp; In, bool ht, int g)<br>{<br>    rating &#x3D; g;    这是调用了基类的默认构造函数<br>}</p><p>Stringn(int r, const String&amp; tp);<br>Stringn::Stringn(int r, const String&amp; tp) :String(tp),rating(r)<br>{<br>                参数虽然与基类默认构造函数不一样,但可以使用,将调用基类的复制构造函数<br>}  </p><p>54.基类指针可以指向派生类对象或引用派生类对象<br>Stringn b(“sd”, “qw”, true, 2);<br>String&amp; c &#x3D; b;<br>String* d &#x3D; &amp;b;<br>基类引用或指针参数可以指向 基类对象或派生类对象<br>void show(const String&amp; s)<br>{<br>    s.Name();<br>}<br>show(d);<br>show(c);<br>void show(const String*s)   也是一样的</p><p>55.可以将基类对象初始化派生类对象,也可以将派生类对象赋值给基类对象<br>必须像54一样先定义基类引用<br>Stringn a(“sd”,”sdf”,false);<br>String b(a);      将调用隐式赋值构造函数<br>b&#x3D;a;</p><p>56.is-a即派生类对象是一个基类对象,可以对基类执行的任何操作,也可以对派生类对象执行<br>香蕉是水果   is-a   不可有律师就像是鲨鱼,早餐是水果<br>早餐有水果   have-a   栈不是数组,栈不包括数组索引<br>uses-a   is-like-a  is-implemented-as-a</p><p>57.多态公有继承<br>虚方法使得派生类和基类对象使用的方法有所不同<br>class brass<br>{<br>private: </p><p>public:<br>    virtual void withdraw(double amt);<br>    virtual ~brass(){};  为基类声明一个虚析构函数也是一种惯例<br>};</p><p>class brassplus :public brass<br>{<br>    private:<br>        int rating;<br>    public:<br>        virtual void withdraw(double amt);<br>};</p><div class="tabs" id="test1"><ul class="nav-tabs"></ul><div class="tab-contents"></div></div><ol><li><p>在C++中对数组的定义必须在栈区，即使用new。但为了有更多的功能，可以使用string。对于指针的定义可以是常量指针，尤其是作为函数的参数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">(<span class="type">const</span> *p, <span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在C++中，一般的地址可以像数组一样使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *a = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">7</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>C++中的while循环用处很大，可以使用地址作为判断条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; a)</span><br></pre></td></tr></table></figure><p>也可以使用数组作为判断条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">while</span> (m &lt;= n &amp;&amp; a[])  <span class="comment">// 相当于a[] != &#x27;\0&#x27;，表示当s数组有元素时继续循环</span></span><br></pre></td></tr></table></figure></li><li><p>在类中，Time operator+(const Time &amp; t) const的第二个const在参数为类时使用。</p></li><li><p>关于cout，如果有double a; cout &lt;&lt; a;，a是整数则会输出没有小数点。cout &lt;&lt; ‘a’也会输出a，不会是数字。</p></li><li><p>二维数组作为函数的参数时的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>模板类vector类似于string类，也是一种动态数组。你可以在运行阶段设置vector对象的长度，它是使用new创建动态数组的替代品，它是用new和delete来管理内存。必须包含头文件<vector>，其次vector包含在命名空间std中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi;  <span class="comment">// vi的长度为0，在你插入或添加值时自动调整长度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vi</span><span class="params">(n)</span></span>;  <span class="comment">// 或者 vi(2)，括号中可以是常量也可以是变量</span></span><br></pre></td></tr></table></figure></li><li><p>模板类array与数组一样，array对象的长度是固定的，也使用栈，不是堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a1;</span><br><span class="line">array&lt;<span class="type">int</span>, 3&gt; a2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">a1 = a2;</span><br></pre></td></tr></table></figure></li><li><p>不需定义结构变量就能使用结构了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">A *p = <span class="keyword">new</span> A;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32单片机编程</title>
      <link href="/2023/02/19/%E7%AC%AC%E4%BA%94%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/02/19/%E7%AC%AC%E4%BA%94%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="STM32-单片机编程"><a href="#STM32-单片机编程" class="headerlink" title="STM32 单片机编程"></a>STM32 单片机编程</h2><p>STM32 常用外设函数</p><p>1.void GPIO_DeInit 所指定的 GPIO 外设就会被复位</p><p>2.void GPIO_AFIODeInit 所指定的 AFIO 外设复位</p><p>3.GPIO_Init 用结构体参数来初始化 GPIO 口</p><p>4.GPIO_StructInit 把结构体变量赋一个默认值</p><p>5.GPIO 读取函数<br>uint8_t GPIO_ReadInputDataBit 用来读取输入数据寄存器某一个端口的输入值<br>uint16_t GPIO_ReadInputData 用来读取整个输入数据寄存器的，返回值的每一位代表一个端口值<br>uint8_t GPIO_ReadOutputDataBit 用来读取输出数据寄存器的某一位<br>uint16_t GPIO_ReadOutputData 用来读取整个输出寄存器的</p><p>6.GPIO 输出函数<br>GPIO_SetBits 设置为高电平<br>GPIO_ResetBits 设置为低电平<br>GPIO_WriteBit Bit_RESET 为低电平 Bit_SET 为高电平<br>GPIO_Write 十六进制设置</p><p>7.Uint8_t 是 unsigned char 的意思</p><p>8.STM32 的程序编写尽量考虑将相同的类型放在同一函数里</p><p>9.RCC 开启内部时钟，即定时器的基准时钟和整个外设的工作时钟都会同时打开了</p><p>10.定时器 time 常用函数 TIM 是定时器<br>TIM_TimeBaseInit 时基单元初始化<br>TIM_TimeBaseStructInit 给结构体设置默认值<br>TIM_Cmd 用来使能计数器<br>TIM_ITConfig 用来使能中断输出信号<br>TIM_InternalClockConfig 选择内部时钟<br>TIM_ITRxExternalClockConfig 选择 ITRx 其他定时器的时钟<br>TIM_TIxExternalClockConfig 选择 TIx 捕获通道的时钟<br>TIM_ETRClockMode1Config 选择 ETR 通过外部时钟模式 1 输入的时钟<br>单独的函数可以方便更改结构体的关键参数<br>TIM_PrescalerConfig 单独写预分频值的<br>TIM_CounterModeConfig 用来改写计数器的计数模式<br>TIM_ARRPreloadConfig 自动重装器预装功能配置<br>TIM_SetCounter 给计数器写入一个值，如果你想手动给一个计数值，就可以用这个函数<br>TIM_SetAutoreload 给自动重装器写入一个值，如果你想手动给一个自动重装值，就可以用这个函数<br>TIM_GetCounter 获取当前计数器的值，如果你想看当前计数器计到哪里了，就可以用这个函数<br>TIM_TimeBaseInitTypeDef 结构体的参数配置<br>TIM_RepetitionCounter &#x3D; 0;重复计数器,高级定时器才有的<br>TIM_ClockDivision 不重要<br>重要两个参数 TIM_Period 配置 ARR TIM_Prescaler 配置 PSC<br>定时频率&#x3D;72M&#x2F;(PSC+1)&#x2F;(ARR+1) 定时 1s,也就是定时频率为 1Hz,PSC&#x3D;7200-1,ARR&#x3D;10000-1,PSC,ARR 取值在 0~65535 之间<br>定时器可以用来定时中断<br>TIM2_IRQHandler 是定时器2的中断函数,当定时器产生更新中断是,这个函数就会自动被执行暂停<br>想要让定时器每秒自动帮我们加一下Num这个变量</p><p>11.用来初始化输出比较单元<br>TIM_OC1Init 不同的通道对应的 GPIO 口不一样的,即函数对应不同的 GPIO 口<br>TIM_OC2Init 使用 TIM2 的 OC1 也就是 CH1 通道,输出 PWM,那它只能在 PA0 的引脚输出,需要查看引脚定义表<br>TIM_OC3Init 其他外设也是一样的,如使用 I2C2 的 SCL 引脚,那就是 PB10,无法更改，可以用重映射解决<br>TIM_OC4Init</p><p>12.这四个用来单独更改 CCR 寄存器值的函数，我们在运行的时候,可以用它更改占空比<br>TIM_SetCompare1 是设置 CCR 寄存器的值<br>TIM_SetCompare2<br>TIM_SetCompare3<br>TIM_SetCompare4</p><p>13.给输出比较单元的结构体赋初始值<br>TIM_OCInitStructure</p><p>14.结构体中的变量 TIM_OCInitStructure.TIM_Pulse 决定了输出 PWM 的占空比<br>ARR,PSC 决定了 PWM 的周期<br>计算公式：<br>PWM 频率：Freq&#x3D;CK_PSC&#x2F;(PSC+1)&#x2F;(ARR+1)&#x3D;1000 1KMz 720<br>PWM 占空比: Duty&#x3D;CCR&#x2F;(ARR+1)&#x3D;50% 50 因为占空比为 50%,所以 TIM_Pulse 为 50,调节亮度用的<br>PWM 分频率: Reso&#x3D;1&#x2F;(ARR+1)&#x3D;1% 100</p><p>15.外设.c 文件主要是放实现功能的函数，main.c 主要是利用功能函数</p><p>16.USB 转串口模块<br>通信引脚为 TXD,RXD<br>PA9 的 USART1_TX 表示发送,接的就是串口模块的 PXD,接收<br>PA10 的 USART1_RX 表示接收,串口模块的 TXD 就是发送</p><p>常用函数<br>USART_SendData,发送数据,就是写 DR 寄存器<br>USART_ReceiveData,接收数据,就是读 DR 寄存器</p><p>17.寄存器是意思是地址</p><p>18.有一些口是不能用的,不如是用来做调试的端口</p><p>19.杜邦线橙色是 VCC,插在正极供电孔,灰色是 GND,插在负极供电孔,红色的是控制脚,插在引脚处</p><p>20.OLED 的 SCL 和 SDA 是 I2C 的通信引脚,需要接在单片机 I2C 的通信的引脚上,用的是 GPIO 口模拟的 I2C<br>如果是 GPIO 口模拟的 I2C 通信,这两个端口就可以任意接在 GPIO 口上<br>自己含有一个现成的 OLED 驱动模块<br>OLED——Font.h 存的是 OLED 的字库数据,可以用来显示字符图形<br>OLED_ShowChar 显示一个字符</p><ol start="21"><li><p>keil自带的调试的用途</p></li><li><p>不清楚程序是如何运行的</p></li><li><p>想要看一大堆变量却不方便显示的</p></li><li><p>看一下寄存器是不是配置正确了</p></li><li><p>在这个函数中就以这个函数为思考对象，viod返回类型是发送数据，整数类型是接受数据</p></li></ol><h2 id="IIC通信"><a href="#IIC通信" class="headerlink" title="IIC通信"></a>IIC通信</h2><h3 id="IIC协议层"><a href="#IIC协议层" class="headerlink" title="IIC协议层"></a>IIC协议层</h3><img src="/imgs/4.jpg" alt="示例图片" style="zoom:50%;" /><h2 id="AT24C02-x2F-EEPROM"><a href="#AT24C02-x2F-EEPROM" class="headerlink" title="AT24C02&#x2F;EEPROM"></a>AT24C02&#x2F;EEPROM</h2><h3 id="AT24C02-x2F-EEPROM概述"><a href="#AT24C02-x2F-EEPROM概述" class="headerlink" title="AT24C02&#x2F;EEPROM概述"></a>AT24C02&#x2F;EEPROM概述</h3><img src="/imgs/1.jpg" alt="示例图片" style="zoom:50%;" />1. I2C/IIC是通过硬件地址+可编程地址进行通信的2. SCL和SDA分别为时钟线和数据线3. 高四位是固定的即硬件地址，是厂家生产设定的。后三位是可编程地址。4. 5？<h3 id="AT24C02写数据时序"><a href="#AT24C02写数据时序" class="headerlink" title="AT24C02写数据时序"></a>AT24C02写数据时序</h3><img src="/imgs/2.jpg" alt="示例图片" style="zoom:50%;" />1. ACK为等待应答<h3 id="AT24C02读数据时序"><a href="#AT24C02读数据时序" class="headerlink" title="AT24C02读数据时序"></a>AT24C02读数据时序</h3><img src="/imgs/3.jpg" alt="示例图片" style="zoom:50%;" />1. 多了一个发送设备地址的节点2. 读和写的时序开始都有发送设备的节点<h2 id="外设控制代码编写"><a href="#外设控制代码编写" class="headerlink" title="外设控制代码编写"></a>外设控制代码编写</h2><ol><li>&#x2F;**</li></ol><ul><li>函数名：LoadOrNot</li><li>描述：检测药品装载</li><li>过程：等待药品装载-&gt;装药-&gt;取药</li><li>输入：无</li><li>输出：0-等待 1-装药 2-取药<br>uint16_t LoadOrNot(void)<br>{<br>static uint8_t load_flag;<br>if(DRUG_Testing&#x3D;&#x3D;1)<br>{<br>  load_flag&#x3D;1;<br>  return 1;<br>}else if(DRUG_Testing&#x3D;&#x3D;0)<br>{<br>  if(load_flag&#x3D;&#x3D;1)<br>  {<br>return 2;<br>  }<br>}<br>return 0;<br>}</li></ul><h2 id="小车逻辑代码编写"><a href="#小车逻辑代码编写" class="headerlink" title="小车逻辑代码编写"></a>小车逻辑代码编写</h2><h2 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h2><ol><li>led控制 使用正点原子家的sys函数中的位带操作</li><li>检测药品 使用正点原子家的sys函数中的位带操作</li><li>dian’z</li></ol>]]></content>
      
      
      <categories>
          
          <category> STM32单片机编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32单片机编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言实现的程序代码</title>
      <link href="/2023/02/19/%E7%AC%AC%E5%85%AB%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/02/19/%E7%AC%AC%E5%85%AB%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h1><h2 id="2048小游戏"><a href="#2048小游戏" class="headerlink" title="2048小游戏"></a>2048小游戏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>][<span class="number">4</span>]=&#123;</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在一个为0的位置，随机生成一个2/4*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">random_produce</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//记录二维数组中为0的元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> zero1[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//这个数组记录二维数组中，元素为0的值的下标</span></span><br><span class="line"><span class="type">int</span> i,j,num=<span class="number">0</span>,k=<span class="number">0</span>; <span class="comment">//num表示为二维数组0的个数</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">zero1[k++]=i;</span><br><span class="line">zero1[k++]=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>)); <span class="comment">//设置随机因子</span></span><br><span class="line"><span class="type">int</span> b = rand()%num; <span class="comment">//b用来确定随机到哪一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c = rand()%<span class="number">3</span>; <span class="comment">//c确定随机到的值是2还是4</span></span><br><span class="line"><span class="keyword">if</span>(c == <span class="number">2</span>) <span class="comment">// 2的概率是2/3，4的概率是1/3</span></span><br><span class="line">&#123;</span><br><span class="line">a[zero1[<span class="number">2</span>*b]] [zero1[<span class="number">2</span>*b+<span class="number">1</span>]] =<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a[zero1[<span class="number">2</span>*b]] [zero1[<span class="number">2</span>*b+<span class="number">1</span>]] =<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左划合并更新数组</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">0：代表无效滑动</span></span><br><span class="line"><span class="comment">1：代表有效滑动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">move_left</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">//有效滑动的标志位</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="comment">//遍历行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先合并</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1， 找到第一个不为0的数字</span></span><br><span class="line"><span class="keyword">if</span>(a[i][j] !=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从第一个不为0的数字往后找</span></span><br><span class="line"><span class="keyword">for</span>(k=j+<span class="number">1</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//后面为0，忽略</span></span><br><span class="line"><span class="keyword">if</span>(a[i][k] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后面相等，合并</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i][k] == a[i][j])</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>; </span><br><span class="line">a[i][j]*=<span class="number">2</span>;</span><br><span class="line">a[i][k] = <span class="number">0</span>; <span class="comment">//清0</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//只合并一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后面不相等，并且不为0</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i][k] != a[i][j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//退出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再向左并拢</span></span><br><span class="line">k = <span class="number">0</span>; <span class="comment">//并拢的位置</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j] !=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i][k]= a[i][j];</span><br><span class="line"><span class="keyword">if</span>(k != j) <span class="comment">//自己的位置和要并拢的位置不一样 </span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">a[i][j]=<span class="number">0</span>; <span class="comment">//将自己清0</span></span><br><span class="line">&#125;</span><br><span class="line">k++; <span class="comment">//并拢的位置往后移动</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">move_right</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">//有效滑动的标志位</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="comment">//遍历行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先合并</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">3</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1， 找到第一个不为0的数字</span></span><br><span class="line">            <span class="keyword">if</span>(a[i][j] !=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//从第一个不为0的数字往前找</span></span><br><span class="line">                <span class="keyword">for</span>(k=j<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//前面为0，忽略</span></span><br><span class="line">                    <span class="keyword">if</span>(a[i][k] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前面相等，合并</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(a[i][k] == a[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = <span class="number">1</span>; </span><br><span class="line">                        a[i][j]*=<span class="number">2</span>;</span><br><span class="line">                        a[i][k] = <span class="number">0</span>; <span class="comment">//清0</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//只合并一次</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前面不相等，并且不为0</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(a[i][k] != a[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//退出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再向右并拢</span></span><br><span class="line">        k = <span class="number">3</span>; <span class="comment">//并拢的位置</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">3</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] !=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][k]= a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(k != j) <span class="comment">//自己的位置和要并拢的位置不一样 </span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    a[i][j]=<span class="number">0</span>; <span class="comment">//将自己清0</span></span><br><span class="line">                &#125;</span><br><span class="line">                k--; <span class="comment">//并拢的位置往前移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">move_up</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">//有效滑动的标志位</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) <span class="comment">//遍历列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先合并</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1， 找到第一个不为0的数字</span></span><br><span class="line">            <span class="keyword">if</span>(a[i][j] !=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//从第一个不为0的数字往后找</span></span><br><span class="line">                <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//后面为0，忽略</span></span><br><span class="line">                    <span class="keyword">if</span>(a[k][j] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//后面相等，合并</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(a[k][j] == a[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = <span class="number">1</span>; </span><br><span class="line">                        a[i][j]*=<span class="number">2</span>;</span><br><span class="line">                        a[k][j] = <span class="number">0</span>; <span class="comment">//清0</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//只合并一次</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//后面不相等，并且不为0</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(a[k][j] != a[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//退出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再向上并拢</span></span><br><span class="line">        k = <span class="number">0</span>; <span class="comment">//并拢的位置</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] !=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k][j]= a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(k != i) <span class="comment">//自己的位置和要并拢的位置不一样 </span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    a[i][j]=<span class="number">0</span>; <span class="comment">//将自己清0</span></span><br><span class="line">                &#125;</span><br><span class="line">                k++; <span class="comment">//并拢的位置往后移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">move_down</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">//有效滑动的标志位</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) <span class="comment">//遍历列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先合并</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">3</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1， 找到第一个不为0的数字</span></span><br><span class="line">            <span class="keyword">if</span>(a[i][j] !=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//从第一个不为0的数字往前找</span></span><br><span class="line">                <span class="keyword">for</span>(k=i<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//前面为0，忽略</span></span><br><span class="line">                    <span class="keyword">if</span>(a[k][j] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前面相等，合并</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(a[k][j] == a[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = <span class="number">1</span>; </span><br><span class="line">                        a[i][j]*=<span class="number">2</span>;</span><br><span class="line">                        a[k][j] = <span class="number">0</span>; <span class="comment">//清0</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//只合并一次</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前面不相等，并且不为0</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(a[k][j] != a[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//退出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再向下并拢</span></span><br><span class="line">        k = <span class="number">3</span>; <span class="comment">//并拢的位置</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] !=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[k][j]= a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(k != i) <span class="comment">//自己的位置和要并拢的位置不一样 </span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    a[i][j]=<span class="number">0</span>; <span class="comment">//将自己清0</span></span><br><span class="line">                &#125;</span><br><span class="line">                k--; <span class="comment">//并拢的位置往后移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_chessboard</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;____________________________________\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;____________________________________\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断游戏是否结束</span></span><br><span class="line"><span class="comment">结束返回1</span></span><br><span class="line"><span class="comment">未结束返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gamester</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j] == <span class="number">0</span>)<span class="comment">//游戏继续的条件3,有0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j] == a[i+<span class="number">1</span>][j] )<span class="comment">//游戏继续的条件1，和下面相同</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j] == a[i][j+<span class="number">1</span>])<span class="comment">//游戏继续的条件2，和右边相同</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">游戏运行逻辑函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//第一步，随机在两个空白处生成2或者4</span></span><br><span class="line">random_produce();</span><br><span class="line">random_produce();</span><br><span class="line">print_chessboard();</span><br><span class="line"><span class="type">char</span> defection;</span><br><span class="line"><span class="keyword">while</span>(!gamester())</span><br><span class="line">&#123;</span><br><span class="line">defection=getch();</span><br><span class="line"><span class="keyword">switch</span>(defection)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>: </span><br><span class="line"><span class="keyword">if</span>(move_up())</span><br><span class="line">&#123;</span><br><span class="line">random_produce();</span><br><span class="line">&#125;</span><br><span class="line">print_chessboard();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: </span><br><span class="line"><span class="keyword">if</span>(move_down())</span><br><span class="line">&#123;</span><br><span class="line">random_produce();</span><br><span class="line">&#125;</span><br><span class="line">print_chessboard();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span>(move_left())</span><br><span class="line">&#123;</span><br><span class="line">random_produce();</span><br><span class="line">&#125;</span><br><span class="line">print_chessboard();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: </span><br><span class="line"><span class="keyword">if</span>(move_right())</span><br><span class="line">&#123;</span><br><span class="line">random_produce();</span><br><span class="line">&#125;</span><br><span class="line">print_chessboard();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;游戏结束！\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]&gt;sum)&#123;</span><br><span class="line">sum=a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Your scrod\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">start();</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机时钟"><a href="#随机时钟" class="headerlink" title="随机时钟"></a>随机时钟</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="type">int</span> n,m,i=<span class="number">1</span>,flag;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    m=rand()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line">    flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(n==m)&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Luky you!&quot;</span>);</span><br><span class="line">            flag==<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&gt;m)&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is big\n&quot;</span>,n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is small\n&quot;</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;game over!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="学生管理系统"><a href="#学生管理系统" class="headerlink" title="学生管理系统"></a>学生管理系统</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 100</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_array</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> option, <span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_array</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> option, <span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">remov</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a[MAXM], option, value, n;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input the number of array elements:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input an ordered array element:&quot;</span>);</span><br><span class="line">  input_array(a, n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[1]Insert\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[2]Delete\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[3]Query\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[Other option] End\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input option:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;option);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (option &gt;= <span class="number">1</span> &amp;&amp; option &lt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Input an element:&quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;value);</span><br><span class="line">      select(option, a, value, n);</span><br><span class="line">      <span class="keyword">if</span> (option == <span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        n = n + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Input option:&quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;option);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Thank you&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">input_array</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_array</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The ordered array a is:&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> option, <span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (option)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    insert(option, a, value, n);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    remov(a, value, n);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    query(a, value, n);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> option, <span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, x;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; value)</span><br><span class="line">    &#123;</span><br><span class="line">      x = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = n; i &gt; x; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    a[i] = a[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  a[x] = value;</span><br><span class="line">  n++;</span><br><span class="line">  printf_array(a, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">remov</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, x;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == value)</span><br><span class="line">    &#123;</span><br><span class="line">      x = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = x; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  n--;</span><br><span class="line">  printf_array(a, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mid, low = <span class="number">0</span>, hight = n - <span class="number">1</span>;</span><br><span class="line">  mid = (low + hight) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= hight)</span><br><span class="line">  &#123;</span><br><span class="line">    mid = (low + hight) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == value)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The index is:%d&quot;</span>, mid);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value)</span><br><span class="line">    &#123;</span><br><span class="line">      low = low + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      hight = hight - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This elements does not exist\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转字符串里的单词"><a href="#反转字符串里的单词" class="headerlink" title="反转字符串里的单词"></a>反转字符串里的单词</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将多余的空格除去</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s[j]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)&#123;</span><br><span class="line">                s[i++]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s[i++]=s[j];</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;s[i<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">        s[i<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将整个字符串反转</span></span><br><span class="line">    len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    i=<span class="number">0</span>,j=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="type">char</span> temp=s[i];</span><br><span class="line">        s[i++]=s[j];</span><br><span class="line">        s[j--]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//将每个单词进行反转</span></span><br><span class="line">    i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[j])&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[j]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t=j<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;t)&#123;</span><br><span class="line">            <span class="type">char</span> temp=s[i];</span><br><span class="line">            s[i++]=s[t];</span><br><span class="line">            s[t--]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            i=++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t=j<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;t)&#123;</span><br><span class="line">        <span class="type">char</span> temp=s[i];</span><br><span class="line">        s[i++]=s[t];</span><br><span class="line">        s[t--]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小学口算练习系统"><a href="#小学口算练习系统" class="headerlink" title="小学口算练习系统"></a>小学口算练习系统</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">t_jia</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">t_jian</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">t_cheng</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">t_chu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c1, <span class="type">int</span> c2, <span class="type">int</span> d, <span class="type">int</span> e)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Jia</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Jian</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Cheng</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Chu</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">selectDifficulty</span><span class="params">()</span>;                    <span class="comment">// 选着练习难度级别</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">viewPracticeRecord</span><span class="params">()</span>;                 <span class="comment">// 查看练习记录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">viewAccuracy</span><span class="params">(<span class="type">int</span> total, <span class="type">int</span> correct)</span>; <span class="comment">// 查看正确率</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLog</span><span class="params">()</span>;                           <span class="comment">// 做题时间</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sys</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>]; <span class="comment">// 名字</span></span><br><span class="line">    <span class="type">int</span> x;         <span class="comment">// 学号</span></span><br><span class="line">    <span class="type">int</span> year;      <span class="comment">// 年级</span></span><br><span class="line">    <span class="type">int</span> clas;      <span class="comment">// 班级</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sys</span> <span class="title">who</span>;</span></span><br><span class="line">    <span class="type">int</span> inputErrorCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你的名字:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;who.name);</span><br><span class="line">    getchar(); <span class="comment">// 清除输入缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入你的学号:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;who.x) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar(); <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无效输入，请重新输入。\n&quot;</span>);</span><br><span class="line">            getchar(); <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">            inputErrorCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (inputErrorCount &lt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputErrorCount &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入错误次数过多，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inputErrorCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入你的年纪:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;who.year) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar(); <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无效输入，请重新输入。\n&quot;</span>);</span><br><span class="line">            getchar(); <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">            inputErrorCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (inputErrorCount &lt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputErrorCount &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入错误次数过多，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inputErrorCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入你的班级:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;who.clas) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar(); <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无效输入，请重新输入。\n&quot;</span>);</span><br><span class="line">            getchar(); <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">            inputErrorCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (inputErrorCount &lt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputErrorCount &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入错误次数过多，程序退出。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> difficulty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;欢迎进入练习系统！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请选择你想要进行的练习:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1. 加法练习\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2. 减法练习\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3. 乘法练习\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;4. 除法练习\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            ; <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">1</span> &amp;&amp; (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span> || n == <span class="number">4</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            difficulty = selectDifficulty();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无效输入，请重新输入。\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Jia(difficulty);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        Jian(difficulty);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        Cheng(difficulty);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        Chu(difficulty);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printLog();</span><br><span class="line">    <span class="type">char</span> cu;</span><br><span class="line">    <span class="type">char</span> cm;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你是否想要查看练习记录输入Y或N: &quot;</span>);</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="type">char</span> cm = getchar();</span><br><span class="line">            <span class="keyword">if</span>(cm == <span class="string">&#x27;Y&#x27;</span> || cm == <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                viewPracticeRecord();</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cm == <span class="string">&#x27;N&#x27;</span> || cm == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;非法输入，请重新输入！\n&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;你是否想要继续答题,输入Y或任意键退出: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;cu);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (cu == <span class="string">&#x27;Y&#x27;</span>|| cu==<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;欢迎进入练习系统！\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;请选择你想要进行的练习:\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1. 加法练习\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;2. 减法练习\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;3. 乘法练习\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;4. 除法练习\n&quot;</span>);</span><br><span class="line">                <span class="type">int</span> result = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">                <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    ; <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="number">1</span> &amp;&amp; (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span> || n == <span class="number">4</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    difficulty = selectDifficulty();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;无效输入，请重新输入。\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            srand(time(<span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">switch</span> (n)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Jia(difficulty);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                Jian(difficulty);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                Cheng(difficulty);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                Chu(difficulty);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printLog();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出练习&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">t_jia</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> <span class="comment">// 储存加法</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;练习记录.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);               <span class="comment">// 创建一个指针</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d + %d = %d 正确答案%d\n&quot;</span>, a, b, c, d); <span class="comment">// 将算式存入文件中</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">t_jian</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> <span class="comment">// 储存减法</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;练习记录.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d - %d = %d 正确答案%d \n&quot;</span>, a, b, c, d);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">t_cheng</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> <span class="comment">// 储存乘法</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;练习记录.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d x %d = %d 正确答案%d\n&quot;</span>, a, b, c, d);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">t_chu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c1, <span class="type">int</span> c2, <span class="type">int</span> d, <span class="type">int</span> e)</span> <span class="comment">// 储存除法</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;练习记录.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d / %d = %d  余 %d  正确答案 %d  余 %d\n&quot;</span>, a, b, c1, c2, d, e);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Jia</span><span class="params">(<span class="type">int</span> difficulty)</span> <span class="comment">// 加法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, answer, n, t = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lower_bound, upper_bound;</span><br><span class="line">    <span class="comment">// 根据难度级别设置题目范围</span></span><br><span class="line">    <span class="keyword">switch</span> (difficulty)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        lower_bound = <span class="number">1</span>;</span><br><span class="line">        upper_bound = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        lower_bound = <span class="number">10</span>;</span><br><span class="line">        upper_bound = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        lower_bound = <span class="number">100</span>;</span><br><span class="line">        upper_bound = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的难度级别！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想要练习的题数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始练习：\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = rand() % (upper_bound - lower_bound + <span class="number">1</span>) + lower_bound;</span><br><span class="line">        b = rand() % (upper_bound - lower_bound + <span class="number">1</span>) + lower_bound;</span><br><span class="line">        answer = a + b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = &quot;</span>, a, b);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        getchar();</span><br><span class="line">        t_jia(a, b, c, answer);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (c == answer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，回答正确!\n\n&quot;</span>);</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;很遗憾，回答错误！正确答案是 %d\n\n&quot;</span>, answer);</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你做对的题数为%d,做错的题数为%d\n\n&quot;</span>, t, f);</span><br><span class="line">    viewAccuracy(n, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;============================================\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Jian</span><span class="params">(difficulty)</span> <span class="comment">// 减法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, answer, n, t = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lower_bound, upper_bound;</span><br><span class="line">    <span class="comment">// 根据难度级别设置题目范围</span></span><br><span class="line">    <span class="keyword">switch</span> (difficulty)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        lower_bound = <span class="number">1</span>;</span><br><span class="line">        upper_bound = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        lower_bound = <span class="number">10</span>;</span><br><span class="line">        upper_bound = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        lower_bound = <span class="number">100</span>;</span><br><span class="line">        upper_bound = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的难度级别！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想要练习的题数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始练习：\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = rand() % (upper_bound - lower_bound + <span class="number">1</span>) + lower_bound;</span><br><span class="line">        b = rand() % (upper_bound - lower_bound + <span class="number">1</span>) + lower_bound;</span><br><span class="line">        answer = a - b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - %d = &quot;</span>, a, b);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        getchar();</span><br><span class="line">        t_jian(a, b, c, answer);</span><br><span class="line">        <span class="keyword">if</span> (c == answer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，回答正确！\n\n&quot;</span>);</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;很遗憾，回答错误！正确答案是 %d\n\n&quot;</span>, answer);</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你做对的题数为%d,做错的题数为%d\n\n&quot;</span>, t, f);</span><br><span class="line">    viewAccuracy(t, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;============================================\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Cheng</span><span class="params">(difficulty)</span> <span class="comment">// 乘法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, answer, n, t = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lower_bound, upper_bound;</span><br><span class="line">    <span class="comment">// 根据难度级别设置题目范围</span></span><br><span class="line">    <span class="keyword">switch</span> (difficulty)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        lower_bound = <span class="number">1</span>;</span><br><span class="line">        upper_bound = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        lower_bound = <span class="number">10</span>;</span><br><span class="line">        upper_bound = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        lower_bound = <span class="number">100</span>;</span><br><span class="line">        upper_bound = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的难度级别！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想要练习的题数：\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始练习：\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = rand() % (upper_bound - lower_bound + <span class="number">1</span>) + lower_bound;</span><br><span class="line">        b = rand() % (upper_bound - lower_bound + <span class="number">1</span>) + lower_bound;</span><br><span class="line">        answer = a * b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d x %d = &quot;</span>, a, b);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        getchar();</span><br><span class="line">        t_cheng(a, b, c, answer);</span><br><span class="line">        <span class="keyword">if</span> (c == answer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，回答正确！\n\n&quot;</span>);</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;很遗憾，回答错误！正确答案是 %d\n\n&quot;</span>, answer);</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你做对的题数为%d,做错的题数为%d\n\n&quot;</span>, t, f);</span><br><span class="line">    viewAccuracy(n, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;============================================\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Chu</span><span class="params">(difficulty)</span> <span class="comment">// 除法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, answer, n, t = <span class="number">0</span>, f = <span class="number">0</span>, answer1, answer2, c1, c2;</span><br><span class="line">    <span class="type">int</span> lower_bound, upper_bound;</span><br><span class="line">    <span class="comment">// 根据难度级别设置题目范围</span></span><br><span class="line">    <span class="keyword">switch</span> (difficulty)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        lower_bound = <span class="number">1</span>;</span><br><span class="line">        upper_bound = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        lower_bound = <span class="number">10</span>;</span><br><span class="line">        upper_bound = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        lower_bound = <span class="number">100</span>;</span><br><span class="line">        upper_bound = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的难度级别！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想要练习的题数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始练习：\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = rand() % (upper_bound - lower_bound + <span class="number">1</span>) + lower_bound;</span><br><span class="line">        b = rand() % (upper_bound - lower_bound + <span class="number">1</span>) + lower_bound;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; a)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = b;</span><br><span class="line">            b = a;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        answer1 = a / b;</span><br><span class="line">        answer2 = a % b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d / %d = \t&quot;</span>, a, b);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;余 &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c2);</span><br><span class="line">        getchar();</span><br><span class="line">        t_chu(a, b, c1, c2, answer1, answer2);</span><br><span class="line">        <span class="keyword">if</span> (c1 == answer1 &amp;&amp; c2 == answer2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，回答正确！\n&quot;</span>);</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;很遗憾，回答错误！正确答案是 %d  余  %d\n\n&quot;</span>, answer1, answer2);</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你做对的题数为%d,做错的题数为%d\n\n&quot;</span>, t, f);</span><br><span class="line">    viewAccuracy(t, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;============================================\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">viewPracticeRecord</span><span class="params">()</span> <span class="comment">// 练习记录</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;练习记录.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">char</span> line[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;练习记录：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">viewAccuracy</span><span class="params">(<span class="type">int</span> total, <span class="type">int</span> correct)</span> <span class="comment">// 查看正确率</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> accuracy = (<span class="type">float</span>)correct / total * <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您的正确率为：%.1f%%\n\n&quot;</span>, accuracy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">selectDifficulty</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> difficulty;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请选择难度级别：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1. 简单\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2. 中等\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3. 困难\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;difficulty) != <span class="number">1</span> || difficulty &lt; <span class="number">1</span> || difficulty &gt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;非法输入，请重新输入：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> difficulty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLog</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;练习记录.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件 %s！\n&quot;</span>, <span class="string">&quot;练习记录.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">t</span> =</span> localtime(&amp;now);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;做题时间 %d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, t-&gt;tm_year + <span class="number">1900</span>, t-&gt;tm_mon + <span class="number">1</span>, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扫雷"><a href="#扫雷" class="headerlink" title="扫雷"></a>扫雷</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf8-*-</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_lowercase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">game</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.<span class="built_in">all</span> = []  <span class="comment"># 所有未扫区域的列表</span></span><br><span class="line">        self.mine = []  <span class="comment"># 雷所在区域的列表</span></span><br><span class="line">        self.sweptlist = []  <span class="comment"># 储存已经扫过的区域</span></span><br><span class="line">        self.mark = []  <span class="comment"># 储存已标记区域</span></span><br><span class="line">        self.state = <span class="string">&#x27;reading&#x27;</span>  <span class="comment"># 当前游戏状态</span></span><br><span class="line">        self.timeused = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self, row, column, mine</span>):  <span class="comment"># 创建游戏的函数</span></span><br><span class="line">        self.row = row  <span class="comment"># 游戏行数</span></span><br><span class="line">        self.column = column  <span class="comment"># 游戏列数</span></span><br><span class="line">        self.minenum = mine  <span class="comment"># 游戏雷数</span></span><br><span class="line">        self.root = Tk()</span><br><span class="line">        self.root.title(<span class="string">&#x27;扫雷迷你版&#x27;</span>)</span><br><span class="line">        <span class="comment"># 显示总雷数与已标记雷数之差</span></span><br><span class="line">        <span class="comment"># 计时器</span></span><br><span class="line">        self.minecount = StringVar()</span><br><span class="line">        self.timecount = StringVar()</span><br><span class="line">        self.label1 = Label(self.root, bg=<span class="string">&#x27;black&#x27;</span>, height=<span class="number">2</span>,</span><br><span class="line">                            fg=<span class="string">&#x27;red&#x27;</span>, width=<span class="number">6</span>, textvariable=self.timecount).grid(row=<span class="number">0</span>, column=<span class="number">0</span>, columnspan=<span class="number">2</span>)</span><br><span class="line">        self.label2 = Label(self.root, bg=<span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">                            fg=<span class="string">&#x27;red&#x27;</span>, height=<span class="number">2</span>, width=<span class="number">6</span>, textvariable=self.minecount).grid(row=<span class="number">0</span>,</span><br><span class="line">                                                                                           column=self.column - <span class="number">2</span>,</span><br><span class="line">                                                                                           columnspan=<span class="number">2</span>)</span><br><span class="line">        self.minecount.<span class="built_in">set</span>(self.minenum)</span><br><span class="line">        self.timecount.<span class="built_in">set</span>(<span class="string">&#x27;%03d&#x27;</span> % <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, self.row + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.column):</span><br><span class="line">                self.<span class="built_in">all</span>.append([i, j])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sample(self.<span class="built_in">all</span>, self.minenum):</span><br><span class="line">            self.mine.append(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.mine:</span><br><span class="line">            mine_bt = Button(self.root, width=<span class="number">2</span>, height=<span class="number">1</span>)</span><br><span class="line">            mine_bt.bind(<span class="string">&#x27;&lt;Button-1&gt;&#x27;</span>, self.left_key1)</span><br><span class="line">            mine_bt.bind(<span class="string">&#x27;&lt;Button-3&gt;&#x27;</span>, self.right_key)</span><br><span class="line">            mine_bt.grid(row=i[<span class="number">0</span>], column=i[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.<span class="built_in">all</span>:</span><br><span class="line">            <span class="keyword">if</span> (i <span class="keyword">in</span> self.mine) == <span class="literal">False</span>:</span><br><span class="line">                self.bt = Button(self.root, width=<span class="number">2</span>, height=<span class="number">1</span>)</span><br><span class="line">                self.bt.bind(<span class="string">&#x27;&lt;Button-1&gt;&#x27;</span>, self.left_key)</span><br><span class="line">                self.bt.bind(<span class="string">&#x27;&lt;Button-3&gt;&#x27;</span>, self.right_key)</span><br><span class="line">                self.bt.grid(row=i[<span class="number">0</span>], column=i[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        menubar = Menu(self.root)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> [[<span class="string">&#x27;新游戏&#x27;</span>, self.new],</span><br><span class="line">                  [<span class="string">&#x27;初级&#x27;</span>, self.beginner]]:</span><br><span class="line">            menubar.add_command(label=x[<span class="number">0</span>], command=x[<span class="number">1</span>])</span><br><span class="line">        self.root[<span class="string">&#x27;menu&#x27;</span>] = menubar</span><br><span class="line">        self.root.mainloop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">beginner</span>(<span class="params">self</span>):</span><br><span class="line">        self.root.destroy()</span><br><span class="line">        self.__init__()</span><br><span class="line">        self.size(<span class="number">10</span>, <span class="number">10</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">self</span>):</span><br><span class="line">        self.root.destroy()</span><br><span class="line">        self.__init__()</span><br><span class="line">        <span class="keyword">if</span> self.column == <span class="number">9</span>:</span><br><span class="line">            self.size(self.row, self.column, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quiz</span>(<span class="params">self</span>):</span><br><span class="line">        self.root.destroy()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        self.size(<span class="number">10</span>, <span class="number">10</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">right_key</span>(<span class="params">self, event</span>):</span><br><span class="line">        w = event.widget</span><br><span class="line">        t = w.cget(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">        g = w.grid_info()</span><br><span class="line">        x = <span class="built_in">int</span>(g[<span class="string">&#x27;row&#x27;</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(g[<span class="string">&#x27;column&#x27;</span>])</span><br><span class="line">        <span class="keyword">if</span> t == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            self.mark.remove([x, y])</span><br><span class="line">            w.config(text=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            self.minenum += <span class="number">1</span></span><br><span class="line">            self.minecount.<span class="built_in">set</span>(self.minenum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.mark.append([x, y])</span><br><span class="line">            w.config(text=<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            self.minenum -= <span class="number">1</span></span><br><span class="line">            self.minecount.<span class="built_in">set</span>(self.minenum)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">left_key1</span>(<span class="params">self, event</span>):</span><br><span class="line">        w = event.widget</span><br><span class="line">        g = w.grid_info()</span><br><span class="line">        x = <span class="built_in">int</span>(g[<span class="string">&#x27;row&#x27;</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(g[<span class="string">&#x27;column&#x27;</span>])</span><br><span class="line">        <span class="keyword">if</span> w.cget(<span class="string">&#x27;text&#x27;</span>) != <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            self.state = <span class="string">&#x27;fail&#x27;</span></span><br><span class="line">            Button(self.root, text=<span class="string">&#x27;X&#x27;</span>, fg=<span class="string">&#x27;red&#x27;</span>, relief=SUNKEN).grid(row=x, column=y)</span><br><span class="line">            tl = Toplevel()</span><br><span class="line">            Label(tl, text=<span class="string">&#x27;很抱歉，您输了。&#x27;</span>, width=<span class="number">50</span>).pack()</span><br><span class="line">            Button(tl, text=<span class="string">&#x27;新游戏&#x27;</span>, command=self.new, width=<span class="number">6</span>).pack()</span><br><span class="line">            Button(tl, text=<span class="string">&#x27;退出&#x27;</span>, command=self.quiz, width=<span class="number">6</span>).pack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fail</span>(<span class="params">self</span>):</span><br><span class="line">        tl = Toplevel()</span><br><span class="line">        Label(tl, text=<span class="string">&#x27;很抱歉，您输了。&#x27;</span>, width=<span class="number">50</span>).pack()</span><br><span class="line">        Button(tl, text=<span class="string">&#x27;新游戏&#x27;</span>, command=self.new, width=<span class="number">6</span>).pack()</span><br><span class="line">        Button(tl, text=<span class="string">&#x27;退出&#x27;</span>, command=self.quiz, width=<span class="number">6</span>).pack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">win</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.<span class="built_in">all</span>) == <span class="built_in">len</span>(self.mine):</span><br><span class="line">            self.state = <span class="string">&#x27;win&#x27;</span></span><br><span class="line">            tl = Toplevel()</span><br><span class="line">            bt = Label(tl, text=<span class="string">&#x27;恭喜，您赢了！您所用时间为%d秒。&#x27;</span> % self.timeused, width=<span class="number">50</span>).pack()</span><br><span class="line">            Button(tl, text=<span class="string">&#x27;再来一局&#x27;</span>, command=self.new, width=<span class="number">6</span>).pack()</span><br><span class="line">            Button(tl, text=<span class="string">&#x27;退出&#x27;</span>, command=self.quiz, width=<span class="number">6</span>).pack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">left_key</span>(<span class="params">self, event</span>):</span><br><span class="line">        w = event.widget</span><br><span class="line">        g = w.grid_info()</span><br><span class="line">        x = <span class="built_in">int</span>(g[<span class="string">&#x27;row&#x27;</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(g[<span class="string">&#x27;column&#x27;</span>])</span><br><span class="line">        <span class="keyword">if</span> w.cget(<span class="string">&#x27;text&#x27;</span>) != <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            self.sweptlist.append([x, y])</span><br><span class="line">            self.count(x, y)</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">&#x27;reading&#x27;</span>:</span><br><span class="line">            self.state = <span class="string">&#x27;begin&#x27;</span></span><br><span class="line">            self.f = Thread(target=self.time, args=(), name=<span class="string">&#x27;thread-&#x27;</span>)</span><br><span class="line">            self.f.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self, i, j</span>):</span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line">        a = <span class="built_in">max</span>(i - <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        b = <span class="built_in">min</span>(i + <span class="number">2</span>, self.row + <span class="number">3</span>)</span><br><span class="line">        c = <span class="built_in">max</span>(<span class="number">0</span>, j - <span class="number">1</span>)</span><br><span class="line">        d = <span class="built_in">min</span>(j + <span class="number">2</span>, self.column)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(i - <span class="number">1</span>, i + <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(j - <span class="number">1</span>, j + <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> ([r, s] <span class="keyword">in</span> self.mine) == <span class="literal">True</span>:</span><br><span class="line">                    self.n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.n == <span class="number">0</span>:</span><br><span class="line">            Button(self.root, width=<span class="number">2</span>, height=<span class="number">1</span>, state=<span class="string">&#x27;disabled&#x27;</span>, relief=SUNKEN).grid(row=i, column=j)</span><br><span class="line">            <span class="keyword">if</span> [i, j] <span class="keyword">in</span> self.<span class="built_in">all</span>:</span><br><span class="line">                self.<span class="built_in">all</span>.remove([i, j])</span><br><span class="line">            self.win()</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(a, b):</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(c, d):</span><br><span class="line">                    <span class="keyword">if</span> ([r, s] <span class="keyword">in</span> self.sweptlist) == <span class="literal">False</span>:</span><br><span class="line">                        self.sweptlist.append([r, s])</span><br><span class="line">                        self.count(r, s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = [<span class="string">&#x27;#0000FF&#x27;</span>, <span class="string">&#x27;#008000&#x27;</span>, <span class="string">&#x27;#FF0000&#x27;</span>, <span class="string">&#x27;#00008B&#x27;</span>, <span class="string">&#x27;#8B0000&#x27;</span>, <span class="string">&#x27;#20B2AA&#x27;</span>, <span class="string">&#x27;#000000&#x27;</span>, <span class="string">&#x27;#808080&#x27;</span>]</span><br><span class="line">            x = a[self.n - <span class="number">1</span>]</span><br><span class="line">            bt = Button(self.root, width=<span class="number">2</span>, height=<span class="number">1</span>, fg=x, text=self.n, relief=SUNKEN)</span><br><span class="line">            bt.bind(<span class="string">&#x27;&lt;Double-Button-1&gt;&#x27;</span>, self.doubleleft_key)</span><br><span class="line">            bt.grid(row=i, column=j)</span><br><span class="line">            <span class="keyword">if</span> [i, j] <span class="keyword">in</span> self.<span class="built_in">all</span>:</span><br><span class="line">                self.<span class="built_in">all</span>.remove([i, j])</span><br><span class="line">            self.win()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doubleleft_key</span>(<span class="params">self, event</span>):</span><br><span class="line">        mark = <span class="number">0</span></span><br><span class="line">        w = event.widget</span><br><span class="line">        g = w.grid_info()</span><br><span class="line">        x = <span class="built_in">int</span>(g[<span class="string">&#x27;row&#x27;</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(g[<span class="string">&#x27;column&#x27;</span>])</span><br><span class="line">        a = <span class="built_in">max</span>(x - <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        b = <span class="built_in">min</span>(x + <span class="number">2</span>, self.row + <span class="number">3</span>)</span><br><span class="line">        c = <span class="built_in">max</span>(<span class="number">0</span>, y - <span class="number">1</span>)</span><br><span class="line">        d = <span class="built_in">min</span>(y + <span class="number">2</span>, self.column)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(a, b):</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(c, d):</span><br><span class="line">                <span class="keyword">if</span> [r, s] <span class="keyword">in</span> self.mark:</span><br><span class="line">                    mark += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> mark == w.cget(<span class="string">&#x27;text&#x27;</span>):</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(a, b):</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(c, d):</span><br><span class="line">                    <span class="keyword">if</span> ([r, s] <span class="keyword">in</span> self.mark) == <span class="literal">False</span>:</span><br><span class="line">                        <span class="keyword">if</span> [r, s] <span class="keyword">in</span> self.mine:</span><br><span class="line">                            Button(self.root, text=<span class="string">&#x27;X&#x27;</span>, fg=<span class="string">&#x27;red&#x27;</span>, relief=SUNKEN).grid(row=r, column=s)</span><br><span class="line">                            self.state = <span class="string">&#x27;fail&#x27;</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">if</span> self.state != <span class="string">&#x27;win&#x27;</span>:</span><br><span class="line">                                self.sweptlist.append([r, s])</span><br><span class="line">                                self.count(r, s)</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">&#x27;fail&#x27;</span>:</span><br><span class="line">            self.fail()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">&#x27;begin&#x27;</span>:</span><br><span class="line">            self.timeused = i</span><br><span class="line">            self.timecount.<span class="built_in">set</span>(<span class="string">&#x27;%03d&#x27;</span> % self.timeused)</span><br><span class="line">            stdout.flush()</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">newgame = game()</span><br><span class="line">newgame.start()</span><br></pre></td></tr></table></figure><h2 id="企业员工信息管理系统的设计与实现"><a href="#企业员工信息管理系统的设计与实现" class="headerlink" title="企业员工信息管理系统的设计与实现"></a>企业员工信息管理系统的设计与实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">char</span> age[<span class="number">5</span>];<span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> worktime[<span class="number">5</span>];<span class="comment">//工龄</span></span><br><span class="line">    <span class="type">char</span> sex[<span class="number">5</span>];<span class="comment">//性别</span></span><br><span class="line">    <span class="type">char</span> grade[<span class="number">5</span>];<span class="comment">//级别</span></span><br><span class="line">    <span class="type">char</span> marrige[<span class="number">5</span>];<span class="comment">//婚姻状况</span></span><br><span class="line">    <span class="type">char</span> wage[<span class="number">10</span>];<span class="comment">//工资</span></span><br><span class="line">    <span class="type">char</span> tired[<span class="number">5</span>];<span class="comment">//是否在职</span></span><br><span class="line">&#125;work[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> n ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tz</span><span class="params">(<span class="type">char</span> a[],<span class="type">char</span> g[],<span class="type">char</span> w[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,q,e,o;</span><br><span class="line">    q=atoi(g);</span><br><span class="line">    e=atoi(a);</span><br><span class="line">    o=atoi(w);</span><br><span class="line">    <span class="keyword">switch</span>(q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:o=o+<span class="number">20</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:o=o+<span class="number">40</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:o=o+<span class="number">60</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:o=o+<span class="number">80</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:o=o+<span class="number">100</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;=<span class="number">65</span>) o=o+<span class="number">50</span>;</span><br><span class="line">    itoa(o,w,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件读写模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read</span><span class="params">()</span><span class="comment">//读入数据</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>( (fp = fopen(<span class="string">&quot;date.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请在D盘根目录下新建一个文本文件，文件名为date\n\n\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d\n&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n&quot;</span>,work[i].name,work[i].age,work[i].worktime,work[i].sex,work[i].grade,work[i].marrige,work[i].wage,work[i].tired);</span><br><span class="line">    i ++;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write</span><span class="params">()</span><span class="comment">//写入数据</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>( (fp = fopen(<span class="string">&quot;date.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n&quot;</span>,work[i].name,work[i].age,work[i].worktime,work[i].sex,work[i].grade,work[i].marrige,work[i].wage,work[i].tired);</span><br><span class="line">    i ++;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input</span><span class="params">()</span><span class="comment">// 从键盘输入</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">char</span> W;</span><br><span class="line">  <span class="type">int</span> flag;<span class="comment">//标记工号是否已存在</span></span><br><span class="line">  <span class="type">char</span> c;<span class="comment">//指令Y?N</span></span><br><span class="line">  read();<span class="comment">//输入数据前先将文件中原有的数据读入</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入职工的姓名:               \n\t\t&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,work[n].name);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(work[i].name,work[n].name) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;该工号已存在！\n\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\t\t是否继续输入?(Y/N): &quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%*c%c&quot;</span>,&amp;c);</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;N&#x27;</span> || c == <span class="string">&#x27;n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入职工的年龄:               \n\t\t&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,work[n].age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入职工的工龄:             \n\t\t&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,work[n].worktime);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入职工的性别:               \n\t\t&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,work[n].sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入职工的婚姻状况:               \n\t\t&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,work[n].marrige);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入职工的级别:               \n\t\t&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,work[n].grade);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入职工的工资:               \n\t\t&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,work[n].wage);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入职工的是否在职:               \n\t\t&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,work[n].tired);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t是否继续输入?(Y/N): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%*c%c&quot;</span>,&amp;c);</span><br><span class="line">    n ++;</span><br><span class="line">  &#125;<span class="keyword">while</span>( c != <span class="string">&#x27;N&#x27;</span> &amp;&amp; c != <span class="string">&#x27;n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  write();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n数据已保存！\n\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    tz(work[i].age,work[i].grade,work[i].wage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">output_inf</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t\t  姓名: %s\n&quot;</span>,work[id].name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t\t  年龄: %s\n&quot;</span>,work[id].age);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t\t  工龄: %s\n&quot;</span>,work[id].worktime);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t\t  性别: %s\n&quot;</span>,work[id].sex);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t\t  婚姻状况: %s\n&quot;</span>,work[id].marrige);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t\t  级别: %s\n&quot;</span>,work[id].grade);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t\t  工资: %s\n&quot;</span>,work[id].wage);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t\t  是否在职: %s\n&quot;</span>,work[id].tired);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span><span class="comment">//显示所有职工信息</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">  read();</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;无记录!\n\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      output_inf(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">statistics_age</span><span class="params">()</span><span class="comment">//按照年龄统计</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请选择统计方式：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1. 按照年龄上下限统计\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2. 按照年龄段统计\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">    <span class="keyword">switch</span> (choice)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> age_min, age_max;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入年龄下限：\n&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age_min);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入年龄上限：\n&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age_max);</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> age = atoi(work[i].age);</span><br><span class="line">                <span class="keyword">if</span> (age &gt;= age_min &amp;&amp; age &lt;= age_max)</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;年龄在%d到%d之间的员工有%d人\n&quot;</span>, age_min, age_max, count);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> age_range[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> age = atoi(work[i].age);</span><br><span class="line">                <span class="keyword">if</span> (age &lt; <span class="number">20</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    age_range[<span class="number">0</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">30</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    age_range[<span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">40</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    age_range[<span class="number">2</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">50</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    age_range[<span class="number">3</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">60</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    age_range[<span class="number">4</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    age_range[<span class="number">5</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;年龄在20岁以下的员工有%d人\n&quot;</span>, age_range[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;年龄在20岁到30岁之间的员工有%d人\n&quot;</span>, age_range[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;年龄在30岁到40岁之间的员工有%d人\n&quot;</span>, age_range[<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;年龄在40岁到50岁之间的员工有%d人\n&quot;</span>, age_range[<span class="number">3</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;年龄在50岁到60岁之间的员工有%d人\n&quot;</span>, age_range[<span class="number">4</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;年龄在60岁以上的员工有%d人\n&quot;</span>, age_range[<span class="number">5</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入有误！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">que</span><span class="params">()</span><span class="comment">//查询信息</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> num;</span><br><span class="line">  <span class="type">int</span> flag,i;</span><br><span class="line">  <span class="type">char</span> q_name[<span class="number">20</span>] ;<span class="comment">//查询姓名</span></span><br><span class="line">  <span class="type">char</span> q_worktime[<span class="number">20</span>] ;<span class="comment">//查询工龄</span></span><br><span class="line">  <span class="type">char</span> q_grade[<span class="number">20</span>] ; <span class="comment">//查询级别</span></span><br><span class="line">  <span class="type">char</span> c;<span class="comment">//指令Y?N</span></span><br><span class="line">  read();<span class="comment">//打开程序后，要查询以前的数据，要先读入</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t******************查询********************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       1.按姓名查询        *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       2.按工龄查询        *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       3.按级别查询        *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t******************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入指令(1-3):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%*c%c&quot;</span>,&amp;num);</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="string">&#x27;1&#x27;</span>||num&gt;<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;错误指令！\n\n&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    flag = <span class="number">0</span>;<span class="comment">//用来标记职工信息是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(num == <span class="string">&#x27;1&#x27;</span>)<span class="comment">//按工号查询</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入您要查询职工的姓名：&quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,q_name);</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ;i ++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>(work[i].name,q_name) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          output_inf(i);</span><br><span class="line">          flag = <span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="string">&#x27;2&#x27;</span>)<span class="comment">//按工龄查询</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入您要查询职工的工龄：&quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,q_worktime);</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ;i ++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>(work[i].worktime,q_worktime) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          output_inf(i);</span><br><span class="line">          flag = <span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="string">&#x27;3&#x27;</span>)<span class="comment">//按级别查询</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入您要查询职工的级别：&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,q_grade);</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ;i ++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>(work[i].grade,q_grade) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          output_inf(i);</span><br><span class="line">          flag = <span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)<span class="comment">//判断是否有该职工信息</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n\n无该职工信息!\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n是否继续查询(Y/N):&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%*c%c&quot;</span>,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;N&#x27;</span> || c == <span class="string">&#x27;n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改信息模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mod</span><span class="params">()</span><span class="comment">//修改职工信息</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> change_name[<span class="number">20</span>];<span class="comment">//需修改的职工的姓名</span></span><br><span class="line">  <span class="type">int</span> number;<span class="comment">//职工信息在数据中的位置</span></span><br><span class="line">  <span class="type">char</span> num;<span class="comment">//指令</span></span><br><span class="line">  <span class="type">char</span> message[<span class="number">100</span>];<span class="comment">//修改的信息</span></span><br><span class="line">  <span class="type">char</span> c;<span class="comment">//指令Y?N</span></span><br><span class="line">  <span class="type">int</span> W;</span><br><span class="line">  <span class="type">int</span> flag;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  read();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入需修改的职工的姓名：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,change_name);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(work[i].name,change_name) == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        number = i;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n\n无此员工信息！！\n\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n\n是否继续修改(Y/N):&quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%*c%c&quot;</span>,&amp;c);</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;N&#x27;</span> || c == <span class="string">&#x27;n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n\t\t******************修改********************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       1.修改姓名         *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       2.修改年龄         *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       3.修改工龄         *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       4.修改性别         *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       5.修改婚姻状况         *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       6.修改级别         *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       7.修改工资        *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*       8.修改是否在职         *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*                    *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t*    输入其他任意键退出本模块     *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t******************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入指令(1-8):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%*c%c&quot;</span>,&amp;num);</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="string">&#x27;1&#x27;</span> || num &gt; <span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;错误指令！\n\n&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入修改后的信息：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,message);</span><br><span class="line">    <span class="keyword">switch</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span> : <span class="built_in">strcpy</span>(work[number].name,message); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span> : <span class="built_in">strcpy</span>(work[number].age,message); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span> : <span class="built_in">strcpy</span>(work[number].worktime,message); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span> : <span class="built_in">strcpy</span>(work[number].sex,message); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span> : <span class="built_in">strcpy</span>(work[number].marrige,message); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span> : <span class="built_in">strcpy</span>(work[number].grade,message); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span> : <span class="built_in">strcpy</span>(work[number].wage,message); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span> : <span class="built_in">strcpy</span>(work[number].tired,message); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n是否继续修改(Y/N):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%*c%c&quot;</span>,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;N&#x27;</span> || c == <span class="string">&#x27;n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  write();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除信息模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">()</span><span class="comment">//删除职工信息</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> delete_name[<span class="number">20</span>];<span class="comment">//删除职工姓名</span></span><br><span class="line">  <span class="type">int</span> i,j;</span><br><span class="line">  <span class="type">int</span> flag;<span class="comment">//标记是否有该职工信息</span></span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  read();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入需删除职工信息的姓名：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,delete_name);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>( <span class="built_in">strcmp</span>(work[i].name,delete_name) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        n --;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = i ; j &lt; n ; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">          work[j] =work[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">&quot;\n\n无此员工信息！\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n\n删除成功！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n是否继续删除(Y/N):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%*c%c&quot;</span>,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;N&#x27;</span> || c == <span class="string">&#x27;n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  write();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">output_all</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    read();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;无记录!\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t  姓名: %s\n&quot;</span>,work[i].name);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t  年龄: %s\n&quot;</span>,work[i].age);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t  工龄: %s\n&quot;</span>,work[i].worktime);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t  性别: %s\n&quot;</span>,work[i].sex);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t  婚姻状况: %s\n&quot;</span>,work[i].marrige);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t  级别: %s\n&quot;</span>,work[i].grade);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t  工资: %s\n&quot;</span>,work[i].wage);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t  是否在职: %s\n&quot;</span>,work[i].tired);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> <span class="title">temp</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请选择排序方式：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1.按工龄排序\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2.按年龄排序\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3.按姓名排序\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">    <span class="keyword">switch</span>(choice)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(atoi(work[j].worktime)&gt;atoi(work[j+<span class="number">1</span>].worktime))</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=work[j];</span><br><span class="line">                        work[j]=work[j+<span class="number">1</span>];</span><br><span class="line">                        work[j+<span class="number">1</span>]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(atoi(work[j].age)&gt;atoi(work[j+<span class="number">1</span>].age))</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=work[j];</span><br><span class="line">                        work[j]=work[j+<span class="number">1</span>];</span><br><span class="line">                        work[j+<span class="number">1</span>]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(work[j].name,work[j+<span class="number">1</span>].name)&gt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=work[j];</span><br><span class="line">                        work[j]=work[j+<span class="number">1</span>];</span><br><span class="line">                        work[j+<span class="number">1</span>]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入有误！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序结果如下：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        output_inf(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span><span class="comment">//菜单</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************************************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                              *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                    欢迎使用本职工信息管理系统                *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*    1。创建职工信息                     2。查询职工信息       *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*    3。修改职工信息                     4。员工信息统计       *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*    5。删除职工信息                     6。输出所有员工信息              *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*    7。员工信息排序                     8。退出               *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                              *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                       请输入相应编号：                       *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*                                                              *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************************************************************\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t\t请输入指令(1-6): &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> kl0,kl1,jh;</span><br><span class="line">  kl0=<span class="number">147</span>;</span><br><span class="line">  <span class="keyword">for</span>(jh=<span class="number">0</span>;;jh++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入口令:  &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;kl1);</span><br><span class="line">  <span class="keyword">if</span>(kl1==kl0)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;你是合法用户！\n&quot;</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(jh&lt;<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;你是非法用户!&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  n = <span class="number">0</span>;</span><br><span class="line">  system(<span class="string">&quot;color 0B&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: input(); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: que(); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: mod();  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: statistics_age();  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>: del();  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>: output_all(); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>: sort();<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>: <span class="built_in">printf</span>(<span class="string">&quot;谢谢使用！\n\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">default</span> :<span class="built_in">printf</span>(<span class="string">&quot;\n---&gt;无效的指令!\n\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="音像图书信息管理系统"><a href="#音像图书信息管理系统" class="headerlink" title="音像图书信息管理系统"></a>音像图书信息管理系统</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 音像图书信息结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> number[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">    <span class="type">int</span> original_quantity;</span><br><span class="line">    <span class="type">int</span> remaining_quantity;</span><br><span class="line">&#125; AVItem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 租借者信息结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> number[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> borrow_date[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> deposit;</span><br><span class="line">    <span class="type">int</span> borrow_days;</span><br><span class="line">    <span class="type">float</span> rent;</span><br><span class="line">&#125; Borrower;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node *head;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建链表</span></span><br><span class="line">LinkedList* <span class="title function_">createLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkedList *<span class="built_in">list</span> = (LinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedList));</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向链表尾部添加节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">appendNode</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">void</span> *data)</span> &#123;</span><br><span class="line">    Node *newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *currentNode = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (currentNode-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据编号查找节点</span></span><br><span class="line">Node* <span class="title function_">findNodeByNumber</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">const</span> <span class="type">char</span> *number)</span> &#123;</span><br><span class="line">    Node *currentNode = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        AVItem *item = (AVItem*)currentNode-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(item-&gt;number, number) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentNode;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据编号删除节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNodeByNumber</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">const</span> <span class="type">char</span> *number)</span> &#123;</span><br><span class="line">    Node *previousNode = <span class="literal">NULL</span>;</span><br><span class="line">    Node *currentNode = <span class="built_in">list</span>-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        AVItem *item = (AVItem*)currentNode-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(item-&gt;number, number) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (previousNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">list</span>-&gt;head = currentNode-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                previousNode-&gt;next = currentNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(item);</span><br><span class="line">            <span class="built_in">free</span>(currentNode);</span><br><span class="line">            <span class="built_in">list</span>-&gt;length--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyLinkedList</span><span class="params">(LinkedList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    Node *currentNode = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node *tempNode = currentNode;</span><br><span class="line">        AVItem *item = (AVItem*)currentNode-&gt;data;</span><br><span class="line">        <span class="built_in">free</span>(item);</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tempNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示音像图书信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayAVItem</span><span class="params">(AVItem *item)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;编号：%s\n&quot;</span>, item-&gt;number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;名称：%s\n&quot;</span>, item-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原价：%.2f\n&quot;</span>, item-&gt;price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原数量：%d\n&quot;</span>, item-&gt;original_quantity);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;剩余数量：%d\n&quot;</span>, item-&gt;remaining_quantity);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示租借者信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayBorrower</span><span class="params">(Borrower *borrower)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;编号：%s\n&quot;</span>, borrower-&gt;number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;租借日期：%s\n&quot;</span>, borrower-&gt;borrow_date);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;押金：%.2f\n&quot;</span>, borrower-&gt;deposit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;租借天数：%d\n&quot;</span>, borrower-&gt;borrow_days);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;租金：%.2f\n&quot;</span>, borrower-&gt;rent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建音像图书</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createAVItem</span><span class="params">(LinkedList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    AVItem *item = (AVItem*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVItem));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入编号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, item-&gt;number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入名称：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, item-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入原价：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;item-&gt;price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入原数量：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;item-&gt;original_quantity);</span><br><span class="line">    item-&gt;remaining_quantity = item-&gt;original_quantity;</span><br><span class="line"></span><br><span class="line">    appendNode(<span class="built_in">list</span>, item);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;音像图书创建成功！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 租借音像图书</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">borrowAVItem</span><span class="params">(LinkedList *<span class="built_in">list</span>, LinkedList *borrowedList)</span> &#123;</span><br><span class="line">    <span class="type">char</span> number[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> borrow_date[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入音像图书编号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入租借日期：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, borrow_date);</span><br><span class="line"></span><br><span class="line">    Node *avNode = findNodeByNumber(<span class="built_in">list</span>, number);</span><br><span class="line">    <span class="keyword">if</span> (avNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无此音像图书！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVItem *item = (AVItem*)avNode-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (item-&gt;remaining_quantity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;此音像图书已全部借出！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Borrower *borrower = (Borrower*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Borrower));</span><br><span class="line">    <span class="built_in">strcpy</span>(borrower-&gt;number, item-&gt;number);</span><br><span class="line">    <span class="built_in">strcpy</span>(borrower-&gt;borrow_date, borrow_date);</span><br><span class="line">    borrower-&gt;deposit = item-&gt;price * <span class="number">3</span>;</span><br><span class="line">    borrower-&gt;borrow_days = <span class="number">0</span>;</span><br><span class="line">    borrower-&gt;rent = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    appendNode(borrowedList, borrower);</span><br><span class="line"></span><br><span class="line">    item-&gt;remaining_quantity--;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;应缴押金：%.2f\n&quot;</span>, borrower-&gt;deposit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;音像图书租借成功！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculateDays</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* date1, <span class="type">const</span> <span class="type">char</span>* date2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> year1, month1, day1;</span><br><span class="line">    <span class="type">int</span> year2, month2, day2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sscanf</span>(date1, <span class="string">&quot;%d-%d-%d&quot;</span>, &amp;year1, &amp;month1, &amp;day1);</span><br><span class="line">    <span class="built_in">sscanf</span>(date2, <span class="string">&quot;%d-%d-%d&quot;</span>, &amp;year2, &amp;month2, &amp;day2);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm1</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    tm1.tm_year = year1 - <span class="number">1900</span>;</span><br><span class="line">    tm1.tm_mon = month1 - <span class="number">1</span>;</span><br><span class="line">    tm1.tm_mday = day1;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm2</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    tm2.tm_year = year2 - <span class="number">1900</span>;</span><br><span class="line">    tm2.tm_mon = month2 - <span class="number">1</span>;</span><br><span class="line">    tm2.tm_mday = day2;</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> time1 = mktime(&amp;tm1);</span><br><span class="line">    <span class="type">time_t</span> time2 = mktime(&amp;tm2);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> diff = difftime(time2, time1);</span><br><span class="line">    <span class="type">int</span> days = (<span class="type">int</span>)(diff / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> days;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 归还音像图书</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">returnAVItem</span><span class="params">(LinkedList* <span class="built_in">list</span>, LinkedList* borrowedList)</span> &#123;</span><br><span class="line">    <span class="type">char</span> number[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> return_date[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入音像图书编号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入归还日期：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, return_date);</span><br><span class="line"></span><br><span class="line">    Node* borrowerNode = findNodeByNumber(borrowedList, number);</span><br><span class="line">    <span class="keyword">if</span> (borrowerNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无此租借者！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Borrower* borrower = (Borrower*)borrowerNode-&gt;data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;音像图书名称：%s\n&quot;</span>, borrower-&gt;number);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> rent_rate;</span><br><span class="line">    Node* avNode = findNodeByNumber(<span class="built_in">list</span>, number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无此音像图书！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVItem* item = (AVItem*)avNode-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(item-&gt;number, <span class="string">&quot;B&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        rent_rate = <span class="number">1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(item-&gt;number, <span class="string">&quot;V&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        rent_rate = <span class="number">2.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(item-&gt;number, <span class="string">&quot;R&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        rent_rate = <span class="number">3.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无此音像图书！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算租借天数</span></span><br><span class="line">    <span class="type">int</span> borrow_days = calculateDays(borrower-&gt;borrow_date, return_date);</span><br><span class="line"></span><br><span class="line">    borrower-&gt;borrow_days = borrow_days;</span><br><span class="line">    borrower-&gt;rent = borrow_days * rent_rate;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;租借天数：%d\n&quot;</span>, borrower-&gt;borrow_days);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;应退押金：%.2f\n&quot;</span>, borrower-&gt;deposit - borrower-&gt;rent);</span><br><span class="line"></span><br><span class="line">    item-&gt;remaining_quantity++;</span><br><span class="line"></span><br><span class="line">    deleteNodeByNumber(borrowedList, borrower-&gt;number);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;音像图书归还成功！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 购进音像图书</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">purchaseAVItem</span><span class="params">(LinkedList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> number[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> additional_quantity;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入音像图书编号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入增加数量：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;additional_quantity);</span><br><span class="line"></span><br><span class="line">    Node *avNode = findNodeByNumber(<span class="built_in">list</span>, number);</span><br><span class="line">    <span class="keyword">if</span> (avNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        AVItem *item = (AVItem*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVItem));</span><br><span class="line">        <span class="built_in">strcpy</span>(item-&gt;number, number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入名称：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, item-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入原价：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;item-&gt;price);</span><br><span class="line">        item-&gt;original_quantity = additional_quantity;</span><br><span class="line">        item-&gt;remaining_quantity = additional_quantity;</span><br><span class="line"></span><br><span class="line">        appendNode(<span class="built_in">list</span>, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AVItem *item = (AVItem*)avNode-&gt;data;</span><br><span class="line">        item-&gt;original_quantity += additional_quantity;</span><br><span class="line">        item-&gt;remaining_quantity += additional_quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;音像图书购进成功！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报废音像图书</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">scrapAVItem</span><span class="params">(LinkedList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> number[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> quantity;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入音像图书编号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入报废数量：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;quantity);</span><br><span class="line"></span><br><span class="line">    Node *avNode = findNodeByNumber(<span class="built_in">list</span>, number);</span><br><span class="line">    <span class="keyword">if</span> (avNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无此音像图书！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVItem *item = (AVItem*)avNode-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (item-&gt;original_quantity != item-&gt;remaining_quantity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已借出的音像图书不能报废！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item-&gt;original_quantity -= quantity;</span><br><span class="line">    item-&gt;remaining_quantity -= quantity;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;音像图书报废成功！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkedList *avList = createLinkedList();</span><br><span class="line">    LinkedList *borrowedList = createLinkedList();</span><br><span class="line">    <span class="type">int</span> option;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|----------------------------|\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|请输入选项编号(0－－5):     |\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|----------------------------|\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;| 1---创建音像图书           |\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;| 2---租借音像图书           |\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;| 3---归还音像图书           |\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;| 4---购进音像图书           |\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;| 5---报废音像图书           |\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;| 0---退出系统               |\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|----------------------------|\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;option);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                createAVItem(avList);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                borrowAVItem(avList, borrowedList);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                returnAVItem(avList, borrowedList);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                purchaseAVItem(avList);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                scrapAVItem(avList);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                destroyLinkedList(avList);</span><br><span class="line">                destroyLinkedList(borrowedList);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;无效的选项！\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用链表构建学生信息库"><a href="#用链表构建学生信息库" class="headerlink" title="用链表构建学生信息库"></a>用链表构建学生信息库</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> stud_node *<span class="title function_">Create_Stu_Doc</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">struct</span> stud_node *<span class="title function_">InsertDoc</span><span class="params">(<span class="keyword">struct</span> stud_node *head, <span class="keyword">struct</span> stud_node *stud)</span>;</span><br><span class="line"><span class="keyword">struct</span> stud_node *<span class="title function_">DeleteDco</span><span class="params">(<span class="keyword">struct</span> stud_node *head, <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print_Stu_Doc</span><span class="params">(<span class="keyword">struct</span> stud_node *head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stud_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stud_node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stud_node</span> *<span class="title">head</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> choice, num, score;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stud_node);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1:Create 2:Insert 3:Delete 4:Print 0:Exit \n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">        <span class="keyword">switch</span>(choice) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">              head= Create_Stu_Doc();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;Input num,name and score\n&quot;</span>);</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d&quot;</span>, &amp;num, name, &amp;score);</span><br><span class="line">              p = (<span class="keyword">struct</span> stud_node *)<span class="built_in">malloc</span>(size);</span><br><span class="line">              p-&gt;num = num;</span><br><span class="line">              <span class="built_in">strcpy</span>(p-&gt;name, name);</span><br><span class="line">              p-&gt;score = score;</span><br><span class="line">              head = InsertDoc(head, p);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;Input num:\n&quot;</span>);</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">              head = DeleteDco(head, num);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">              Print_Stu_Doc(head);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (choice != <span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*新建链表*/</span></span><br><span class="line"><span class="keyword">struct</span> stud_node *<span class="title function_">Create_Stu_Doc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num, score;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stud_node</span> *<span class="title">head</span>,*<span class="title">p</span>;</span></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input num,name and score:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d&quot;</span>, &amp;num, name, &amp;score);</span><br><span class="line">    <span class="keyword">while</span>(num!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> stud_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stud_node));</span><br><span class="line">        p-&gt;num = num;</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;name, name);</span><br><span class="line">        p-&gt;score = score;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        head = InsertDoc(head, p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input num,name and score:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d&quot;</span>, &amp;num, name, &amp;score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*插入操作*/</span></span><br><span class="line"><span class="keyword">struct</span> stud_node *<span class="title function_">InsertDoc</span><span class="params">(<span class="keyword">struct</span> stud_node *head, <span class="keyword">struct</span> stud_node *stud)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stud_node</span> *<span class="title">ptr</span>, *<span class="title">ptr1</span>, *<span class="title">ptr2</span>;</span></span><br><span class="line">    ptr2 = head;</span><br><span class="line">    ptr = stud;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = ptr;</span><br><span class="line">        head-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((ptr-&gt;num&gt;ptr2-&gt;num)&amp;&amp;(ptr2-&gt;next!=<span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">              ptr1 = ptr2;</span><br><span class="line">              ptr2 = ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;num&lt;=ptr2-&gt;num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head==ptr2)</span><br><span class="line">                head = ptr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ptr1-&gt;next = ptr;</span><br><span class="line">                ptr-&gt;next = ptr2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptr2-&gt;next = ptr;</span><br><span class="line">            ptr-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*删除操作*/</span></span><br><span class="line"><span class="keyword">struct</span> stud_node *<span class="title function_">DeleteDco</span><span class="params">(<span class="keyword">struct</span> stud_node *head,<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stud_node</span> *<span class="title">ptr1</span>, *<span class="title">ptr2</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">NULL</span>&amp;&amp;head-&gt;num==num)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr2 = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(ptr2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr1 = head;</span><br><span class="line">    ptr2 = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(ptr2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr2-&gt;num==num)&#123;</span><br><span class="line">            ptr1-&gt;next = ptr2-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(ptr2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ptr1 = ptr2;</span><br><span class="line">            ptr2 = ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*遍历操作*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print_Stu_Doc</span><span class="params">(<span class="keyword">struct</span> stud_node *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stud_node</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNo Records&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe Students Records Are:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num\t Name\t Score\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (ptr = head; ptr!= <span class="literal">NULL</span>; ptr = ptr-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t%s\t%d\n&quot;</span>, ptr-&gt;num, ptr-&gt;name, ptr-&gt;score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment"> *@title LED system</span></span><br><span class="line"><span class="comment"> *@brief flight light</span></span><br><span class="line"><span class="comment"> *@brief </span></span><br><span class="line"><span class="comment"> *@time  2016.10.19</span></span><br><span class="line"><span class="comment"> *@editor小南&amp;zin</span></span><br><span class="line"><span class="comment"> *飞控爱好QQ群551883670,邮箱759421287@qq.com</span></span><br><span class="line"><span class="comment"> ******************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ALL_DATA.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="comment">//机身前灯 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fLED_H()  GPIOB-&gt;BRR = GPIO_Pin_0|GPIO_Pin_1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fLED_L()  GPIOB-&gt;BSRR = GPIO_Pin_0|GPIO_Pin_1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fLED_Toggle()  GPIOB-&gt;ODR ^= GPIO_Pin_0|GPIO_Pin_1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fLED_H1()  GPIOB-&gt;BRR = GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fLED_H2()  GPIOB-&gt;BRR = GPIO_Pin_1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fLED_L1()  GPIOB-&gt;BSRR = GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fLED_L2()  GPIOB-&gt;BSRR = GPIO_Pin_1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">//机身后灯 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bLED_H()  GPIOA-&gt;BRR = GPIO_Pin_6|GPIO_Pin_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bLED_L()  GPIOA-&gt;BSRR  = GPIO_Pin_6|GPIO_Pin_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bLED_Toggle()  GPIOA-&gt;ODR ^= GPIO_Pin_6|GPIO_Pin_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bLED_H1()  GPIOA-&gt;BRR = GPIO_Pin_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bLED_H2()  GPIOA-&gt;BRR = GPIO_Pin_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bLED_L1()  GPIOA-&gt;BSRR  = GPIO_Pin_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bLED_L2()  GPIOA-&gt;BSRR  = GPIO_Pin_7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------</span></span><br><span class="line"><span class="comment">/*     you can select the LED statue on enum contains            */</span></span><br><span class="line">sLED LED = &#123;<span class="number">100</span>,AllFlashLight&#125;;  <span class="comment">//LED initial statue is off;</span></span><br><span class="line">                             <span class="comment">//default 300ms flash the status</span></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment"> *  LED Init</span></span><br><span class="line"><span class="comment"> * @param[in] </span></span><br><span class="line"><span class="comment"> * @param[out] </span></span><br><span class="line"><span class="comment"> * @return     </span></span><br><span class="line"><span class="comment"> ***************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LEDInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOA , ENABLE);</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;   </span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;     </span><br><span class="line">  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">fLED_L();<span class="comment">//暗</span></span><br><span class="line">bLED_L();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment"> *  LED system</span></span><br><span class="line"><span class="comment"> * @param[in] </span></span><br><span class="line"><span class="comment"> * @param[out] </span></span><br><span class="line"><span class="comment"> * @return     </span></span><br><span class="line"><span class="comment"> ***************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PilotLED</span><span class="params">()</span> <span class="comment">//flash 300MS interval</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> LastTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SysTick_count - LastTime &lt; LED.FlashTime)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LastTime = SysTick_count;</span><br><span class="line"><span class="keyword">switch</span>(LED.status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> AlwaysOff:      <span class="comment">//常暗   </span></span><br><span class="line">bLED_L();</span><br><span class="line">fLED_L();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AllFlashLight:  <span class="comment">//全部同时闪烁</span></span><br><span class="line">fLED_H1();</span><br><span class="line">fLED_L1();</span><br><span class="line">delay_ms(<span class="number">1000</span>);</span><br><span class="line">bLED_H1();</span><br><span class="line">bLED_L1();</span><br><span class="line">delay_ms(<span class="number">1000</span>);</span><br><span class="line">bLED_H2();</span><br><span class="line">bLED_L2();</span><br><span class="line">delay_ms(<span class="number">1000</span>);</span><br><span class="line">fLED_H2();</span><br><span class="line">fLED_L2();</span><br><span class="line">delay_ms(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AlwaysOn:  <span class="comment">//常亮</span></span><br><span class="line">bLED_H();</span><br><span class="line">fLED_H();</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AlternateFlash: <span class="comment">//交替闪烁</span></span><br><span class="line">bLED_H();</span><br><span class="line">fLED_L();</span><br><span class="line">LED.status = AllFlashLight;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WARNING:</span><br><span class="line">fLED_L();</span><br><span class="line">bLED_Toggle();</span><br><span class="line">LED.FlashTime = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DANGEROURS:</span><br><span class="line">bLED_L();</span><br><span class="line">fLED_Toggle();</span><br><span class="line">LED.FlashTime = <span class="number">70</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">LED.status = AlwaysOff;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************END OF FILE*********************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序代码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode总结</title>
      <link href="/2023/02/19/%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/02/19/%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Leetcode总结"><a href="#Leetcode总结" class="headerlink" title="Leetcode总结"></a>Leetcode总结</h2><p>&#x2F;&#x2F; Leetcode总结 </p><span class='p red'>1.</span>if-else if应当这样写<p>if (*s &#x3D;&#x3D; ‘V’)         sum +&#x3D; 5;<br>else if (*s &#x3D;&#x3D; ‘L’)    sum +&#x3D; 50</p><span class='p red'>2.</span>执行代码是检查语法错误，提交是检查算法错误,<p> 1.执行出错是有语法错误<br>  (1)可能是漏掉了了一个单词<br>  (2)也可以是少打了一个,就是没有检查出来<br> 2.给你指出错误来了,一定是自己搞错了,反向思考一下,适当修改一下<br> 3.考试的时候只能自己一个一个的检查出哪里有问题,不要怀疑自己的算法,不要考虑换算法,肯定是自己哪里错了,因为自己的语法知识并没有完全掌握,甚至&amp;&amp;会搞错成||<br> 4.有调试就调试,没有调试就写下一题,然后重新写</p><span class='p red'>3.</span>C语言语法基本没有问题，C++可能有语法错误<span class='p red'>4.</span>自己有代码错误可以用Chatgpt,不懂用Chatgpt,同时注意它的使用技巧,它会记住你之前对它问过的问题来重新会答你,还要结合Bing来写,首先使用chargpt<span class='p red'>5.</span>注意多使用while()在没有a[], a>b?a:b的使用，输入一个值n,有一个长度为a数组，<p>输出长度为n的新数组,n可能大于a,可能小于a,选择b&#x3D;a&lt;n:a,b<br>即遇到if时可以使用?条件语句<br>for (int i &#x3D; 0; i &lt; numsSize; i++)<br>  int limit &#x3D; i+k &gt;&#x3D; numsSize? numsSize: i+k+1;<br>放在for循环中有满足某个条件时一直等于munsSize</p><span class='p red'>6.</span>注意严谨的思维,在读完题以后,回想一下要完成的内容是什么,然后对比题目看遗漏了什么没有<span class='p red'>7.</span>删除有序数组中的重复项<p>设置两个指针分别为快指针和慢指针s[a],s[b],比起一个i的s[i]更好控制,先让两个指针指向同一个位置<br>让后面的值先出现,使用！&#x3D;,它的目的是空出空位来,在原数组中重新存放元素,而不设置新数组,nums[j]!&#x3D;nums[j-1]找出不是重复的元素,nums[i]用来存放<br>双指针的好处是可以记忆元素和直接对数组操作不需要重新创建新的数组</p><span class='p red'>8.</span>示例是对if语句的形式的提示<span class='p red'>9.</span>二分查找法是在数组中找到与指定目标值相同的下标,但必须是有序数组<span class='p red'>10.</span>一般对字符串的处理函数是可以用的在leetcode<p>11.在leetcode用到的算法<br>二分查找法 是在数组中用较少的时间找到要找的数(搜索插入位置),有搜索二字就代表了要二分查找,并且找到下标, while(i&lt;&#x3D;j)必修等于防止target在最后一个找到<br>两个指针分别为快指针和慢指针或者更多的指针,指针可以是从数组的第二个元素开始,但一般是从第一个元素开始<br>两个for循环实现后面的数组元素前移并覆盖一个数组元素<br>C中的算法<br>while()<br>二进制进位法<br>累加和sum</p><p>12.在一个函数中返回一个字符数组的地址,并且需要在该函数中建立一个数组,需使用动态分配,并且不需要free(),注意动态分配的是数组</p><ol start="13"><li>nums1[j–]&#x3D;nums2[j–]这个代表的是赋值以后要减一 j–</li></ol><p>14.c语言注意&amp;&amp; || 的综合运用<br> 1.if((flowerbed[i]&#x3D;&#x3D;0) &amp;&amp; (i&#x3D;&#x3D;0 || flowerbed[i-1]&#x3D;&#x3D;0) &amp;&amp; (i&#x3D;&#x3D;flowerbedSize-1 || flowerbed[i+1]&#x3D;&#x3D;0));<br> 与山顶元素一样的在特殊位置与一般位置的分析情况少一点,都是一排过去(||)中有一个是为真的,但要把特殊情况放在里面</p><p>15.在一个简单的题目中也要分步骤进行思考例如<br> 1.先排序<br> 2.再找出第三大的数</p><ol start="16"><li>for(i &#x3D; 0; i &lt; nums1Size; i++)      &#x2F;&#x2F;遍历数组1，记录出现的元素<br>{<br>count[nums1[i] &#x3D; 1;            &#x2F;&#x2F;这里置1，而不++，以便后面操作<br>}<br>这样count[]会把nums1中出现过的数字记录下来,并且还会记录下重复出现的次数，可作用于重复的数字</li></ol><p>17.int* returnSize中returnSize是指针,但也是这样用的 ret[(*returnSize)] &#x3D; nums2[i]; *returnSize++;</p><p>18.快速排序<br>函数声明<br>int Cmp_int(const void* p1, const void* p2)     是一个自定义的比较函数<br>{<br>    return (<em>(int</em>)p1 - <em>(int</em>)p2);<br>}<br>注意快速排序是对无序的数组进行的,对从小到大还是从大到小都是无操作的</p><p>qsort(nums1, nums1Size, sizeof(int), Cmp_int);</p><p>19.int* returnSize,作为参数<br>1.传递过来时对它取值增时要注意(*returnSize)++,而不是这样的 <em>returnSize++<br>2.对它赋值时同时也应该注意是</em>returnSize&#x3D;0,而不是int *returnSize&#x3D;0<br>3.看到它要记住对它的处理,但不返回它的值,我们是通过地址来改变它在主函数里的值</p><p>20.选择排序<br>int temp<br>for(k&#x3D;0;k&lt;numsSize-1;k++){<br>        index&#x3D;k;<br>        for(i&#x3D;k+1;i&lt;numsSize;i++){<br>            if(a[i]&lt;a[index]){<br>                index&#x3D;i;<br>            }<br>        }<br>        temp&#x3D;a[index];<br>        a[index]&#x3D;a[k];<br>        a[k]&#x3D;temp;<br>   }<br>要使用下标来表示最小值,而不是一个值,还有就是在交换时不是使用i,其实i要比index大</p><p>21.在内部创建的字符串数组结束以后记得加上a[i]&#x3D;’\0’,如果不返回这还要释放它， char* ch&#x3D;(char*)malloc(size+1)，free()</p><ol start="22"><li>for(i&#x3D;0;i&lt;size;i++){<br>if((s[i]&gt;&#x3D;’a’&amp;&amp;s[i]&lt;&#x3D;’z’)||(s[i]&gt;&#x3D;’0’&amp;&amp;s[i]&lt;&#x3D;’9’)){<br>ch[j]&#x3D;s[i];<br>j++;<br>}else if(s[i]&gt;&#x3D;’A’&amp;&amp;s[i]&lt;&#x3D;’Z’){<br>ch[j]&#x3D;s[i]-‘A’+’a’;<br>j++;<br>}<br>}<br>j++以后是要比当前大一些的加1后并没有使用,所以在后面的使用要减1</li></ol><p>23.char a[0]&#x3D;’&#x2F;0’表示空字符串,strs[0][0]&#x3D;’\0’,return strs[0]表示返回空字符串,使用’\0’,直接截断了字符串的长度<br>    1.1 &lt;&#x3D; strs.length &lt;&#x3D; 200表示二维字符串strs &#x3D; [“flower”,”flow”,”flight”],”flower”的长度<br>    2.0 &lt;&#x3D; strs[i].length &lt;&#x3D; 200表示[“flower”,”flow”,”flight”]的长度</p><p>24.while(flag){<br>        for(j&#x3D;1;j&lt;strsSize;j++){<br>            if(strs[j][i]!&#x3D;flag) break;<br>        }<br>        if(j&lt;strsSize) break;<br>        flag&#x3D;strs[0][++i];<br>    }<br>两次break跳出循环</p><ol start="25"><li>char <em>c&#x3D;(char</em>)malloc(sizeof(char)*length);<br>c[length-1]&#x3D;’\0’;<br>在字符串动态内存分配以后,要立马给它a[size-1]&#x3D;’&#x2F;0’</li></ol><p>26.if(*src&#x3D;&#x3D;’\0’)<br>    return NULL;<br>有src[0]&#x3D;’\0’可以返回NULL空字符</p><p>27.三数之和<br>输出的顺序和三元组的顺序并不重要,一般要涉及到排序来解决,如果是和下标有关系的话就不能排序</p><p>28.三数之和<br>1.for(j&#x3D;i+1;k&lt;numsSize-1;j&lt;k;){j++;k++}两个指针相向运动for写的情况,只有排好序,为了才好逐个遍历,消重也可以用来控制有重复出现要输出时,输出第一种的情况,省略了++的情况<br>2.三个指针使用分布的情况,注意continue的使用用来跳过当前循环<br>3.for(i&#x3D;0;i&lt;(numsSize-2);i++){<br>    if((nums[i]+nums[i+1]+nums[i+2])&gt;0) break;<br>能够提升算法的效率,在该题中还用了除去相同的结果<br>29.二维数组的动态内存分配<br> 1.整个二维数组int **res&#x3D;(int **)malloc(sizeof(int *) * (numsSize + 1) * 6);<br> 2.对行指针的分配 res[<em>returnSize]&#x3D;(int</em>)malloc(sizeof(int)<em>3);<br> 3.对列指针的分配 <em>returnColumnSizes&#x3D;(int</em>)malloc(sizeof(int)</em>(*returnSize));<br> 4.申请内存，此时不确定合并之后的数组大小，只能按照intervalSize进行申请<br>   int **target &#x3D; (int **)malloc(sizeof(int *)*intervalsSize);<br>   <em>returnColumnSizes &#x3D; (int <em>)malloc(sizeof(int) * intervalsSize);<br> 4.int</em></em> threeSum() return a返回的是一级指针</p><p>30.自己创建一个数组来记录前面出现过的重复的数,主要是前面与后面比较<br>最长子串的题都是用双指针来移动</p><p>31.字符串转换整数<br>看似只遍历了字符串的第一字符,但实则遍历了很多字符<br> 1.while(*str &#x3D;&#x3D; ‘ ‘)&#x2F;&#x2F;删除空格<br>        ++str;<br> 对空格多次遍历<br> 2.if(*str &#x3D;&#x3D; ‘-‘){<br>        flag &#x3D; -1;<br>        ++str;<br> 对’-‘遍历了一次<br> 3.while(<em>str&gt;&#x3D;’0’ &amp;&amp; <em>str&lt;&#x3D;’9’){<br>        temp &#x3D; <em>str-‘0’;<br>        if(res&lt;div || (res&#x3D;&#x3D;div&amp;&amp;temp&lt;8)){<br>            res &#x3D; res</em>10 + temp;<br>            ++str;<br>        }<br>        else<br>            return (flag&#x3D;&#x3D;1?INT_MAX:INT_MIN);<br>    }<br>    return res</em>flag;<br> 对数字遍历了多次<br> 4.return res</em>flag;<br> 并且遇到英文字符时就结束<br> 5.int div &#x3D; INT_MAX&#x2F;10;<br>   temp &#x3D; *str-‘0’;<br>   if(res&lt;div||(res&#x3D;&#x3D;div&amp;&amp;temp&lt;8))<br> 确保不会超出整数的范围</p><p>32.如何将找到的元素存放到数组中</p><p>33.在找出字符串中第一个匹配项的下标中<br> 1.for(i&#x3D;0;i&lt;strlen(haystack);i++){<br>        if(i+strlen(needle)&gt;strlen(haystack)){<br> 也是用来提升效率的<br> 2.for(i&#x3D;0;i&lt;strlen(haystack);i++){<br>        if(i+strlen(needle)&gt;strlen(haystack)){<br>            break;<br>        }<br>        for(j&#x3D;0;j&lt;strlen(needle);j++){<br>            if(haystack[i+j]!&#x3D;needle[j]){<br>                break;<br>            }<br>            if(j&#x3D;&#x3D;strlen(needle)-1){<br>                return i;<br>            }<br>        }<br>    }<br> 使得能找准对的下标位置来比较</p><p>34 1.reverse函数来对字符串反转,直接使用库函数<br>   2.split函数,就给它拆成一个个独立的单词了<br>   3.erase函数就能在字符串里删除字符   </p><p>35.空间复杂度是o(1)的不能去申请一个新的字符串,做字符串的一般都有申请新的字符串,移除数组,移除多余空格都需要双指针来操作,并且是原地移除</p><p>36.1 &lt;&#x3D; num &lt;&#x3D; 3999<br>char* result &#x3D; (char*)malloc(sizeof(char) * 20)有时候是要自己计算来分配多少内存的</p><ol start="37"><li>memcpy(result + strIndex, rom[numIndex], strlen(rom[numIndex]));将字符串放到字符数组中的函数</li></ol><p>38.char* result &#x3D; (char*)malloc(sizeof(char) * 20)<br>*(result + strIndex) &#x3D; ‘\0’;在申请内存中最后还不知道为多少时,要在后面加上’\0’</p><ol start="39"><li>在排序数组中查找元素的第一个和最后一个位置   记得有查找二字一定用二分查找法</li></ol><p>40.在i进行了一次for循环后,注意i的值要比原先大<br> for(j&#x3D;0;j&lt;len;j++){</p><pre><code>    if(s[j]==&#39; &#39;)&#123;        if(flag==0&amp;&amp;i!=0)&#123;            s[i++]=&#39; &#39;;            flag=1;        &#125;    &#125;else&#123;        s[i++]=s[j];        flag=0;    &#125;    &#125;if(i&gt;=1&amp;&amp;s[i-1]==&#39; &#39;)&#123;    s[i-1]=&#39;\0&#39;;</code></pre><p>41.移除元素的本质是利用双指针来覆盖不要的元素</p><p>42.将字符串反转时必需有i&lt; j不能i&lt;&#x3D;j,不然会进入死循环<br> &#x2F;&#x2F;将整个字符串反转<br>    len&#x3D;strlen(s);<br>    i&#x3D;0,j&#x3D;len-1;<br>    while(i&lt;j){<br>        char temp&#x3D;s[i];<br>        s[i++]&#x3D;s[j];<br>        s[j–]&#x3D;temp; </p><p>43.使用了二维数组的动态内存分配的题目有<br>三数之和<br>合并区间</p><p>44.交换数组中元素可以使用直接赋值<br> if(nums[i] &#x3D;&#x3D; 0){<br>            nums[i] &#x3D; nums[j];<br>            nums[j++] &#x3D; 0;</p><p>45.在for循环中i–是重新查看该位置的元素<br> for(i&#x3D;0;i&lt;&#x3D;k;i++){<br>    i–;</p><p>46.哈希法<br>哈希表的数据结构有三种   数组 set map<br>1.在哈希值比较小的情况下,而且范围也比较小,长度可控,用数组  1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 1000   0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000 就是自定义一个数组不是动态内存分配<br>2.如果数值很大的话,我们就用set     值是二的次方  unorderset其实它就是一个可以无限存装的一个数组,可以去重,做映射和取值的效率是很高的,在unorderset result中放入100个2最终也会存入一个2<br>3.如果这个k对应的value的话,我们就用map<br>4.哈希表最擅长的是解决就是给你一个元素,判断在这个集合里是否出现过</p><p>47.既可以对数字数组做计数也可以对字符串数组做计数<br>for(i&#x3D;0;i&lt;lens;i++){<br>        flags[s[i]-‘a’]++;<br>    }<br>记录的是字符串的差值而不是ASCLL码值<br>如果数字数组的值太大就不好计数了</p><p>48.在不需要返回自己创建的数组的时候可以直接定义数组<br> int flags[26]&#x3D;0;<br> int flagt[26]&#x3D;0;</p><p>49.有这种关键词就要想到二分查找法<br>1.在数组中找到目标值<br>2.搜索<br>3.在连续的数组中查找<br>4.在不连续的但是有排序得到数组中查找<br>5.int mid &#x3D; left + (right - left) &#x2F; 2;这个也是找到中间值的方法,并且能缩小时间复杂度  int mid &#x3D; (l + r) &gt;&gt; 1也可以找到中间值<br>6. if(mid*mid&lt;&#x3D;x){<br>           a&#x3D;mid;<br>           left&#x3D;mid+1;<br>重复赋值获得比mid小的最大数<br>7.二分查找的本质是二段性，二分查找的过程本质是对可行区间的压缩。<br>8.中等题的二分查找法都不满足有序不重复的数组,有序重复的数组是可以用二分查找法</p><p>50.long long mid;<br>0 &lt;&#x3D; x &lt;&#x3D; 2的31次方 - 1<br>mid*mid&lt;&#x3D;x<br>可以防止整数的溢出long long</p><ul><li>&#x2F; + - 要考虑发生有溢出<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104 还是很小的</li></ul><p>51.模拟一个旋转圆,把螺旋矩阵的过程模拟出来了</p><p>52.滑动窗口的最重要的一个思路<br>1.是用了一个for循环来做两个for循环的事情<br>2.如何移动起始位置<br>3.动态的去调整我们的起始位置<br>4.i表示起始位置,j表示终止位置<br>5.用于求解子数组的问题<br>6.两个指针却包括了很大的空间</p><p>53.前缀和是某个数的前面的元素</p><p>54.有时候还得想一些暴力解法比如两个元素进行比较看是否有重复的元素出现,并且if语句中使用&amp;&amp;可解决问题<br>for (int k &#x3D; 0; k &lt; *boardColSize; k++)<br>                {<br>                    if (j !&#x3D; k &amp;&amp; board[i][j] &#x3D;&#x3D; board[i][k])<br>                        return false;<br>                }</p><p>55.二维数组中是这样用列数的,最好使用数组的方式来表示元素,但长度使用的是指针表示的<br>for(int i&#x3D;0;i&lt;boardSize;i++){<br>    for(int j&#x3D;0;j&lt;*boardcloSize;j++){</p><pre><code>    &#125;</code></pre><p>}<br>2.int size &#x3D; matrixSize*(*matrixColSize);二维矩阵的长度是这样计算的<br>3.int rows &#x3D; matrixSize, columns &#x3D; matrixColSize[0];列的长度也可以这样表示<br>4.螺旋矩阵要保持好循环不变量<br>5.二维数组中一定要用双重for循环</p><p>56.用于把二维数组分块并进行遍历每一个子块的方法<br>&#x2F;&#x2F;查找每个子块<br>                int x &#x3D; i &#x2F; 3 * 3;&#x2F;&#x2F;每个字块中的x开端<br>                int y &#x3D; j &#x2F; 3 * 3;<br>for (int m &#x3D; 0; m &lt; 3; m++)<br>                {<br>                    for (int n &#x3D; 0; n &lt; 3; n++)<br>                    {<br>                        if (x + m !&#x3D; i &amp;&amp; y + n !&#x3D; j &amp;&amp; board[x + m][y + n] &#x3D;&#x3D; board[i][j])&#x2F;&#x2F;**<br>                            return false;<br>                    }<br>                }</p><p>57.一维数组的下标转换成二维数组的下标<br>a为一位数组的下标,n为列的长度<br>int x &#x3D; matrix[a &#x2F; n][a % n];</p><p>58.int* runningSum(int* nums, int numsSize, int* returnSize){<br>    int *runningSum&#x3D;(int *)malloc(sizeof(int)*numsSize);<br>    runningSum[0]&#x3D;nums[0];<br>    for(int i&#x3D;1;i&lt;numsSize;i++){<br>        runningSum[i]&#x3D;nums[i]+runningSum[i-1];<br>    }<br>    *returnSize&#x3D;numsSize;<br>    return runningSum;<br>}<br>是一个指针值函数,但返回的却是指针地址</p><p>59.为了在 O(1) 的时间内得到每个子数组的和，可以使用前缀和</p><p>60.for(int j&#x3D;i+1,k&#x3D;numsSize-1;j&lt;k) 两个指针相向运动结束的判断条件</p><p>61res[*returnSize][0]&#x3D;nums[i];<br>                res[*returnSize][1]&#x3D;nums[j];<br>                res[*returnSize][2]&#x3D;nums[k];<br>                (*returnSize)++;<br>这是一种往二维数组存放元素的方式</p><p>61.s&#x3D;nums[0]+nums[1]+nums[2]-target用来得到与目标值最接近的元素<br>m&#x3D;abs(k);n&#x3D;abs(s)用来取绝对值的函数</p><p>62.对矩阵的快速排序<br>int cmp(const void* a, const void* b){<br>    int* aa &#x3D; <em>(int</em><em>)a;<br>    int</em> bb &#x3D; <em>(int</em><em>)b;<br>    return aa[0] - bb[0];<br>}<br>qsort(intervals, intervalsSize, sizeof(int</em>), cmp);</p><ol start="62"><li>int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){<br> <em>returnColumnSizes &#x3D; malloc(sizeof(int) * intervalsSize);<br> int</em>* res &#x3D; malloc(sizeof(int*) * intervalsSize);<br> 赋值给二维数组时注意点,2表示列的长度<br> (*returnColumnSizes)[(*returnSize)] &#x3D; 2;<br> res[(*returnSize)] &#x3D; malloc(sizeof(int) * 2);<br> res[(*returnSize)][0] &#x3D; left;<br> res[(*returnSize)][1] &#x3D; right;<br> (*returnSize)++;<br>}</li></ol><p>63.字符串题要看由什么字符组成<br>s 由英文字母、数字、符号和空格组成</p><p>64.新建一个数组用来记录出现的元素,并且可以发现重复出现的个数</p><p>65.无重复字符的最长子串<br>左指针移动是因为右指针找到了重复的元素</p><p>66.for循环必须这样写<br>for (; i &lt; maxlen; i++)<br>        {<br>            arr[i] &#x3D; s[start++];<br>        }</p><p>67.负数总是用flag&#x3D;-1与乘法来表示的return res*flag;</p><p>68.div&#x3D;INT_MAX是整数的最大值的取法</p><p>&#x2F;**</p><ul><li>Note: The returned array must be malloced, assume caller calls free().<br> <em>&#x2F;<br>int</em> rowAndMaximumOnes(int** mat, int matSize, int* matColSize, int* returnSize){<br> int col &#x3D; matColSize[0];<br> int row &#x3D; matSize;<br> int cnt &#x3D; 0;<br> int maxNum &#x3D; 0;<br> int index &#x3D; 0;<br> int *res &#x3D; (int *)malloc(sizeof(int) * 2);<br> memset(res, 0, sizeof(int) * 2);<br> for (int i &#x3D; 0; i &lt; row; i++) {<br> for (int j &#x3D; 0; j &lt; col; j++) {<br>     if (mat[i][j] &#x3D;&#x3D; 1) {<br>         cnt++;<br>     }<br> }<br> if (maxNum &lt; cnt) {<br>     index &#x3D; i;<br> }<br> maxNum &#x3D; fmax(maxNum, cnt);<br> cnt &#x3D; 0;<br> }<br> *returnSize &#x3D; 2;<br> res[0] &#x3D; index;<br> res[1] &#x3D; maxNum;<br> return res;<br>}</li></ul><p>int maxDivScore(int* nums, int numsSize, int* divisors, int divisorsSize){<br>    int max &#x3D; 0;<br>    int max1 &#x3D; 0;<br>    for(int k &#x3D; 0; k &lt; divisorsSize; k++){<br>        for(int m &#x3D; k + 1; m &lt; divisorsSize; m++){<br>            if(divisors[k] &gt; divisors[m]){<br>                int temp &#x3D; divisors[m];<br>                divisors[m] &#x3D; divisors[k];<br>                divisors[k] &#x3D; temp;<br>            }<br>        }<br>    }<br>    for(int i &#x3D; 0; i &lt; divisorsSize; i++){<br>        int temp &#x3D; 0;<br>        for(int j &#x3D; 0; j &lt; numsSize; j++){<br>            if(nums[j] % divisors[i] &#x3D;&#x3D; 0)<br>                temp++;</p><pre><code>    &#125;    if(temp &gt; max)&#123;        max = temp;        max1 = divisors[i];    &#125;&#125;if(max1 == 0)    return divisors[0];return max1;</code></pre><p>}</p><p>int addMinimum(char * word){<br>    int count &#x3D; 0, len &#x3D; strlen(word);<br>    for(int i &#x3D; 0; i &lt; len; count++, i++)<br>    {<br>        while(count % 3 !&#x3D; word[i] - ‘a’)<br>        {<br>            count++;<br>        }<br>    }<br>    while(count % 3 !&#x3D; 0)<br>    {<br>        count++;<br>    }<br>    return count - len;<br>}</p><p>2<br>bool isPrime(int x)<br>{<br>    int i &#x3D; 2;<br>    while(i * i &lt;&#x3D; x)<br>    {<br>        if(x % i &#x3D;&#x3D; 0)<br>        {<br>            return false;<br>        }<br>        i++;<br>    }<br>    return x &gt;&#x3D; 2;<br>}</p><p>int diagonalPrime(int** nums, int numsSize, int* numsColSize){<br>    int ans &#x3D; 0;<br>    for(int i &#x3D; 0; i &lt; numsSize; i++)<br>    {<br>        if(isPrime(nums[i][i]))<br>        {<br>            ans &#x3D; fmax(ans, nums[i][i]);<br>        }<br>        if(isPrime(nums[i][numsSize-i-1]))<br>        {<br>            ans &#x3D; fmax(ans, nums[i][numsSize-i-1]);<br>        }<br>    }<br>    return ans;<br>}</p><h1 id="C-部分"><a href="#C-部分" class="headerlink" title="C++部分"></a>C++部分</h1><ol><li><p>常用的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt;  <span class="comment">//strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;  <span class="comment">//&#123;[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;1&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]&#125;</span></span><br><span class="line">vector&lt;<span class="type">char</span>&gt;  <span class="comment">//[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span></span><br></pre></td></tr></table></figure></li><li><p>常用的类成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>())  <span class="comment">//将从索引 i + 1 到数组末尾的元素进行反转</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(nums[i], nums[j]) <span class="comment">//用于交换两个值的内容</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans</span><br><span class="line">ans.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;)  <span class="comment">//将一个包含三个整数的向量添加到二维向量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(rows,<span class="number">0</span>,<span class="built_in">sizeof</span>(rows))  <span class="comment">//于将指定的内存区域的每个字节都设置为特定的值。在这个特定的上下文中，它被用来将数组 rows 中的每个元素都设置为 0。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>常用的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>())  <span class="comment">//排序函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>这是一种初始化列表语法，它允许你在返回语句中用一个花括号括起来的列表来初始化一个对象，这里是一个 vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;      <span class="comment">//这里有问题，这样就不用再分配一个数组了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;i, j&#125;; </span><br></pre></td></tr></table></figure></li><li><p>计算行和列数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix.<span class="built_in">size</span>()</span><br><span class="line">matrix[<span class="number">0</span>].<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Leetcode总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习</title>
      <link href="/2023/02/19/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/02/19/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h1><ol><li><p>while+else在break下的作用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br></pre></td></tr></table></figure><table><tr><td bgcolor=MistyRose>很容易知道循环是因为条件结束还是break结束，并且还可以与for结合</td></tr></table></li><li><p>列表的增删查改函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加</span></span><br><span class="line">rhyme.append(<span class="number">9</span>)</span><br><span class="line">rhyme.extend(<span class="number">12</span>, <span class="number">22</span>)</span><br><span class="line">rhyme[<span class="built_in">len</span>(rhyme):] = [<span class="number">6</span>]</span><br><span class="line">rhyme[<span class="built_in">len</span>(rhyme):] = [<span class="number">6</span>, <span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">rhyme.insert(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">rhyme.remove(<span class="number">3</span>)</span><br><span class="line">rhyme.pop(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#排序</span></span><br><span class="line">rhyme.sort()</span><br><span class="line">rhyme.reverse()   <span class="comment">#前一个与后一个互换</span></span><br><span class="line">rhyme.sort(reverse=<span class="literal">True</span>)   <span class="comment">#从大到小排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找</span></span><br><span class="line"><span class="built_in">print</span>(rhyme.count(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(rhyme.index(<span class="number">2</span>))  <span class="comment">#查下标</span></span><br><span class="line">rhyme[rhyme.index(<span class="number">2</span>)] = <span class="number">3</span>   <span class="comment">#找出下标再替换</span></span><br></pre></td></tr></table></figure></li><li><p>print分别输出空格和换行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> i:</span><br><span class="line">        <span class="built_in">print</span>(each, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure></li><li><p>是这样的结果a&#x3D;[0,0,0]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>嵌套列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">a = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    a[i] = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure></li><li><p>当赋值运算发生的时候,python并不是将数据放到变量里边去,而是将变量与数据进行挂钩,被称为引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = x</span><br><span class="line">x[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(y)    <span class="comment">#会改变y</span></span><br></pre></td></tr></table></figure></li><li><p>浅拷贝和深拷贝用于嵌套列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = x.copy</span><br><span class="line">x[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(y)   <span class="comment">#不会改变y</span></span><br></pre></td></tr></table></figure></li><li><p>列表推导式的值是列表</p></li></ol><pre><code class="python">x = [i for i in range(10)]print(x)      #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]```;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux操作系统</title>
      <link href="/2023/02/19/%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/02/19/%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-操作系统"><a href="#Linux-操作系统" class="headerlink" title="Linux 操作系统"></a>Linux 操作系统</h2><ol><li><p>虚拟机的 Linux 系统，其 IP 地址是通过 DHCP 服务获取的</p></li><li><p>DHCP：动态获取 IP 地址，即每次重启设备后都会获取一次，使得 IP 地址经常变化</p></li><li><p>windows 的软件安装包为.exe，Linux 的软件安装包为.rpm，MaxOS 的软件安装包为.dmg</p></li><li><p>NetworkManager，主网络服务<br>network，副网络服务<br>firewalld，防火墙服务<br>sshd，ssh 服务(远程登录使用这个服务)</p></li><li><p>国内镜像一般是指位于中国境内的网站或文件服务器，或者在国内网络环境下为某些模型提供的用于快速下载和部署的镜像资源</p></li><li><p>虚拟端口可以确保两个不同计算机的程序(进程)之间进行连接<br>公认端口：SSH 服务的 22 端口(通过 FinalShell 去远程连接 Linux 操作系统，就是用的是系统的 22 端口)，HTTPS 服务的 443 端口</p></li><li><p>执行命令就是执行这个程序文件，比如 cd 的本体就是&#x2F;usr&#x2F;bin&#x2F;cd 这个程序文件</p></li><li><p>环境变量是操作系统在运行的时候，记录的一些关键性信息，用以辅助系统运行，环境变量就是一些变量，跟 c 语言的变量是一个意思</p></li><li><p>环境变量 PATH 记录了系统执行任何命令的搜索路径，无论你在任何地方去执行 cd，都能够准确的执行他的一个基础原理</p></li><li><p>自己开发的一些程序，把你自己开发程序所在的路径添加到环境变量 PATH 中，这样你就可以在任何地方执行自己开发程序了或自行的去设置一些变量，当你自己开发的程序需要用的时候，就可以从环境变量里面把它给取出来，这样相当于你自己在系统里面帮助你记录了一个全局的信息</p></li><li><p>Bash 是一个命令处理器，通常运行于文本窗口中，并能执行用户直接输入的命令</p></li><li><p>.tar，gzip(.gz 或.tar.gz)是 linux 系统中常用的压缩包格式</p></li><li><p>卡密：XCPL9DIUWAAZOV2HT9S6QK</p></li><li><p>.rpm是linux系统的软件包，使用rpm命令进行安装</p></li><li><p>Tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等，简单来说，Tomcat是一个WEB应用程序的托管平台，可以让用户编写的WEB应用程序，被Tomcat所托管，并提供网站服务。即让用户开发的WEB应用程序，变成可以被访问的网页。</p></li><li><p>Nginx* (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务，同Tomcat一样，Nginx可以托管用户编写的WEB应用程序成为可访问的网页服务，同时也可以作为流量代理服务器，控制流量的中转。</p></li><li><p>RabbitMQ一款知名的开源消息队列系统，为企业提供消息的发布、订阅、点对点传输等消息服务，RabbitMQ在企业开发中十分常见，课程为大家演示快速搭建RabbitMQ环境。</p></li><li><p>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。redis的特点就是：快，可以基于内存存储数据并提供超低延迟、超快的检索速度一般用于在系统中提供快速缓存的能力。</p></li><li><p>全文搜索属于最常见的需求，开源的(以下简称 es)是目前全文搜索引擎的首选,它可以快速地储存、搜索和分析海量数据,维基百科、Stack Overflow、Github 都采用它,Elasticsearch简称es，在企业内同样是一款应用非常广泛的搜索引擎服务,很多服务中的搜索功能，都是基于es来实现的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
