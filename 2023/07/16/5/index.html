<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Python | 金银财宝</title><meta name="keywords" content="计算机语言"><meta name="author" content="金银财宝"><meta name="copyright" content="金银财宝"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#9796f0"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Python"><meta name="application-name" content="Python"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#9796f0"><meta name="description" content="一、前言这是哪托针对老师的课件整理的复习笔记，基础入门，希望能对广大基础小白受用。内容如有错误的地方，劳请留言指正。 笔记所有代码使用Microsoft VS Code的 Python、Jupyter 插件编译。 二、语言基础2.1标识符1.2.1标识符标识符可以包括英文、数字以及下划线，并且：  开头必须是字母或下划线；  不能以数字开头开头；  区分大小写的；  不能出现分隔符、标点符号或者运">
<meta property="og:type" content="article">
<meta property="og:title" content="Python">
<meta property="og:url" content="https://www.jinyincaibao.online/2023/07/16/5/index.html">
<meta property="og:site_name" content="金银财宝">
<meta property="og:description" content="一、前言这是哪托针对老师的课件整理的复习笔记，基础入门，希望能对广大基础小白受用。内容如有错误的地方，劳请留言指正。 笔记所有代码使用Microsoft VS Code的 Python、Jupyter 插件编译。 二、语言基础2.1标识符1.2.1标识符标识符可以包括英文、数字以及下划线，并且：  开头必须是字母或下划线；  不能以数字开头开头；  区分大小写的；  不能出现分隔符、标点符号或者运">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/66dd3100d9c307b7e9837df9.jpg">
<meta property="article:published_time" content="2023-07-16T04:00:00.000Z">
<meta property="article:modified_time" content="2023-07-16T04:00:00.000Z">
<meta property="article:author" content="金银财宝">
<meta property="article:tag" content="计算机语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/66dd3100d9c307b7e9837df9.jpg"><link rel="shortcut icon" href="https://pic.imgdb.cn/item/66daa709d9c307b7e9042d3a.png"><link rel="canonical" href="https://www.jinyincaibao.online/2023/07/16/5/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="9f1f8e31c0e37a081430a812a31d7ef0"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: undefined,
  navMusic: true,
  changeMainColorPost: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"bottom-lef"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-16 12:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#9796f0')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#9796f0')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button" tabindex="-1"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://yz.chsi.com.cn/" title="研招网" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66dadacbd9c307b7e94c2e19.png" alt="研招网"/><span class="back-menu-item-text">研招网</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title"></div><div class="back-menu-list"><a class="back-menu-item" target="_blank"><img class="back-menu-item-icon"/><span class="back-menu-item-text"></span></a></div></div></div></div><a id="site-name" href="/"><div class="title">金银财宝</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 统计图</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9320926809&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" style="display: flex"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div class="nav-button" id="darkmode_navswitch"><a class="darkmode_switchbutton" type="button" href="javascript:void(0);" title="浅色和深色模式转换" onclick="anzhiyu.switchDarkMode()"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke" style="font-size: 1.3rem"></i></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>计算机语言</span></a></span></div></div><h1 class="post-title">Python</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-16T04:00:00.000Z" title="发表于 2023-07-16 12:00:00">2023-07-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-16T04:00:00.000Z" title="更新于 2023-07-16 12:00:00">2023-07-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">19.4k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>70分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Python"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为湖南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>湖南</span></div></div></div><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><div id="ai-tag">Tianli GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己</div><div class="ai-btn-item">生成本文简介</div><div class="ai-btn-item">推荐相关文章</div><div class="ai-btn-item">前往主页</div><div class="ai-btn-item" id="go-tianli-blog">前往tianli博客</div></div><script data-pjax>(function(){
  // 当前随机到的ai摘要到index
  let lastAiRandomIndex = -1;
  let animationRunning = true; // 标志变量，控制动画函数的运行
  // 当前gpt模式
  let mode = "tianli"
  // 刷新点击次数
  let refreshNum = 0
  // 记录上一次传递给aiAbstract的参数
  let prevParam;
  const aiTitleRefreshIcon = document.querySelector(".ai-title .anzhiyufont.anzhiyu-icon-arrow-rotate-right")
  const explanation = document.querySelector(".ai-explanation");
  const post_ai = document.querySelector(".post-ai-description");
  let ai_str = "";
  let ai_str_length = "";
  let delay_init = 600;
  let i = 0;
  let j = 0;
  let sto = [];
  let elapsed = 0;
  const animate = timestamp => {
    if (!animationRunning) {
      return; // 动画函数停止运行
    }
    if (!animate.start) animate.start = timestamp;
    elapsed = timestamp - animate.start;
    if (elapsed >= 20) {
      animate.start = timestamp;
      if (i < ai_str_length - 1) {
        let char = ai_str.charAt(i + 1);
        let delay = /[,.，。!?！？]/.test(char) ? 150 : 20;
        if (explanation.firstElementChild) {
          explanation.removeChild(explanation.firstElementChild);
        }
        explanation.innerHTML += char;
        let div = document.createElement("div");
        div.className = "ai-cursor";
        explanation.appendChild(div);
        i++;
        if (delay === 150) {
          document.querySelector(".ai-explanation .ai-cursor").style.opacity = "0";
        }
        if (i === ai_str_length - 1) {
          observer.disconnect(); // 暂停监听
          explanation.removeChild(explanation.firstElementChild);
        }
        sto[0] = setTimeout(() => {
          requestAnimationFrame(animate);
        }, delay);
      }
    } else {
      requestAnimationFrame(animate);
    }
  };
  const observer = new IntersectionObserver(
    entries => {
      let isVisible = entries[0].isIntersecting;
      animationRunning = isVisible; // 标志变量更新
      if (animationRunning) {
        delay_init = i === 0 ? 200 : 20;
        sto[1] = setTimeout(() => {
          if (j) {
            i = 0;
            j = 0;
          }
          if (i === 0) {
            explanation.innerHTML = ai_str.charAt(0);
          }
          requestAnimationFrame(animate);
        }, delay_init);
      }
    },
    { threshold: 0 }
  );
  function clearSTO() {
    if (sto.length) {
      sto.forEach(item => {
        if (item) {
          clearTimeout(item);
        }
      });
    }
  }
  function startAI(str, df = true) {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    observer.disconnect(); // 暂停上一次监听
    explanation.innerHTML = df ? "生成中. . ." : "请等待. . .";
    ai_str = str;
    ai_str_length = ai_str.length;
    observer.observe(post_ai); //启动新监听
  }

  async function aiAbstract(num = 1000) {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    observer.disconnect(); // 暂停上一次监听
    if (mode === "tianli") {
      num = Math.max(10, Math.min(2000, num));
      const options = {
        key: "i5m48wFrNQDM9fwUs2Lz",
        Referer: "https://www.jingyingcaibao.club/"
      };
      const truncateDescription = ("Python" + "一、前言, 二、语言基础, 2.1标识符, 1.2.1标识符, 1.2.2关键字, 2.1.3变量, 2.2数据类型, 1.整型int, 2.浮点数float, 3.复数complex, 4.布尔bool, 5.字符串str, 6.列表 list, 7.元组 tuple, 8.字典 dict, 9.集合 set, 2.3赋值语句、运算符, 2.3.1赋值语句的格式, 2.3.2运算符, 1.算数运算符, 2.关系运算符, 3.测试运算符, 4.逻辑运算符, 2.4从控制台输入和输出, 1. input()函数, 2.类型转换函数, 3.数据的输出, 2.5内置函数, 三、流程控制, 3.1分支结构, 3.2循环结构, 3.2.1for循环语句, 3.2.2 break语句和continue语句, 3.2.3 带else的循环语句（与C语言不同不建议用）, 3.2.4循环嵌套, 四、常用数据结构, 4.1 序列, 4.1.1列表 list, 1.列表的创建, 2.列表的元素访问, 3.修改元素, 4.列表切片, 5. del命令, 7.列表方法：类型本身的方法, 9.列表遍历, 4.1.2元组, 1.元组的创建, 2.元组的访问, 4.1.3 列表与元组的转换, 1.列表–gt元组, 2.元组–gt列表, 4.2 字典, 4.2.1 创建字典, 4.2.2 字典操作, 1.字典中键-值对的数量, 2.查找与特定键相关联的值：键—gt值, 3.修改字典中的数据, 4.删除字典条目, 4.2.3 字典方法, 1.keys()、values(), 2.items(), 3.setdefault(), 4.update(), 5.clear(), 6.pop(), 7.popitem(), 8.get(), 4.2.4遍历字典, 1.遍历字典的key, 2.遍历字典的值Value, 3.遍历字典的键值对, 4.2.5列表、元组、字典的转换, 1.列表与字典之间的转化：字典–gt列表, 2.元组与字典之间的转化：字典–gt元组, 4.3 集合 Set, 4.3.1 集合的创建, 4.3.2 集合的运算, 1.len() 、max()、min()、sum(), 2.in, 3.并集、交集, 4.差集, 5.对称差, 6.子集和超集, 4.3.3 集合的方法, 1.union()、intersection(), 2.update(), 3.difference(), 4.symmetric_difference(), 5.issubset()和issuperset(), 6.add(), 7.remove(), 8.discard(), 9.pop(), 10.clear(), 4.4 可迭代对象Iterable 与 迭代器Iterator, 4.4.1 可迭代(Iterable)对象, 4.4.2 相关内置函数, 4.5 推导式, 4.5.1 列表推导式, 4.5.2 字典推导式, 4.5.3 集合推导式, 4.5.4 生成器推导式, 五、字符串, 5.1 字符串的编码, 5.2 字符串的构建, 5.3 字符串格式化, 5.4 字符串截取, 5.5 字符串常用内置函数, 5.6字符串常用方法, 5.7 字符串string模块, 5.8正则表达式一前言这是哪托针对老师的课件整理的复习笔记基础入门希望能对广大基础小白受用内容如有错误的地方劳请留言指正笔记所有代码使用的插件编译二语言基础标识符标识符标识符可以包括英文数字以及下划线并且开头必须是字母或下划线不能以数字开头开头区分大小写的不能出现分隔符标点符号或者运算符不能使用关键字等最好不要使用内置模块名类型名函数名已经导入的模块及其成员名合法的标识符连续两个下画线等非法的标识符中间用了空格关键字等关键字关键字是一个特殊的对象不是不是也不是空字符串空列表等有自己的数据类型和任何其他数据类型进行是否相等比较永远返回可以将赋值给任何变量但是不能创建其他对象变量变量与与语言相比相同点用于储存计算结果或能表示值可以通过变量名访问变量值通常是可变的变量具有名字不同变量是通过名字相互区分的不同点变量的数据类型不需要声明变量的数据类型可以变化是动态类型语言变量使用之前必须赋值常量没有常量即没有语法规则限制改变一个常量的值怎么办呢使用人为约定通常用全大写字母表示常量编程时不要修改它的值常量示例你喜欢我吗运行运行数据类型整型整数没有小数部分的数值分为正整数和负整数十进制二进制八进制十六进制浮点数浮点数包含小数点的数科学计数法运行运行复数复数由两部分组成实部和虚部复数的形式为实部虚部都是复数复数的实部复数的虚部运行运行两个注意点支持任意大的数字仅受内存大小的限制所以在使用时不用考虑的范围为了提高可读性在数值中可以使用下画线布尔布尔类型是用来表示逻辑是非的一种类型它只有两个值和首字母和是大写的将布尔值实现为类型实现为所以可以参与整型运算但不建议这么做字符串语言中的字符串是一种序列字符串用单引号双引号三引号作为定界符等列表列表也是一种序列类型列表用方括号和将列表中的元素括起来元素之间以逗号进行分隔和元组元组也是一种序列元组用和作为边界将元素括起来元素之间以逗号分隔和字典字典是唯一内建的映射类型可用来实现通过数据查找关联数据的功能字典是键值对的无序集合字典中的每一个元素都包含两部分键和值字典用大括号和来表示每个元素的键和值用冒号分隔元素之间用逗号分隔张三徐虎张林集合集合是由各种不可变类型的元素组成但元素之间无序并且元素都不重复赋值语句运算符赋值语句的格式变量表达式常规同特殊多变量赋值两变量的交换运行运行运算符算数运算符在中算术运算符有加减乘真除法求整商取模幂需要说明的几点运算符不支持不同类型的对象之间的连接错误不同类型正确通过类型转换函数将数字转换成字符串运算符可以用于列表元组或字符串与整数的相乘用于将这些序列重复整数所指定的次数它不适用于字典和集合与整数的相乘列表元组字符串字典不可以因为字典的键不能重复运算符幂运算与内置函数相同真除法与整数除法真除取商的整数部分操作数为实数时则取实数形式的整数即运行运行关系运算符六个小于小于等于大于大于等于等于不等于结果布尔值或所有的字符串都是字符串单个字符可以通过函数获取该字符的码通过函数把编码转换为对应的字符得到对应的字符我我运行运行注意字符串和数字属于不可比较大小的列表比较大小也是从左到右逐个元素的依次比较类似字符串之间的比较列表中字符串与数值也是不能比较的出错出错关系运算符可以连用等价于某几个用连接起来的表达式注意语言和语言均不可这么用与下式含义相同与下式含义相同运行运行因为精度问题可能导致实数运算有一定的误差要尽可能地避免在实数之间进行相等性判断有误差了误差导致不相等解决方法使用实数之间的差值的绝对值是否小于某一个很小的数来作为实数之间是否相等的判断表示和是相等的运行运行测试运算符四个结果返回布尔值或列表测试字符串虽然内容一样但不是同一个对象运行运行同一性测试运算符和测试是否为同一个对象或内存地址是否相同返回布尔值和测试是否为同一个对象相等但不是同一个对象测试是否相等运行运行注意是否相等只是测试值是否相同是否为同一个对象指的是是否指向同一个对象如果指向同一个对象则内存地址应该相同当然也相等内置函数返回对象的标识内存地址每个人运行得到的内存地址可能会不一样赋值语句则和不仅值相等而且指向同一个对象的内存地址相同逻辑运算符在中逻辑运算符有与或非通过逻辑运算符可以将任意表达式连接在一起哪些是数值类型中的空字符串空元组空列表空字典空集合等非零值为零值为运行运行逻辑操作符和也称作短路操作符具有惰性求值的特点短路运算表达式从左向右解析一旦结果可以确定就停止注意逻辑运算符不一定会返回布尔值和与运算结果不一定为或当计算表达式时先计算的值当的值为或非空值非非值非空的其他数据类型才计算并输出的值当的值为或空值值为空的其他数据类型直接输出的值不再计算第一个为则输出第二个的值结果与第二个值有关下同的值为则计算并输出的值第一个为则不再计算第二个的值直接输出第一个的值下同直接输出直接输出运行运行或运算结果不一定为或当计算表达式时先计算的值当的值为或非空值非非值非空的其他数据类型直接输出的值不再计算当的值为或空值值为空的其他数据类型才计算并输出的值第一个为则不再计算第二个的值直接输出第一个的值下同的值为则直接输出第一个为则继续计算第二个的值输出第二个的值下同运行运行赋值运算符复合赋值运算符位运算符等等此处基本同语言特别注意没有自加与自减优先级小括号最高从控制台输入和输出函数用于输入数据无论用户输入什么内容该函数都返回字符串类型其格式如下表示提示语默认为空请输入值请输入值查看的类型为运行运行类型转换函数函数格式功能截取数字的整数部分或将字符串转换成一个整数如果不给定参数则返回没有参数时浮点数直接截取整数部分不进行四舍五入整数字符串浮点数字符串错误注意函数不接受带小数的数字字符串格式功能把进制的字符串转换为十进制为基数进制默认为十进制的有效值范围为和二进制的数转换为十进制数十六进制的数转换为十进制数八进制的数转换为十进制数不允许二进制的小数不接受带小数的数字二进制的数转换为十进制数函数格式功能将一个数字或字符串转换成浮点数默认参数为无穷大不区分大小写错误错误不能转换表达式字符串所以引入函数函数格式功能将字符串当做一个表达式进行解析和计算返回计算结果参数说明是一个字符串这个字符串能表示成表达式或者是能够通过编译的代码是可选的参数默认为如果设置属性不为的话就必须是对象也是可选的参数默认为如果设置属性不为的话可以是任何对象字符串中是表达式返回表达式的值字符串中是列表元组或字典得到真正的列表元组或字典字符串中是能够通过编译的代码执行代码表达式返回列表返回字典执行语句执行语句获取当前目录组合使用函数和请输入值输入列表格式获得列表请输入值输入字典格式获得字典数据的输出函数格式如下各参数的解释如下需要输出的对象一次可以输出一个或者多个对象其中表示任意多个对象对象之间要用逗号分隔对象之间的间隔符默认用一个空格分隔以何字符结尾默认值是换行符表示输出位置可将输出到文件指定的对象要有写的方法默认值是标准输出即控制台屏幕将缓存里面的内容是否强制刷新输出默认值是一般不需要一次输出三个对象中间默认用空格隔开一次输出三个对象中间用隔开一次输出三个对象中间无分隔因为参数值被设置为空字符串了一次输出三个对象以结尾不换行一次输出三个对象以分隔以结尾运行运行可以看出函数默认输出是换行的如果要实现不换行需要在变量末尾设置参数内置函数函数功能返回数字的绝对值如果给出复数返回值就是该复数的模把整数转换为二进制函数返回整商和余数的元组计算字符串中表达式的值并返回返回对象的帮助信息返回对象的标识内存地址接受键盘输入显示提示信息返回字符串返回对象列表元组字典字符串集合对象的元素个数包含若干函数值的对象其中表示函数表示迭代对象将函数作用于迭代对象返回给定参数的最大值最小值参数可以为可迭代对象函数返回以为底为指数的幂如果给出值该函数就计算的次幂值被取模的值输出对象默认输出到屏幕相邻数据之间使用空格分隔结尾以换行符结束返回对象该对象包含按参数范围内为步长生成的整数返回浮点数的四舍五入值若不给出值则返回整数给出值则代表舍入到小数点后的位数返回排序后的列表其中表示要排序的序列或迭代对象表示排序规则表示升序或降序默认升序返回序列中所有元素之和如果指定起始值则返回如果为空则返回返回编码为所对应的字符把字符串或数字转换为复数如果第个参数是字符串不能使用第个参数把一个数字或字符串转换成浮点数把整数转换成十六进制串把数字和字符串转换成一个整数或把进制的字符串转换为十进制为可选的基数默认为十进制将对象转换成列表元组字典集合或生成空列表空元组空字典空集合把给出的整数转换成八进制串返回一个字符的编码三流程控制分支结构单分支语句双分支语句多分支语句选择结构的嵌套选择结构的三元运算注意没有语句语法类似于此处省略循环结构定义给定的判断条件为真包括非零非空时重复执行某些操作判断条件为假包括零空时结束循环循环分类语句语句循环中断带的循环语句特有与类似相关内容请参考循环语句语句通过遍历一个序列字符串列表元组或迭代器等可迭代对象中的每个元素来建立循环语句的语法形式如下所示变量序列或迭代器等可迭代对象循环体补充函数返回可迭代对象语法格式如下功能产生一个从开始包括默认为到结束不包括两个整数对象之间间隔默认为的可迭代对象可以用循环直接遍历函数产生的可迭代对象默认运行运行对象可以被转换成列表或元组例如对象转换为列表对象对象转换为元组对象语句和语句详细解释语句可以用在和循环中在循环进行过程中如果某个条件被满足一般通过语句判断是否满足执行语句的条件则可以通过语句立即终止本层循环如果语句在具有两层循环嵌套的内层循环中则只终止内层循环进入到外层循环的下一条语句继续执行语句可以用在和循环中在循环体执行过程中如果遇到语句程序会跳过本次循环的循环体剩余语句回到循环开始的地方重新判断是否进入下一次循环精简语句终止整个当前循环语句的执行不会终止整个当前循环只是提前结束本次循环跳过循环体中本次循环的剩余语句提前进入到下一次循环再精简同语言带的循环语句与语言不同不建议用中的和语句后面还可以带有语句块语句语法如下条件表达式循环体语句块三种执行流程正常循环当条件表达式为真非空非零时反复执行循环体执行一次当条件表达式为假零空而导致循环终止或无法进入循环语句块执行一次然后结束该循环结构不执行如果该循环是因为执行了循环体中的语句而导致循环终止语句块不会执行直接结束该循环结构例从键盘输入一个正整数用循环找出小于等于该整数且能被整除的最大正整数如果找到了输出该整数如果没有找到则输出未找到请输入一个正整数小于等于且能被整除的最大正整数是未找到运行运行带的语句语法如下变量序列或迭代器等可迭代对象循环体语句块循环嵌套四常用数据结构序列列表列表是中最基本的数据结构是最常用的数据类型列表的特点列表将由若干数据作为元素的序列放置在一对方括号中元素之间以逗号分隔列表中的元素允许重复列表是可以修改的增删改查以上类似数组列表元素可以由任意类型的数据构成同一列表中各元素的类型可以各不相同不同于数组列表的操作汇总创建列表访问元素更改元素值切片形式列表计算列表列表列表整数列表方法查增删序序列函数不仅仅用于列表命令列表列表的创建创建一维列表方式普通列表方式创建空列表函数创建二维列表运行运行列表的元素访问索引列表中的每个元素被关联一个序号即元素的位置索引值是从开始第二个则是以此类推从左向右逐渐变大列表也可以从后往前索引值从开始从右向左逐渐变小适用于所有序列类型的对象列表元组字符串修改元素通过重新赋值来更改某个元素的值注意合法索引范围超过范围则会出错列表切片在列表中可以使用切片操作来选取指定位置上的元素组成新的列表简单的切片方式为步长默认为原列表名左封闭能取到右开放取不到左索引为时可缺省右索引为列表长度时可缺省取第号元素缺省为缺省为列表长度长度从开始计算都缺省全列表等于时空列表运行运行也可以使用负数作索引索引为和位置上的元素依然是从左往右取索引从至列表末尾位置上的元素运行运行切片步长非零整数即可正可负但不能为跳着切片原列表名步长为时参数可以省略步长不为时该参数不可省略函数为的可迭代对象用函数转换为从到的列表步长为索引值从开始每次增长但索引值必须小于步长为负数时不能小于值超过范围实际索引从最后一个元素开始不出错这里步长为负数表示在整个列表内从后往前取值作用逆序运行运行利用切片还可以更改元素值有点类似多变量赋值的感觉分别更改索引号为和的位置上元素值分别更改索引号为三个位置上的元素值少给个数呢少的那个数被删掉了命令注意是命令不是函数或方法从列表中删除元素也可以删除整个列表删除了删除列表列表不存在了再次使用出错补充方法函数命令的概念上的区别命令内置命令没有括号函数是指内置函数或用导入的某模块的函数直接可以使用比如方法是指某个对象的方法格式为对象名方法名比如是指列表对象的方法列表运算列表相加通过列表相加的方法生成新列表支持复合赋值结果为新列表原列表不变复合赋值语句不支持减运算出错列表乘法列表整数生成一个新列表新列表原来列表的元素重复次相乘语句复合赋值语句相当于重新定义了列表运行运行列表方法类型本身的方法返回第一个值元素索引位置没指定则从索引为的位置开始查找否则从索引为的位置开始查找没指定可以查找到列表最后元素否则在位于内的索引区间查找如果找不到匹配项就会引发异常整个列表范围内第次出现的索引位置是在从索引为开始第次出现的索引位置是运行运行统计某个元素在列表中出现的次数追加单个元素到列表的尾部只接受一个元素元素可以是任何数据类型被追加的元素在列表中保持着原结构类型在列表的末尾一次性追加另一个列表中的多个值只能有一个参数应用用新列表扩展原有的列表将一个元素插入到指定位置两个参数第一个参数是索引点即插入的位置第二个参数是插入的元素插入后在位置注意插入后的位置在位置的前面运行运行用于移除列表中与某值匹配的第一个元素如果找不到匹配项就会引发异常移除列表中的一个元素默认为最后一个元素并且返回该元素的值出栈可以指定索引位置当不在索引范围内或者是空列表中均会触发异常删除列表中所有元素但保留列表对象请注意与命令的区别命令删除整个列表时列表对象不再保留方法用于将列表中的元素位置反向存放列表中可以有不同类型的元素方法只是将位置反转元素排序默认按升序排列两个参数参数默认为升序若等于表示降序排序如果包含的是字符串按字符串排序规则参数指定排序方式按数值大小升序降序按转换为字符串后的大小升序排列码排序的元素必须是可比较大小字符串和数值不能比较列表函数不单单用于列表的函数也可用于其他数据结构列表遍历通过语句或者语句循环遍历所有元素直接遍历每一个元素循环通过索引遍历每一个元素运行运行元组元组和列表十分相似元组是用一对圆括号括起用逗号分隔的多个元素的组合属于序列有顺序可以重复元组是不可更改的是不可变对象元组创建之后就不能修改添加删除成员元组的上述特点使得其在处理数据时效率较高而且可以防止出现误修改操作元组的创建创建多个元素的元组创建单一元素的元组后面的逗号不能省略省略后就变成字符串类型了创建空元组使用函数创建空元组运行运行元组的访问和列表一样可以通过索引访问单个切片访问多个来访问元组的成员索引方式切片方式元组不能更改元素值不能赋值报错元组的运算元组相加通过元组相加的方法生成新元组正确重新定义了运行运行元组相乘用数字乘以一个元组会生成一个新元组在新元组中原来的元组元素将依次被重复次运行运行元组的遍历通过语句或者语句同列表方法列表与元组的转换列表元组函数接受一个列表并返回一个包含同样元素的元组从结果上看函数冻结了列表元组运行运行元组列表函数接受一个元组并返回一个包含同样元素的列表从结果上看函数融化了元组运行运行字典字典是中唯一内建的映射类型用一对花括号和作为边界元素之间以逗号分隔每个元素是一对键和值键和值之间用英文冒号分隔映射可通过数据查找关联数据无序字典的元素没有顺序因此不能像序列那样通过位置索引来查找成员数据但是每一个值都有一个对应的键不重复字典的键是不重复的用法通过键来访问相应的值值是可以重复的创建字典创建创建需注意键外面不能加引号列表元组由序列构建对象由对象创建字典以给定序列元组或者列表为键创建值为空的字典创建空字典无参的函数运行运行键必须是不可修改类型的数据如数值字符串和元组等列表是可变的不能作为字典的键键对应的值可以是任何类型的数据字典是无序集合字典的显示次序由字典在内部的存储结构决定字典操作字典中键值对的数量返回字典中项键值对的数量运行运行查找与特定键相关联的值键值运行运行修改字典中的数据在字典中某个键相关联的值可以通过赋值语句来修改如果指定的键不存在则相当于向字典中添加新的键值对有则修改无则添加运行运行删除字典条目命令用来删除字典条目或者整个字典键存在删除整个检查字典中是否含有某键的项命令查找某键值是否在字典中如果存在返回否则返回字典方法方法将字典中的键以可迭代的对象返回方法将字典中的值以可迭代的对象形式返回转换成列表转换成元组运行运行将字典中的所有键和值以可迭代的对象返回每对键值对组成元组作为一个元素转换成列表转换成元组运行运行使用时如果字典中包含参数对应的键则返回该键对应的值否则以参数的值为键以参数的值为该键对应的值在字典中插入键值对元素并返回该元素的值部存在这个键返回对应的值控制单元存在这个键默认值和原有的值不一样返回对应的原值有则修改不存在这个键插入新的键值对和之前比较无则添加不存在这个键也未指定新值运行运行将另一个字典中的所有键值对一次性地添加到当前字典中如果两个字典中存在有相同的键则以另一个字典中的值更新当前字典方法将字典中的所有条目删除变成空字典方法能够弹出并删除字典中的键值对返回键为的值并在字典中删除该键值对方法能够弹出字典的一个元素如果字典为空则触发异常返回指定键所对应的值如果键不存在则返回默认值默认值为也可以自己指定遍历字典遍历字典的默认遍历字典的键和上面相同遍历字典的值遍历字典的键值对列表元组字典的转换列表与字典之间的转化字典列表中的函数可以将字典转换列表但列表不能转换为字典默认将键转化为列表键值键值对元组与字典之间的转化字典元组中的函数可以将字典转换元组但元组不能转换为字典默认将键转化为元组键值键值对集合集合是一组用括起来的无序不重复元素元素之间用逗号分隔元素可以是各种类型的不可变对象集合想象成只有没有值的字典集合的创建集合类型的值有两种创建方式用一对花括号将多个元素括起来元素之间用逗号分隔函数将字符串列表元组等类型的数据转换为集合类型直接赋值函数注意空集合只能用来创建而不能用空的花括号表示因为已将空用于表示空字典无参的函数空集合运行运行集合中没有相同的元素因此创建集合时会自动删除掉重复的元素利用这一点可以快速去重集合的运算返回集合中元素的个数生成排序后的列表集合本身无序不能反序集合本身无序判断某元素是否存在于集合之中判断结果用布尔值或表示并集交集并集创建一个新的集合该集合包含两个集合中的所有元素交集创建一个新的集合该集合为两个集合中的公共部分并集交集运行运行差集表示集合与的差集返回由出现在集合中但不出现在集合中的元素所构成的集合对称差返回由两个集合中那些不重叠的元素所构成的集合子集和超集子集如果集合的每个元素都是集合中的元素则集合是集合的子集超集超集是仅当集合是集合的一个子集集合才是集合的一个超集检测是否是的子集检测是否是的真子集检测是否是的超集检测是否是的真超集以上结果只返回或将的元素并入中集合的方法同样以面向对象方式实现集合类型的运算方法相当于并集运算方法相当于交集运算并集新的集合未发生改变未发生改变交集产生新集合运行运行方法相当于集合元素合并运算注意与方法的区别发生了改变相当于差集运算新集合原集合没有变化相当于对称差运算结果相同和方法判断是否子集方法判断是否超集是向集合中添加元素重复元素只保留一个是从集合中删除元素如果集合中没有该元素则出错作用是从集合中删除元素如果集合中没有该元素也不提示出错方法的作用是从集合中删除任一元素并返回该元素如果集合为空则抛出异常从集合中删除所有元素变成一个空集合可迭代对象与迭代器简单解释可迭代对象是存放元素的容器可以被遍历其中的元素类比链表迭代器由可迭代对象容器提供的因为只有该容器知道怎么遍历它的每一个元素用于遍历容器元素的一个工具类比链表的遍历指针可迭代对象列表元组字符串字典可以用进行遍历表面只要可以用进行遍历的对象就是可迭代对象那么列表元组字符串字典都是可迭代对象本质如果一个对象实现了方法那么这个对象就是可迭代对象方法查看对象的方法是否有方法类似于中查看某一个类可实现的方法运行运行方法可以通过调用内置函数来判断一个对象是否属于可迭代对象列表是可迭代对象吗数值是可迭代对象吗不是运行运行迭代器实现了方法和方法并且可以通过方法不断返回下一个值的对象迭代器还可以通过内置函数访问下一个元素可以通过调用内置函数来判断一个对象是否属于迭代器列表是迭代器吗列表是迭代器吗字典是迭代器吗集合是迭代器吗字符串是迭代器吗函数生成的数列是迭代器吗数值是迭代器吗以上对象均不能成为迭代器注意迭代器和可迭代对象不同运行运行可迭代对象容器迭代器迭代工具虽然列表元组字符串字典集合都是可迭代对象而不是迭代器但可以通过函数获得一个迭代器列表取的迭代器自带方法返回下一个值也可以用内置函数函数没有下一个元素了触发异常内置函数访问下一个值同样异常运行运行相关内置函数枚举组合映射逐个计算过滤挑选共同点这四个函数都会返回一个特定对象它们都既是迭代器也是可迭代对象枚举格式功能返回下标和值的对象参数第个参数表示可迭代对象第个参数表示下标的开始值默认从开始通俗将容器的每个元素取出来搭配一个下标对象既是对象容器也是对象容器的遍历工具列表用其他容器也可以取得的枚举器迭代器可以使用语句也可以使用函数也可以使用方法将剩余的对象元素转换为列表对象转换为元组下标从开始返回下一个值遍历对象中的元素遍历对象元素的下标和值对象转换为字典枚举号转为枚举值转为对象转换为集合格式功能将多个迭代器对象或者可迭代对象中的元素压缩到一起返回一个对象通俗将多个容器的逐个对应元素拼合在一起同样对象既是一个可迭代对象也是一个迭代器对象只有一个参数字符串容器每个元素是元组有两个参数有两个容器作为参数对象是可迭代对象容器可以使用运算第二个参数是枚举也是容器不同长短时匹配短的更多参数更多容器格式功能把一个函数依次映射到可迭代对象的每个元素上返回一个对象通俗将每个元素传入函数把结果放入里对象既是一个可迭代对象也是一个迭代器对象将每个元素变为类型将改为字符串定义一个函数中的每个元素都执行一次函数结果放入运行运行格式函数名可迭代对象功能把一个带有一个参数的函数作用到一个可迭代对象上返回一个对象对象中的元素由可迭代对象中使得函数返回值为的那些元素组成如果指定函数为则返回可迭代对象中等价于的元素通俗将容器中的元素用函数过滤挑选一下对象既是一个可迭代对象也是一个迭代器对象只保留满足条件的元素用法函数定义函数为奇数返回否则返回将中的每个元素作为参数带入将返回值为的元素保留下来是一个对象用法函数匿名函数不用单独定义函数了用法指定函数为函数就不起作用了就看元素本身是否为运行运行推导式利用列表推导式字典推导式集合推导式可以从一个数据对象构建另一个新的数据对象利用生成器推导式可以构建生成器对象语法糖列表推导式列表推导式是开发时用得最多的技术之一表示对可迭代对象的元素进行遍历过滤或再次计算生成满足条件的新列表它的结构是在一个方括号里包含一个函数或表达式再次计算接着是一个语句遍历然后是个或多个遍历或者语句过滤在逻辑上等价于循环语句但是形式上更简洁语法形式函数表达式值可迭代对象条件值可迭代对象条件值可迭代对象条件列表推导式和循环语句如果要将一个列表中的元素均扩大倍组成新列表列表推导式运行运行两点利用列表推导式更加简洁由于内部对列表推导式做了大量优化还能保证较快的运行速度循环可以嵌套列表推导式中也可以有多个语句如果要将一个一层嵌套数字列表中的元素展开后扩大倍组成新列表一层嵌套列表常规写法每一行行中的每一列列表推导式运行运行列表推导式和条件语句在列表推导式中条件语句对可迭代对象中的元素进行筛选起到过滤的作用接着上面的例子如果是将一个数字列表中的是正数的元素扩大倍组成新列表运行运行另外在列表推导式中还可以使用语句将一个数字列表中的正偶数扩大倍正奇数扩大倍组成新列表运行运行列表推导式和函数在列表推导式中可以使用函数利用列表推导式快速生成包含个包含之间的随机整数列表使用函数对中的元素如果被整除则该数除以如果被整除则该数扩大倍其他的数扩大倍这些数组成新列表使用自定义的函数运行运行同时遍历多个列表或可迭代对象有两个成绩列表和将中分数及以上和中分数及以下的元素两两分别组成元组将这些元组组成列表中的元素运行运行字典推导式字典推导式和列表推导式的使用方法类似将方括号变成花括号需要两个表达式一个生成键一个生成值两个表达式之间使用冒号分隔最后生成的是字典语法形式函数表达式值可迭代对象条件值可迭代对象条件值可迭代对象条件列表存储若干人的名字唯一列表在对应的位置上存储这些人的成绩利用字典推导式以名字为键成绩为值组成新字典以名字为键成绩为值组成新字典新字典中的键值对只包含成绩及以上的增加一个以名字为键名字的长度为值组成新字典运行运行集合推导式集合也有自己的推导式跟列表推导式类似只不过将方括号变成花括号最后生成的是集合语法形式函数表达式值可迭代对象条件值可迭代对象条件值可迭代对象条件运行运行不难发现构建和的时候除了方括号和花括号不同以外其他语法均相同生成一个列表里面的元素是元组中每个元素的倍而且元素位置一一对应生成一个集合里面的元素是元组中每个元素的倍去掉重复元素后的结果并且并非与元组的元素位置一一对应需要说明的是元组没有推导式生成器推导式生成器推导式用法与列表推导式类似把列表推导式的方括号改成圆括号它与列表推导式最大的区别是生成器推导式的结果是一个生成器对象是一种迭代器而列表推导式的结果是一个列表生成器对象可以通过循环或者方法函数进行遍历也可以转换为列表或元组但是不支持使用下标访问元素已经访问过的元素也不支持再次访问当所有元素访问结束之后如果想再次访问就必须重新创建该生成器对象生成器对象转换为列表不能再次访问访问下一个元素循环遍历五字符串字符串的编码码标准码为位编码包括英文字母数字标点符号等个字符用个字节存储最高位为扩展码个字节存储最高位为编码把所有语言统一到一套编码里采用个字节或个字节生僻字符的编码缺点全部是英文的话比码多用一倍存储空间编码可变长编码英文字符用个字节兼容码中文字符用个字节其他语言也有用或个字节等中文编码一般用个字节支持两种类型字符串类型支持编码和类型而且类型和类型可以相互转换可以转换为类型转换为类型除此之外其他方法都一样我类型编码编码成类型编码格式进制个字节位进制数用位进制数表示编码成类型编码格式进制个字节解码目前是编码的字符串使用进行解码目前是编码的字符串使用进行解码我是类型字符串中文字符串不能以编码英文字符串可以以编码也可以使用和完成两种类型的相互转换阳光用编码转换用编码转换个字节用编码转换类型是用转换来的阳光个字节结果有误运行运行完全支持中文字符解析器默认采用解析源程序无论是数字字符英文字母汉字都按一个字符来对待和处理字符串的构建在中字符串的构建主要通过两种方法来实现一是使用函数二是用单引号双引号或三引号单引号或双引号构造字符串要求引号成对出现合法如不合法字符串本身有单引号或双引号时字符串包含了单引号且不用转义字符整个字符串就要用双引号来构造字符串包含了双引号且不用转义字符整个字符串要用单引号来构造字符串本身有单引号字符串本身有双引号函数输出时是没有外层的引号的运行运行对引号转义运行运行对其他字符转义转义字符以开头后接某些特定的字符或数字转义字符含义转义字符含义转义字符含义行尾续行符换行符换页符一个反斜杠回车位进制数对应的字符如单引号横向水平制表符位进制数对应的字符如双引号纵向垂直制表符位进制数表示的字符你好再见表示换行相当于敲了一个回车键进制数对应的字符是进制数对应的字符运行运行原始字符串假设在文件夹中有一个文件夹如何输出完整路径呢可能你想到的是错误运行运行第种方法使用表示反斜杠则和不再形成和运行运行第种方法在原始字符串前加前缀在字符串前面加上字母或表示原始字符串所有的字符都是原始的本义而不会进行任何转义运行运行三重引号字符串三重引号将保留所有字符串的格式信息如字符串跨越多行行与行之间的回车符引号制表符或者其他任何信息都将保存下来在三重引号中可以自由的使用单引号和双引号字符串格式化用符号格式化字符串格式以开头格式化运算符用表示用对象代替格式串中的格式最终得到个字符串基本同语言字符串格式的书写中的内容可以省略简单的格式是加格式字符如等当最小宽度及精度都出现时它们之间不能有空格格式字符和其他选项之间也不能有空格如常用格式字符的含义基本同语言最小宽度和精度最小宽度转换后的值所保留的最小字符个数精度对于数字来说结果中应该包含的小数位数浮点数总宽度为保留位小数四舍五入单独的默认保留位小数保留位小数第位四舍五入四舍五入为宽度位保留位小数空位填空格宽度位保留位小数空位填实际宽度允许超出最小宽度宽度位保留位小数正数加正号空位填宽度位保留位小数空位填空格左对齐输出左对齐左对齐右补空格字符串用格式化整数输出引发异常类型必须一致与等价多对象后用元组常量元组我叫今年岁变量元组我叫今年岁进位制和科学计数法转换为八进制串转换为十六进制串进制数前添加转换为科学计数法串基底小数点前有一位非零数字小数点后是位小数科学计数法基底科学计数法基底采用浮点数形式根据值的大小采用或采用浮点数形式采用科学计数法形式基底运行运行方法格式化字符串方法是通过和来代替传统方式首先看和参数的对应关系我叫今年岁张清以下输出均为我叫张清今年岁我叫今年岁张清我叫今年岁张清张清我叫今年岁列表前加自动解包我叫今年岁列表不加则需要用列表的索引元素后的表示第一个参数若有第个参数则为中的数字表示列表元素的索引我叫今年岁张清直接写变量名我叫今年岁张清有了名字之后就可以任意顺序张清我叫今年岁字典前加自动解包十进制的二进制八进制十六进制千分位格式化右对齐左对齐居中对齐放在和中间作为分隔符起到千分位的作用运行运行带前缀的格式化字符串张清我叫今年岁运行运行字符串截取字符串属于序列类型同样可以使用索引或者切片单个字符索引取出单个字符切片字符取出一片字符同序列的切片取出位置为到位置为的字符不包括位置的字符取出从头至位置为的字符取出从倒数第个位置开始的所有字符从左往右取步长默认是正序全部字符逆序全部字符步长为运行运行字符串属于不可变序列类型不支持字符串修改字符串常用内置函数字符串长度最大字符最小字符本处为空格获取该字符的码把编码转换为对应的字符好汉字的编码运行运行字符串常用方法由于字符串属于不可变序列下述方法中涉及到返回字符串的都是新字符串原有字符串对象不变格式居中对齐左对齐右对齐说明指定宽度填充的字符默认为空格功能返回一个宽度为的新字符串原字符串居中左对齐或右对齐出现在新字符串中如果大于字符串长度则使用进行填充你好居中对齐以空格填充你好你好居中对齐以填充你好你好右对齐以填充你好你好左对齐以填充你好运行运行方法将大写字母转换为小写字母其他字符不变并返回新字符串全部为小写字母方法将小写字母转换为大写字母其他字符不变并返回新字符串全部为大写字母用处解决有关不区分大小写问题将整个字符串首字母转换为大写形式其他字母转换为小写形式将每个单词的首字母转换为大写形式其他部分的字母转换为小写形式将大小写互换提醒均返回新字符串原字符串对象不做任何修改功能测试字符串是否为全小写大写数字如果是则返回否则返回其他的方法请通过自行查看帮助信息格式说明字符串子串开始位置结束位置查找范围开始结束不包括功能在字符串中在范围内查找并返回子串首次出现的位置索引如果没有找到则返回默认范围是整个字符串其中方法从左往右查找方法从右往左查找格式功能在字符串中查找并返回在范围内子串首次出现的位置索引如果不存在则抛出异常和的不同点默认范围是整个字符串其中方法从左往右查找方法从右往左查找格式功能在字符串中查找并返回范围内子串出现的次数如果不存在则返回默认范围是整个字符串功能以指定字符为分隔符从左往右将字符串分割开来并将分割后的结果组成列表返回如果字符串中的某种字符出现次或多次可以利用方法根据该字符把字符串分离成多个子串组成的列表对于如果不指定分隔符实际上表示以任何空白字符包括连续出现的作为分隔符空白字符包括空格换行符制表符等除了还有表示从右往左将字符串分割开来这两种方法还能指定最大分隔次数方法可用来连接序列中的元素并在两个元素之间插入指定字符返回一个字符串方法是方法的逆方法用空格分割用空格接上运行运行格式功能查找字符串中子串并用子串来替换参数默认值为表示替换所有匹配项否则为其他值时最多替换次返回替换后的新字符串原字符串不变中国北京北京地铁地铁沿线北京沿线城市北京指定最大替换次数运行运行生成字符映射表根据字符映射表替换字符这两种方法联合起来使用可以一次替换多个字符两个序列中的元素按照次序一一对应用于替换运行运行去除字符串两侧的空白字符空格回车制表符等或指定字符并返回新字符串从两端逐一去除或字符直到不是这两个字符为止中间的字符不能去除运行运行字符串模块字符串模块定义了类类函数和常量熟悉模块可以简化某些字符串的操作请输入英文单词用空格分隔用到了函数单词首字母大写运行运行说明这种方法直接用到模块中的常量和模块中方法方法的功能是在一个非空的序列中随机选择一个元素运行运行正则表达式正则表达式的元字符正则表达式模式串中的字符根据作用不同分为两类普通字符大多数字母和字符一般都会和自身匹配元字符有些字符比较特殊它们和自身并不匹配而是表明应和一些特殊的东西匹配或者会影响重复次数因为在模式串中常常有特殊字符为了书写方便在字符串前加前缀不对其进行转义第一种情况模式串中全部是普通字符导入模块模式串中全部是普通字符无匹配两处匹配查找到两个运行运行第二种情况模式串中含有元字符常用的元字符表示任意单个字符除换行符以外在中匹配所有的运行运行三引号字符串中可以有换行符本结果中没有匹配两个换行符匹配后面跟除换行符以外的任意字符的形式必须是两个字符第一个是第个是换行符以外的任意字符可以是空白符指定字符集用来指定一个字符集合例如从字符集合中必须选一个也只能选一个字符即单个字符有些元字符在方括号中不起作用作为普通字符例如和中元字符都不起作用方括号内的表示补集匹配不在区间范围内的字符例如表示除以外的字符匹配后跟或者再跟形式查找个字符第字符必须是第字符必须是中间字符只能是中的一个运行运行匹配行首匹配每行中以后面的字符开头的字符串必须放在模式串的开头英文称为英语发音记忆法数学上读作帽子戴头上可以形象的想象成首部匹配模式默认只匹配多行字符串的首行多行匹配需要单独设置参数匹配行尾匹配每行中以匹配行尾匹配每行中以匹配行尾匹配每行中以之前的字符结束的字符串英语读作音标记忆法可以形象的想象成弯曲的尾巴行尾匹配模式默认只匹配多行字符串的末行多行匹配需要单独设置参数反斜杠后面可以加不同的字符以表示不同的特殊意义四对匹配单词头或单词尾放前面会匹配单词头放后面会匹配单词尾相当于或但这两个只能用于整个字符串不能切分单词与相反匹配非单词头或单词尾不查找单词头或单词尾只查其他部分匹配任何数字字符相当于与相反匹配任何非数字字符相当于匹配任何空白字符相当于与相反匹配任何非空白字符相当于是制表符是换页符是垂直制表符匹配任何字母数字或下画线字符相当于与相反匹配任何非字母数字和下画线字符相当于也可以用于取消所有的元字符这些特殊字符都可以包含在中如将匹配任何空白字符或第一对和字符串中切分单词的分隔符包括空格换行制表符各种标点符号单词头单词尾注意不是整个字符串而是分隔后的每个单词和相反不查开头结尾的只查其他部分的第二对与数字字符等同于和相反等同于非数字字符第三对与匹配查找任何空白字符相当于横向制表符换行回车换页符纵向制表符和相反不匹配查找任何空白字符相当于与区别表示任意单个字符换行符除外表示任意单个字符空白符除外注意是大写的第四对与匹配任何字母数字或下画线字符相当于和相反不匹配任何字母数字或下画线字符相当于第五点用取消元字符此时的就是元字符匹配查找任意字符此时的就是普通的字符匹配查找第六点也可以用在内以上类元字符都是表示单个字符任意单个字符换行符除外集合中的任意单个字符行首行尾量词正则表达式能指定正则表达式的一部分的重复次数用到的元字符有").trim().substring(0, num)

      const queryParams = `key=${options.key}&content=${truncateDescription}`;
      const requestOptions = {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Referer: options.Referer
        },
      };
      try {
        let animationInterval = null
        if (animationInterval) clearInterval(animationInterval);
        animationInterval = setInterval(() => {
          const animationText = "生成中" + ".".repeat(j);
          explanation.innerHTML = animationText;
          j = (j % 3) + 1; // 在 1、2、3 之间循环
        }, 500);
        const response = await fetch(`https://summary.tianli0.top/?${queryParams}`, requestOptions);
        const result = await response.json();
        const summary = result.summary.trim();
        setTimeout(() => {
          aiTitleRefreshIcon.style.opacity = "1";
        }, 300)
        startAI(summary);
        clearInterval(animationInterval)

      } catch (error) {
        console.error(error);
        explanation.innerHTML = "发生异常" + error;
      }
    } else {
      const strArr = "true".split(",").map(item => item.trim()); // 将字符串转换为数组，去除每个字符串前后的空格
      if (strArr.length !== 1) {
        let randomIndex = Math.floor(Math.random() * strArr.length); // 随机生成一个索引
        while (randomIndex === lastAiRandomIndex) { // 如果随机到了上次的索引
          randomIndex = Math.floor(Math.random() * strArr.length); // 再次随机
        }
        lastAiRandomIndex = randomIndex; // 更新上次随机到的索引
        startAI(strArr[randomIndex]);
      } else {
        startAI(strArr[0])
      }
      setTimeout(() => {
        aiTitleRefreshIcon.style.opacity = "1";
      }, 600)
    }
  }

  function aiRecommend() {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    explanation.innerHTML = "生成中. . .";
    ai_str = "";
    ai_str_length = "";
    observer.disconnect(); // 暂停上一次监听
    sto[2] = setTimeout(() => {
      explanation.innerHTML = recommendList();
    }, 600);
  }
  function aiGoHome() {
    startAI("正在前往博客主页...", false);
    sto[2] = setTimeout(() => {
      pjax.loadUrl("/");
    }, 1000);
  }
  const ai_btn_item = document.querySelectorAll(".ai-btn-item");
  function Introduce() {
    if (mode == "tianli") {
      startAI("我是文章辅助AI: TianliGPT，点击下方的按钮，让我生成本文简介、推荐相关文章等。")
    } else {
      startAI("我是文章辅助AI: AnZhiYu GPT，点击下方的按钮，让我生成本文简介、推荐相关文章等。")
    }
  }
  function aiTitleRefreshIconClick() {
    aiTitleRefreshIcon.click()
  }
  const aiFunctions = [Introduce, aiTitleRefreshIconClick, aiRecommend, aiGoHome];
  ai_btn_item.forEach((item, index) => {
    item.addEventListener("click", () => {
      aiFunctions[index]();
    });
  });

  function recommendList() {
    let thumbnail = document.querySelectorAll('.relatedPosts-list a');
    if (!thumbnail.length) {
      const cardRecentPost = document.querySelector('.card-widget.card-recent-post'); 
      if (!cardRecentPost) return '';

      thumbnail = cardRecentPost.querySelectorAll('.aside-list-item a');

      let list = '';
      for (let i = 0; i < thumbnail.length; i++) {
        const item = thumbnail[i];
        list += `<div class="ai-recommend-item"><span class="index">${i + 1}：</span><a href="javascript:;" onclick="pjax.loadUrl('${item.href}')" title="${item.title}" data-pjax-state="">${item.title}</a></div>`;
      }
      
      return `很抱歉，无法找到类似的文章，你也可以看看本站最新发布的文章：<br /><div class="ai-recommend">${list}</div>`;
    }

    let list = '';
    for (let i = 0; i < thumbnail.length; i++) {
      const item = thumbnail[i];
      list += `<div class="ai-recommend-item"><span>推荐${i + 1}：</span><a href="javascript:;" onclick="pjax.loadUrl('${item.href}')" title="${item.title}" data-pjax-state="">${item.title}</a></div>`;
    }

    return `推荐文章：<br /><div class="ai-recommend">${list}</div>`;
  }


  function changeShowMode() {
    if (mode === "tianli") {
      mode = "local";
      document.getElementById("ai-tag").innerHTML = "AnZhiYu GPT";
      aiAbstract(1000);
    } else {
      mode = "tianli";
      document.getElementById("ai-tag").innerHTML = "Tianli GPT";

      const truncateDescription = ("" + "一、前言, 二、语言基础, 2.1标识符, 1.2.1标识符, 1.2.2关键字, 2.1.3变量, 2.2数据类型, 1.整型int, 2.浮点数float, 3.复数complex, 4.布尔bool, 5.字符串str, 6.列表 list, 7.元组 tuple, 8.字典 dict, 9.集合 set, 2.3赋值语句、运算符, 2.3.1赋值语句的格式, 2.3.2运算符, 1.算数运算符, 2.关系运算符, 3.测试运算符, 4.逻辑运算符, 2.4从控制台输入和输出, 1. input()函数, 2.类型转换函数, 3.数据的输出, 2.5内置函数, 三、流程控制, 3.1分支结构, 3.2循环结构, 3.2.1for循环语句, 3.2.2 break语句和continue语句, 3.2.3 带else的循环语句（与C语言不同不建议用）, 3.2.4循环嵌套, 四、常用数据结构, 4.1 序列, 4.1.1列表 list, 1.列表的创建, 2.列表的元素访问, 3.修改元素, 4.列表切片, 5. del命令, 7.列表方法：类型本身的方法, 9.列表遍历, 4.1.2元组, 1.元组的创建, 2.元组的访问, 4.1.3 列表与元组的转换, 1.列表–gt元组, 2.元组–gt列表, 4.2 字典, 4.2.1 创建字典, 4.2.2 字典操作, 1.字典中键-值对的数量, 2.查找与特定键相关联的值：键—gt值, 3.修改字典中的数据, 4.删除字典条目, 4.2.3 字典方法, 1.keys()、values(), 2.items(), 3.setdefault(), 4.update(), 5.clear(), 6.pop(), 7.popitem(), 8.get(), 4.2.4遍历字典, 1.遍历字典的key, 2.遍历字典的值Value, 3.遍历字典的键值对, 4.2.5列表、元组、字典的转换, 1.列表与字典之间的转化：字典–gt列表, 2.元组与字典之间的转化：字典–gt元组, 4.3 集合 Set, 4.3.1 集合的创建, 4.3.2 集合的运算, 1.len() 、max()、min()、sum(), 2.in, 3.并集、交集, 4.差集, 5.对称差, 6.子集和超集, 4.3.3 集合的方法, 1.union()、intersection(), 2.update(), 3.difference(), 4.symmetric_difference(), 5.issubset()和issuperset(), 6.add(), 7.remove(), 8.discard(), 9.pop(), 10.clear(), 4.4 可迭代对象Iterable 与 迭代器Iterator, 4.4.1 可迭代(Iterable)对象, 4.4.2 相关内置函数, 4.5 推导式, 4.5.1 列表推导式, 4.5.2 字典推导式, 4.5.3 集合推导式, 4.5.4 生成器推导式, 五、字符串, 5.1 字符串的编码, 5.2 字符串的构建, 5.3 字符串格式化, 5.4 字符串截取, 5.5 字符串常用内置函数, 5.6字符串常用方法, 5.7 字符串string模块, 5.8正则表达式一前言这是哪托针对老师的课件整理的复习笔记基础入门希望能对广大基础小白受用内容如有错误的地方劳请留言指正笔记所有代码使用的插件编译二语言基础标识符标识符标识符可以包括英文数字以及下划线并且开头必须是字母或下划线不能以数字开头开头区分大小写的不能出现分隔符标点符号或者运算符不能使用关键字等最好不要使用内置模块名类型名函数名已经导入的模块及其成员名合法的标识符连续两个下画线等非法的标识符中间用了空格关键字等关键字关键字是一个特殊的对象不是不是也不是空字符串空列表等有自己的数据类型和任何其他数据类型进行是否相等比较永远返回可以将赋值给任何变量但是不能创建其他对象变量变量与与语言相比相同点用于储存计算结果或能表示值可以通过变量名访问变量值通常是可变的变量具有名字不同变量是通过名字相互区分的不同点变量的数据类型不需要声明变量的数据类型可以变化是动态类型语言变量使用之前必须赋值常量没有常量即没有语法规则限制改变一个常量的值怎么办呢使用人为约定通常用全大写字母表示常量编程时不要修改它的值常量示例你喜欢我吗运行运行数据类型整型整数没有小数部分的数值分为正整数和负整数十进制二进制八进制十六进制浮点数浮点数包含小数点的数科学计数法运行运行复数复数由两部分组成实部和虚部复数的形式为实部虚部都是复数复数的实部复数的虚部运行运行两个注意点支持任意大的数字仅受内存大小的限制所以在使用时不用考虑的范围为了提高可读性在数值中可以使用下画线布尔布尔类型是用来表示逻辑是非的一种类型它只有两个值和首字母和是大写的将布尔值实现为类型实现为所以可以参与整型运算但不建议这么做字符串语言中的字符串是一种序列字符串用单引号双引号三引号作为定界符等列表列表也是一种序列类型列表用方括号和将列表中的元素括起来元素之间以逗号进行分隔和元组元组也是一种序列元组用和作为边界将元素括起来元素之间以逗号分隔和字典字典是唯一内建的映射类型可用来实现通过数据查找关联数据的功能字典是键值对的无序集合字典中的每一个元素都包含两部分键和值字典用大括号和来表示每个元素的键和值用冒号分隔元素之间用逗号分隔张三徐虎张林集合集合是由各种不可变类型的元素组成但元素之间无序并且元素都不重复赋值语句运算符赋值语句的格式变量表达式常规同特殊多变量赋值两变量的交换运行运行运算符算数运算符在中算术运算符有加减乘真除法求整商取模幂需要说明的几点运算符不支持不同类型的对象之间的连接错误不同类型正确通过类型转换函数将数字转换成字符串运算符可以用于列表元组或字符串与整数的相乘用于将这些序列重复整数所指定的次数它不适用于字典和集合与整数的相乘列表元组字符串字典不可以因为字典的键不能重复运算符幂运算与内置函数相同真除法与整数除法真除取商的整数部分操作数为实数时则取实数形式的整数即运行运行关系运算符六个小于小于等于大于大于等于等于不等于结果布尔值或所有的字符串都是字符串单个字符可以通过函数获取该字符的码通过函数把编码转换为对应的字符得到对应的字符我我运行运行注意字符串和数字属于不可比较大小的列表比较大小也是从左到右逐个元素的依次比较类似字符串之间的比较列表中字符串与数值也是不能比较的出错出错关系运算符可以连用等价于某几个用连接起来的表达式注意语言和语言均不可这么用与下式含义相同与下式含义相同运行运行因为精度问题可能导致实数运算有一定的误差要尽可能地避免在实数之间进行相等性判断有误差了误差导致不相等解决方法使用实数之间的差值的绝对值是否小于某一个很小的数来作为实数之间是否相等的判断表示和是相等的运行运行测试运算符四个结果返回布尔值或列表测试字符串虽然内容一样但不是同一个对象运行运行同一性测试运算符和测试是否为同一个对象或内存地址是否相同返回布尔值和测试是否为同一个对象相等但不是同一个对象测试是否相等运行运行注意是否相等只是测试值是否相同是否为同一个对象指的是是否指向同一个对象如果指向同一个对象则内存地址应该相同当然也相等内置函数返回对象的标识内存地址每个人运行得到的内存地址可能会不一样赋值语句则和不仅值相等而且指向同一个对象的内存地址相同逻辑运算符在中逻辑运算符有与或非通过逻辑运算符可以将任意表达式连接在一起哪些是数值类型中的空字符串空元组空列表空字典空集合等非零值为零值为运行运行逻辑操作符和也称作短路操作符具有惰性求值的特点短路运算表达式从左向右解析一旦结果可以确定就停止注意逻辑运算符不一定会返回布尔值和与运算结果不一定为或当计算表达式时先计算的值当的值为或非空值非非值非空的其他数据类型才计算并输出的值当的值为或空值值为空的其他数据类型直接输出的值不再计算第一个为则输出第二个的值结果与第二个值有关下同的值为则计算并输出的值第一个为则不再计算第二个的值直接输出第一个的值下同直接输出直接输出运行运行或运算结果不一定为或当计算表达式时先计算的值当的值为或非空值非非值非空的其他数据类型直接输出的值不再计算当的值为或空值值为空的其他数据类型才计算并输出的值第一个为则不再计算第二个的值直接输出第一个的值下同的值为则直接输出第一个为则继续计算第二个的值输出第二个的值下同运行运行赋值运算符复合赋值运算符位运算符等等此处基本同语言特别注意没有自加与自减优先级小括号最高从控制台输入和输出函数用于输入数据无论用户输入什么内容该函数都返回字符串类型其格式如下表示提示语默认为空请输入值请输入值查看的类型为运行运行类型转换函数函数格式功能截取数字的整数部分或将字符串转换成一个整数如果不给定参数则返回没有参数时浮点数直接截取整数部分不进行四舍五入整数字符串浮点数字符串错误注意函数不接受带小数的数字字符串格式功能把进制的字符串转换为十进制为基数进制默认为十进制的有效值范围为和二进制的数转换为十进制数十六进制的数转换为十进制数八进制的数转换为十进制数不允许二进制的小数不接受带小数的数字二进制的数转换为十进制数函数格式功能将一个数字或字符串转换成浮点数默认参数为无穷大不区分大小写错误错误不能转换表达式字符串所以引入函数函数格式功能将字符串当做一个表达式进行解析和计算返回计算结果参数说明是一个字符串这个字符串能表示成表达式或者是能够通过编译的代码是可选的参数默认为如果设置属性不为的话就必须是对象也是可选的参数默认为如果设置属性不为的话可以是任何对象字符串中是表达式返回表达式的值字符串中是列表元组或字典得到真正的列表元组或字典字符串中是能够通过编译的代码执行代码表达式返回列表返回字典执行语句执行语句获取当前目录组合使用函数和请输入值输入列表格式获得列表请输入值输入字典格式获得字典数据的输出函数格式如下各参数的解释如下需要输出的对象一次可以输出一个或者多个对象其中表示任意多个对象对象之间要用逗号分隔对象之间的间隔符默认用一个空格分隔以何字符结尾默认值是换行符表示输出位置可将输出到文件指定的对象要有写的方法默认值是标准输出即控制台屏幕将缓存里面的内容是否强制刷新输出默认值是一般不需要一次输出三个对象中间默认用空格隔开一次输出三个对象中间用隔开一次输出三个对象中间无分隔因为参数值被设置为空字符串了一次输出三个对象以结尾不换行一次输出三个对象以分隔以结尾运行运行可以看出函数默认输出是换行的如果要实现不换行需要在变量末尾设置参数内置函数函数功能返回数字的绝对值如果给出复数返回值就是该复数的模把整数转换为二进制函数返回整商和余数的元组计算字符串中表达式的值并返回返回对象的帮助信息返回对象的标识内存地址接受键盘输入显示提示信息返回字符串返回对象列表元组字典字符串集合对象的元素个数包含若干函数值的对象其中表示函数表示迭代对象将函数作用于迭代对象返回给定参数的最大值最小值参数可以为可迭代对象函数返回以为底为指数的幂如果给出值该函数就计算的次幂值被取模的值输出对象默认输出到屏幕相邻数据之间使用空格分隔结尾以换行符结束返回对象该对象包含按参数范围内为步长生成的整数返回浮点数的四舍五入值若不给出值则返回整数给出值则代表舍入到小数点后的位数返回排序后的列表其中表示要排序的序列或迭代对象表示排序规则表示升序或降序默认升序返回序列中所有元素之和如果指定起始值则返回如果为空则返回返回编码为所对应的字符把字符串或数字转换为复数如果第个参数是字符串不能使用第个参数把一个数字或字符串转换成浮点数把整数转换成十六进制串把数字和字符串转换成一个整数或把进制的字符串转换为十进制为可选的基数默认为十进制将对象转换成列表元组字典集合或生成空列表空元组空字典空集合把给出的整数转换成八进制串返回一个字符的编码三流程控制分支结构单分支语句双分支语句多分支语句选择结构的嵌套选择结构的三元运算注意没有语句语法类似于此处省略循环结构定义给定的判断条件为真包括非零非空时重复执行某些操作判断条件为假包括零空时结束循环循环分类语句语句循环中断带的循环语句特有与类似相关内容请参考循环语句语句通过遍历一个序列字符串列表元组或迭代器等可迭代对象中的每个元素来建立循环语句的语法形式如下所示变量序列或迭代器等可迭代对象循环体补充函数返回可迭代对象语法格式如下功能产生一个从开始包括默认为到结束不包括两个整数对象之间间隔默认为的可迭代对象可以用循环直接遍历函数产生的可迭代对象默认运行运行对象可以被转换成列表或元组例如对象转换为列表对象对象转换为元组对象语句和语句详细解释语句可以用在和循环中在循环进行过程中如果某个条件被满足一般通过语句判断是否满足执行语句的条件则可以通过语句立即终止本层循环如果语句在具有两层循环嵌套的内层循环中则只终止内层循环进入到外层循环的下一条语句继续执行语句可以用在和循环中在循环体执行过程中如果遇到语句程序会跳过本次循环的循环体剩余语句回到循环开始的地方重新判断是否进入下一次循环精简语句终止整个当前循环语句的执行不会终止整个当前循环只是提前结束本次循环跳过循环体中本次循环的剩余语句提前进入到下一次循环再精简同语言带的循环语句与语言不同不建议用中的和语句后面还可以带有语句块语句语法如下条件表达式循环体语句块三种执行流程正常循环当条件表达式为真非空非零时反复执行循环体执行一次当条件表达式为假零空而导致循环终止或无法进入循环语句块执行一次然后结束该循环结构不执行如果该循环是因为执行了循环体中的语句而导致循环终止语句块不会执行直接结束该循环结构例从键盘输入一个正整数用循环找出小于等于该整数且能被整除的最大正整数如果找到了输出该整数如果没有找到则输出未找到请输入一个正整数小于等于且能被整除的最大正整数是未找到运行运行带的语句语法如下变量序列或迭代器等可迭代对象循环体语句块循环嵌套四常用数据结构序列列表列表是中最基本的数据结构是最常用的数据类型列表的特点列表将由若干数据作为元素的序列放置在一对方括号中元素之间以逗号分隔列表中的元素允许重复列表是可以修改的增删改查以上类似数组列表元素可以由任意类型的数据构成同一列表中各元素的类型可以各不相同不同于数组列表的操作汇总创建列表访问元素更改元素值切片形式列表计算列表列表列表整数列表方法查增删序序列函数不仅仅用于列表命令列表列表的创建创建一维列表方式普通列表方式创建空列表函数创建二维列表运行运行列表的元素访问索引列表中的每个元素被关联一个序号即元素的位置索引值是从开始第二个则是以此类推从左向右逐渐变大列表也可以从后往前索引值从开始从右向左逐渐变小适用于所有序列类型的对象列表元组字符串修改元素通过重新赋值来更改某个元素的值注意合法索引范围超过范围则会出错列表切片在列表中可以使用切片操作来选取指定位置上的元素组成新的列表简单的切片方式为步长默认为原列表名左封闭能取到右开放取不到左索引为时可缺省右索引为列表长度时可缺省取第号元素缺省为缺省为列表长度长度从开始计算都缺省全列表等于时空列表运行运行也可以使用负数作索引索引为和位置上的元素依然是从左往右取索引从至列表末尾位置上的元素运行运行切片步长非零整数即可正可负但不能为跳着切片原列表名步长为时参数可以省略步长不为时该参数不可省略函数为的可迭代对象用函数转换为从到的列表步长为索引值从开始每次增长但索引值必须小于步长为负数时不能小于值超过范围实际索引从最后一个元素开始不出错这里步长为负数表示在整个列表内从后往前取值作用逆序运行运行利用切片还可以更改元素值有点类似多变量赋值的感觉分别更改索引号为和的位置上元素值分别更改索引号为三个位置上的元素值少给个数呢少的那个数被删掉了命令注意是命令不是函数或方法从列表中删除元素也可以删除整个列表删除了删除列表列表不存在了再次使用出错补充方法函数命令的概念上的区别命令内置命令没有括号函数是指内置函数或用导入的某模块的函数直接可以使用比如方法是指某个对象的方法格式为对象名方法名比如是指列表对象的方法列表运算列表相加通过列表相加的方法生成新列表支持复合赋值结果为新列表原列表不变复合赋值语句不支持减运算出错列表乘法列表整数生成一个新列表新列表原来列表的元素重复次相乘语句复合赋值语句相当于重新定义了列表运行运行列表方法类型本身的方法返回第一个值元素索引位置没指定则从索引为的位置开始查找否则从索引为的位置开始查找没指定可以查找到列表最后元素否则在位于内的索引区间查找如果找不到匹配项就会引发异常整个列表范围内第次出现的索引位置是在从索引为开始第次出现的索引位置是运行运行统计某个元素在列表中出现的次数追加单个元素到列表的尾部只接受一个元素元素可以是任何数据类型被追加的元素在列表中保持着原结构类型在列表的末尾一次性追加另一个列表中的多个值只能有一个参数应用用新列表扩展原有的列表将一个元素插入到指定位置两个参数第一个参数是索引点即插入的位置第二个参数是插入的元素插入后在位置注意插入后的位置在位置的前面运行运行用于移除列表中与某值匹配的第一个元素如果找不到匹配项就会引发异常移除列表中的一个元素默认为最后一个元素并且返回该元素的值出栈可以指定索引位置当不在索引范围内或者是空列表中均会触发异常删除列表中所有元素但保留列表对象请注意与命令的区别命令删除整个列表时列表对象不再保留方法用于将列表中的元素位置反向存放列表中可以有不同类型的元素方法只是将位置反转元素排序默认按升序排列两个参数参数默认为升序若等于表示降序排序如果包含的是字符串按字符串排序规则参数指定排序方式按数值大小升序降序按转换为字符串后的大小升序排列码排序的元素必须是可比较大小字符串和数值不能比较列表函数不单单用于列表的函数也可用于其他数据结构列表遍历通过语句或者语句循环遍历所有元素直接遍历每一个元素循环通过索引遍历每一个元素运行运行元组元组和列表十分相似元组是用一对圆括号括起用逗号分隔的多个元素的组合属于序列有顺序可以重复元组是不可更改的是不可变对象元组创建之后就不能修改添加删除成员元组的上述特点使得其在处理数据时效率较高而且可以防止出现误修改操作元组的创建创建多个元素的元组创建单一元素的元组后面的逗号不能省略省略后就变成字符串类型了创建空元组使用函数创建空元组运行运行元组的访问和列表一样可以通过索引访问单个切片访问多个来访问元组的成员索引方式切片方式元组不能更改元素值不能赋值报错元组的运算元组相加通过元组相加的方法生成新元组正确重新定义了运行运行元组相乘用数字乘以一个元组会生成一个新元组在新元组中原来的元组元素将依次被重复次运行运行元组的遍历通过语句或者语句同列表方法列表与元组的转换列表元组函数接受一个列表并返回一个包含同样元素的元组从结果上看函数冻结了列表元组运行运行元组列表函数接受一个元组并返回一个包含同样元素的列表从结果上看函数融化了元组运行运行字典字典是中唯一内建的映射类型用一对花括号和作为边界元素之间以逗号分隔每个元素是一对键和值键和值之间用英文冒号分隔映射可通过数据查找关联数据无序字典的元素没有顺序因此不能像序列那样通过位置索引来查找成员数据但是每一个值都有一个对应的键不重复字典的键是不重复的用法通过键来访问相应的值值是可以重复的创建字典创建创建需注意键外面不能加引号列表元组由序列构建对象由对象创建字典以给定序列元组或者列表为键创建值为空的字典创建空字典无参的函数运行运行键必须是不可修改类型的数据如数值字符串和元组等列表是可变的不能作为字典的键键对应的值可以是任何类型的数据字典是无序集合字典的显示次序由字典在内部的存储结构决定字典操作字典中键值对的数量返回字典中项键值对的数量运行运行查找与特定键相关联的值键值运行运行修改字典中的数据在字典中某个键相关联的值可以通过赋值语句来修改如果指定的键不存在则相当于向字典中添加新的键值对有则修改无则添加运行运行删除字典条目命令用来删除字典条目或者整个字典键存在删除整个检查字典中是否含有某键的项命令查找某键值是否在字典中如果存在返回否则返回字典方法方法将字典中的键以可迭代的对象返回方法将字典中的值以可迭代的对象形式返回转换成列表转换成元组运行运行将字典中的所有键和值以可迭代的对象返回每对键值对组成元组作为一个元素转换成列表转换成元组运行运行使用时如果字典中包含参数对应的键则返回该键对应的值否则以参数的值为键以参数的值为该键对应的值在字典中插入键值对元素并返回该元素的值部存在这个键返回对应的值控制单元存在这个键默认值和原有的值不一样返回对应的原值有则修改不存在这个键插入新的键值对和之前比较无则添加不存在这个键也未指定新值运行运行将另一个字典中的所有键值对一次性地添加到当前字典中如果两个字典中存在有相同的键则以另一个字典中的值更新当前字典方法将字典中的所有条目删除变成空字典方法能够弹出并删除字典中的键值对返回键为的值并在字典中删除该键值对方法能够弹出字典的一个元素如果字典为空则触发异常返回指定键所对应的值如果键不存在则返回默认值默认值为也可以自己指定遍历字典遍历字典的默认遍历字典的键和上面相同遍历字典的值遍历字典的键值对列表元组字典的转换列表与字典之间的转化字典列表中的函数可以将字典转换列表但列表不能转换为字典默认将键转化为列表键值键值对元组与字典之间的转化字典元组中的函数可以将字典转换元组但元组不能转换为字典默认将键转化为元组键值键值对集合集合是一组用括起来的无序不重复元素元素之间用逗号分隔元素可以是各种类型的不可变对象集合想象成只有没有值的字典集合的创建集合类型的值有两种创建方式用一对花括号将多个元素括起来元素之间用逗号分隔函数将字符串列表元组等类型的数据转换为集合类型直接赋值函数注意空集合只能用来创建而不能用空的花括号表示因为已将空用于表示空字典无参的函数空集合运行运行集合中没有相同的元素因此创建集合时会自动删除掉重复的元素利用这一点可以快速去重集合的运算返回集合中元素的个数生成排序后的列表集合本身无序不能反序集合本身无序判断某元素是否存在于集合之中判断结果用布尔值或表示并集交集并集创建一个新的集合该集合包含两个集合中的所有元素交集创建一个新的集合该集合为两个集合中的公共部分并集交集运行运行差集表示集合与的差集返回由出现在集合中但不出现在集合中的元素所构成的集合对称差返回由两个集合中那些不重叠的元素所构成的集合子集和超集子集如果集合的每个元素都是集合中的元素则集合是集合的子集超集超集是仅当集合是集合的一个子集集合才是集合的一个超集检测是否是的子集检测是否是的真子集检测是否是的超集检测是否是的真超集以上结果只返回或将的元素并入中集合的方法同样以面向对象方式实现集合类型的运算方法相当于并集运算方法相当于交集运算并集新的集合未发生改变未发生改变交集产生新集合运行运行方法相当于集合元素合并运算注意与方法的区别发生了改变相当于差集运算新集合原集合没有变化相当于对称差运算结果相同和方法判断是否子集方法判断是否超集是向集合中添加元素重复元素只保留一个是从集合中删除元素如果集合中没有该元素则出错作用是从集合中删除元素如果集合中没有该元素也不提示出错方法的作用是从集合中删除任一元素并返回该元素如果集合为空则抛出异常从集合中删除所有元素变成一个空集合可迭代对象与迭代器简单解释可迭代对象是存放元素的容器可以被遍历其中的元素类比链表迭代器由可迭代对象容器提供的因为只有该容器知道怎么遍历它的每一个元素用于遍历容器元素的一个工具类比链表的遍历指针可迭代对象列表元组字符串字典可以用进行遍历表面只要可以用进行遍历的对象就是可迭代对象那么列表元组字符串字典都是可迭代对象本质如果一个对象实现了方法那么这个对象就是可迭代对象方法查看对象的方法是否有方法类似于中查看某一个类可实现的方法运行运行方法可以通过调用内置函数来判断一个对象是否属于可迭代对象列表是可迭代对象吗数值是可迭代对象吗不是运行运行迭代器实现了方法和方法并且可以通过方法不断返回下一个值的对象迭代器还可以通过内置函数访问下一个元素可以通过调用内置函数来判断一个对象是否属于迭代器列表是迭代器吗列表是迭代器吗字典是迭代器吗集合是迭代器吗字符串是迭代器吗函数生成的数列是迭代器吗数值是迭代器吗以上对象均不能成为迭代器注意迭代器和可迭代对象不同运行运行可迭代对象容器迭代器迭代工具虽然列表元组字符串字典集合都是可迭代对象而不是迭代器但可以通过函数获得一个迭代器列表取的迭代器自带方法返回下一个值也可以用内置函数函数没有下一个元素了触发异常内置函数访问下一个值同样异常运行运行相关内置函数枚举组合映射逐个计算过滤挑选共同点这四个函数都会返回一个特定对象它们都既是迭代器也是可迭代对象枚举格式功能返回下标和值的对象参数第个参数表示可迭代对象第个参数表示下标的开始值默认从开始通俗将容器的每个元素取出来搭配一个下标对象既是对象容器也是对象容器的遍历工具列表用其他容器也可以取得的枚举器迭代器可以使用语句也可以使用函数也可以使用方法将剩余的对象元素转换为列表对象转换为元组下标从开始返回下一个值遍历对象中的元素遍历对象元素的下标和值对象转换为字典枚举号转为枚举值转为对象转换为集合格式功能将多个迭代器对象或者可迭代对象中的元素压缩到一起返回一个对象通俗将多个容器的逐个对应元素拼合在一起同样对象既是一个可迭代对象也是一个迭代器对象只有一个参数字符串容器每个元素是元组有两个参数有两个容器作为参数对象是可迭代对象容器可以使用运算第二个参数是枚举也是容器不同长短时匹配短的更多参数更多容器格式功能把一个函数依次映射到可迭代对象的每个元素上返回一个对象通俗将每个元素传入函数把结果放入里对象既是一个可迭代对象也是一个迭代器对象将每个元素变为类型将改为字符串定义一个函数中的每个元素都执行一次函数结果放入运行运行格式函数名可迭代对象功能把一个带有一个参数的函数作用到一个可迭代对象上返回一个对象对象中的元素由可迭代对象中使得函数返回值为的那些元素组成如果指定函数为则返回可迭代对象中等价于的元素通俗将容器中的元素用函数过滤挑选一下对象既是一个可迭代对象也是一个迭代器对象只保留满足条件的元素用法函数定义函数为奇数返回否则返回将中的每个元素作为参数带入将返回值为的元素保留下来是一个对象用法函数匿名函数不用单独定义函数了用法指定函数为函数就不起作用了就看元素本身是否为运行运行推导式利用列表推导式字典推导式集合推导式可以从一个数据对象构建另一个新的数据对象利用生成器推导式可以构建生成器对象语法糖列表推导式列表推导式是开发时用得最多的技术之一表示对可迭代对象的元素进行遍历过滤或再次计算生成满足条件的新列表它的结构是在一个方括号里包含一个函数或表达式再次计算接着是一个语句遍历然后是个或多个遍历或者语句过滤在逻辑上等价于循环语句但是形式上更简洁语法形式函数表达式值可迭代对象条件值可迭代对象条件值可迭代对象条件列表推导式和循环语句如果要将一个列表中的元素均扩大倍组成新列表列表推导式运行运行两点利用列表推导式更加简洁由于内部对列表推导式做了大量优化还能保证较快的运行速度循环可以嵌套列表推导式中也可以有多个语句如果要将一个一层嵌套数字列表中的元素展开后扩大倍组成新列表一层嵌套列表常规写法每一行行中的每一列列表推导式运行运行列表推导式和条件语句在列表推导式中条件语句对可迭代对象中的元素进行筛选起到过滤的作用接着上面的例子如果是将一个数字列表中的是正数的元素扩大倍组成新列表运行运行另外在列表推导式中还可以使用语句将一个数字列表中的正偶数扩大倍正奇数扩大倍组成新列表运行运行列表推导式和函数在列表推导式中可以使用函数利用列表推导式快速生成包含个包含之间的随机整数列表使用函数对中的元素如果被整除则该数除以如果被整除则该数扩大倍其他的数扩大倍这些数组成新列表使用自定义的函数运行运行同时遍历多个列表或可迭代对象有两个成绩列表和将中分数及以上和中分数及以下的元素两两分别组成元组将这些元组组成列表中的元素运行运行字典推导式字典推导式和列表推导式的使用方法类似将方括号变成花括号需要两个表达式一个生成键一个生成值两个表达式之间使用冒号分隔最后生成的是字典语法形式函数表达式值可迭代对象条件值可迭代对象条件值可迭代对象条件列表存储若干人的名字唯一列表在对应的位置上存储这些人的成绩利用字典推导式以名字为键成绩为值组成新字典以名字为键成绩为值组成新字典新字典中的键值对只包含成绩及以上的增加一个以名字为键名字的长度为值组成新字典运行运行集合推导式集合也有自己的推导式跟列表推导式类似只不过将方括号变成花括号最后生成的是集合语法形式函数表达式值可迭代对象条件值可迭代对象条件值可迭代对象条件运行运行不难发现构建和的时候除了方括号和花括号不同以外其他语法均相同生成一个列表里面的元素是元组中每个元素的倍而且元素位置一一对应生成一个集合里面的元素是元组中每个元素的倍去掉重复元素后的结果并且并非与元组的元素位置一一对应需要说明的是元组没有推导式生成器推导式生成器推导式用法与列表推导式类似把列表推导式的方括号改成圆括号它与列表推导式最大的区别是生成器推导式的结果是一个生成器对象是一种迭代器而列表推导式的结果是一个列表生成器对象可以通过循环或者方法函数进行遍历也可以转换为列表或元组但是不支持使用下标访问元素已经访问过的元素也不支持再次访问当所有元素访问结束之后如果想再次访问就必须重新创建该生成器对象生成器对象转换为列表不能再次访问访问下一个元素循环遍历五字符串字符串的编码码标准码为位编码包括英文字母数字标点符号等个字符用个字节存储最高位为扩展码个字节存储最高位为编码把所有语言统一到一套编码里采用个字节或个字节生僻字符的编码缺点全部是英文的话比码多用一倍存储空间编码可变长编码英文字符用个字节兼容码中文字符用个字节其他语言也有用或个字节等中文编码一般用个字节支持两种类型字符串类型支持编码和类型而且类型和类型可以相互转换可以转换为类型转换为类型除此之外其他方法都一样我类型编码编码成类型编码格式进制个字节位进制数用位进制数表示编码成类型编码格式进制个字节解码目前是编码的字符串使用进行解码目前是编码的字符串使用进行解码我是类型字符串中文字符串不能以编码英文字符串可以以编码也可以使用和完成两种类型的相互转换阳光用编码转换用编码转换个字节用编码转换类型是用转换来的阳光个字节结果有误运行运行完全支持中文字符解析器默认采用解析源程序无论是数字字符英文字母汉字都按一个字符来对待和处理字符串的构建在中字符串的构建主要通过两种方法来实现一是使用函数二是用单引号双引号或三引号单引号或双引号构造字符串要求引号成对出现合法如不合法字符串本身有单引号或双引号时字符串包含了单引号且不用转义字符整个字符串就要用双引号来构造字符串包含了双引号且不用转义字符整个字符串要用单引号来构造字符串本身有单引号字符串本身有双引号函数输出时是没有外层的引号的运行运行对引号转义运行运行对其他字符转义转义字符以开头后接某些特定的字符或数字转义字符含义转义字符含义转义字符含义行尾续行符换行符换页符一个反斜杠回车位进制数对应的字符如单引号横向水平制表符位进制数对应的字符如双引号纵向垂直制表符位进制数表示的字符你好再见表示换行相当于敲了一个回车键进制数对应的字符是进制数对应的字符运行运行原始字符串假设在文件夹中有一个文件夹如何输出完整路径呢可能你想到的是错误运行运行第种方法使用表示反斜杠则和不再形成和运行运行第种方法在原始字符串前加前缀在字符串前面加上字母或表示原始字符串所有的字符都是原始的本义而不会进行任何转义运行运行三重引号字符串三重引号将保留所有字符串的格式信息如字符串跨越多行行与行之间的回车符引号制表符或者其他任何信息都将保存下来在三重引号中可以自由的使用单引号和双引号字符串格式化用符号格式化字符串格式以开头格式化运算符用表示用对象代替格式串中的格式最终得到个字符串基本同语言字符串格式的书写中的内容可以省略简单的格式是加格式字符如等当最小宽度及精度都出现时它们之间不能有空格格式字符和其他选项之间也不能有空格如常用格式字符的含义基本同语言最小宽度和精度最小宽度转换后的值所保留的最小字符个数精度对于数字来说结果中应该包含的小数位数浮点数总宽度为保留位小数四舍五入单独的默认保留位小数保留位小数第位四舍五入四舍五入为宽度位保留位小数空位填空格宽度位保留位小数空位填实际宽度允许超出最小宽度宽度位保留位小数正数加正号空位填宽度位保留位小数空位填空格左对齐输出左对齐左对齐右补空格字符串用格式化整数输出引发异常类型必须一致与等价多对象后用元组常量元组我叫今年岁变量元组我叫今年岁进位制和科学计数法转换为八进制串转换为十六进制串进制数前添加转换为科学计数法串基底小数点前有一位非零数字小数点后是位小数科学计数法基底科学计数法基底采用浮点数形式根据值的大小采用或采用浮点数形式采用科学计数法形式基底运行运行方法格式化字符串方法是通过和来代替传统方式首先看和参数的对应关系我叫今年岁张清以下输出均为我叫张清今年岁我叫今年岁张清我叫今年岁张清张清我叫今年岁列表前加自动解包我叫今年岁列表不加则需要用列表的索引元素后的表示第一个参数若有第个参数则为中的数字表示列表元素的索引我叫今年岁张清直接写变量名我叫今年岁张清有了名字之后就可以任意顺序张清我叫今年岁字典前加自动解包十进制的二进制八进制十六进制千分位格式化右对齐左对齐居中对齐放在和中间作为分隔符起到千分位的作用运行运行带前缀的格式化字符串张清我叫今年岁运行运行字符串截取字符串属于序列类型同样可以使用索引或者切片单个字符索引取出单个字符切片字符取出一片字符同序列的切片取出位置为到位置为的字符不包括位置的字符取出从头至位置为的字符取出从倒数第个位置开始的所有字符从左往右取步长默认是正序全部字符逆序全部字符步长为运行运行字符串属于不可变序列类型不支持字符串修改字符串常用内置函数字符串长度最大字符最小字符本处为空格获取该字符的码把编码转换为对应的字符好汉字的编码运行运行字符串常用方法由于字符串属于不可变序列下述方法中涉及到返回字符串的都是新字符串原有字符串对象不变格式居中对齐左对齐右对齐说明指定宽度填充的字符默认为空格功能返回一个宽度为的新字符串原字符串居中左对齐或右对齐出现在新字符串中如果大于字符串长度则使用进行填充你好居中对齐以空格填充你好你好居中对齐以填充你好你好右对齐以填充你好你好左对齐以填充你好运行运行方法将大写字母转换为小写字母其他字符不变并返回新字符串全部为小写字母方法将小写字母转换为大写字母其他字符不变并返回新字符串全部为大写字母用处解决有关不区分大小写问题将整个字符串首字母转换为大写形式其他字母转换为小写形式将每个单词的首字母转换为大写形式其他部分的字母转换为小写形式将大小写互换提醒均返回新字符串原字符串对象不做任何修改功能测试字符串是否为全小写大写数字如果是则返回否则返回其他的方法请通过自行查看帮助信息格式说明字符串子串开始位置结束位置查找范围开始结束不包括功能在字符串中在范围内查找并返回子串首次出现的位置索引如果没有找到则返回默认范围是整个字符串其中方法从左往右查找方法从右往左查找格式功能在字符串中查找并返回在范围内子串首次出现的位置索引如果不存在则抛出异常和的不同点默认范围是整个字符串其中方法从左往右查找方法从右往左查找格式功能在字符串中查找并返回范围内子串出现的次数如果不存在则返回默认范围是整个字符串功能以指定字符为分隔符从左往右将字符串分割开来并将分割后的结果组成列表返回如果字符串中的某种字符出现次或多次可以利用方法根据该字符把字符串分离成多个子串组成的列表对于如果不指定分隔符实际上表示以任何空白字符包括连续出现的作为分隔符空白字符包括空格换行符制表符等除了还有表示从右往左将字符串分割开来这两种方法还能指定最大分隔次数方法可用来连接序列中的元素并在两个元素之间插入指定字符返回一个字符串方法是方法的逆方法用空格分割用空格接上运行运行格式功能查找字符串中子串并用子串来替换参数默认值为表示替换所有匹配项否则为其他值时最多替换次返回替换后的新字符串原字符串不变中国北京北京地铁地铁沿线北京沿线城市北京指定最大替换次数运行运行生成字符映射表根据字符映射表替换字符这两种方法联合起来使用可以一次替换多个字符两个序列中的元素按照次序一一对应用于替换运行运行去除字符串两侧的空白字符空格回车制表符等或指定字符并返回新字符串从两端逐一去除或字符直到不是这两个字符为止中间的字符不能去除运行运行字符串模块字符串模块定义了类类函数和常量熟悉模块可以简化某些字符串的操作请输入英文单词用空格分隔用到了函数单词首字母大写运行运行说明这种方法直接用到模块中的常量和模块中方法方法的功能是在一个非空的序列中随机选择一个元素运行运行正则表达式正则表达式的元字符正则表达式模式串中的字符根据作用不同分为两类普通字符大多数字母和字符一般都会和自身匹配元字符有些字符比较特殊它们和自身并不匹配而是表明应和一些特殊的东西匹配或者会影响重复次数因为在模式串中常常有特殊字符为了书写方便在字符串前加前缀不对其进行转义第一种情况模式串中全部是普通字符导入模块模式串中全部是普通字符无匹配两处匹配查找到两个运行运行第二种情况模式串中含有元字符常用的元字符表示任意单个字符除换行符以外在中匹配所有的运行运行三引号字符串中可以有换行符本结果中没有匹配两个换行符匹配后面跟除换行符以外的任意字符的形式必须是两个字符第一个是第个是换行符以外的任意字符可以是空白符指定字符集用来指定一个字符集合例如从字符集合中必须选一个也只能选一个字符即单个字符有些元字符在方括号中不起作用作为普通字符例如和中元字符都不起作用方括号内的表示补集匹配不在区间范围内的字符例如表示除以外的字符匹配后跟或者再跟形式查找个字符第字符必须是第字符必须是中间字符只能是中的一个运行运行匹配行首匹配每行中以后面的字符开头的字符串必须放在模式串的开头英文称为英语发音记忆法数学上读作帽子戴头上可以形象的想象成首部匹配模式默认只匹配多行字符串的首行多行匹配需要单独设置参数匹配行尾匹配每行中以匹配行尾匹配每行中以匹配行尾匹配每行中以之前的字符结束的字符串英语读作音标记忆法可以形象的想象成弯曲的尾巴行尾匹配模式默认只匹配多行字符串的末行多行匹配需要单独设置参数反斜杠后面可以加不同的字符以表示不同的特殊意义四对匹配单词头或单词尾放前面会匹配单词头放后面会匹配单词尾相当于或但这两个只能用于整个字符串不能切分单词与相反匹配非单词头或单词尾不查找单词头或单词尾只查其他部分匹配任何数字字符相当于与相反匹配任何非数字字符相当于匹配任何空白字符相当于与相反匹配任何非空白字符相当于是制表符是换页符是垂直制表符匹配任何字母数字或下画线字符相当于与相反匹配任何非字母数字和下画线字符相当于也可以用于取消所有的元字符这些特殊字符都可以包含在中如将匹配任何空白字符或第一对和字符串中切分单词的分隔符包括空格换行制表符各种标点符号单词头单词尾注意不是整个字符串而是分隔后的每个单词和相反不查开头结尾的只查其他部分的第二对与数字字符等同于和相反等同于非数字字符第三对与匹配查找任何空白字符相当于横向制表符换行回车换页符纵向制表符和相反不匹配查找任何空白字符相当于与区别表示任意单个字符换行符除外表示任意单个字符空白符除外注意是大写的第四对与匹配任何字母数字或下画线字符相当于和相反不匹配任何字母数字或下画线字符相当于第五点用取消元字符此时的就是元字符匹配查找任意字符此时的就是普通的字符匹配查找第六点也可以用在内以上类元字符都是表示单个字符任意单个字符换行符除外集合中的任意单个字符行首行尾量词正则表达式能指定正则表达式的一部分的重复次数用到的元字符有").trim().substring(0, 1000);
      let value = Math.floor(Math.random() * 3) + 1000;
      while (value === prevParam || truncateDescription.length - value === prevParam) {
        value = Math.floor(Math.random() * 3) + 1000;
      }
      aiTitleRefreshIcon.style.opacity = "0.2";
      aiTitleRefreshIcon.style.transitionDuration = "0.3s";
      aiTitleRefreshIcon.style.transform = "rotate(" + 360 * refreshNum + "deg)";
      if (truncateDescription.length <= 1000) {
        let param = truncateDescription.length - Math.floor(Math.random() * 3);
        while (param === prevParam) {
          param = truncateDescription.length - Math.floor(Math.random() * 3);
        }
        aiAbstract(param);
        prevParam = param;
      } else {
        aiAbstract(value);
        prevParam = value;
      }
      refreshNum++;
    }
  }

  //- 监听tag点击事件
  document.getElementById("ai-tag").addEventListener("click", () => {
    if (mode === "tianli") {
      document.querySelectorAll(".ai-btn-item").forEach(item => item.style.display = "none");
      document.getElementById("go-tianli-blog").style.display = "block";
      startAI("你好，我是Tianli开发的摘要生成助理TianliGPT，是一个基于GPT-4的生成式AI。我在这里只负责摘要的预生成和显示，你无法与我直接沟通，如果你也需要一个这样的AI摘要接口，可以在下方购买。（暂未开放购买，敬请期待）")
    } else {
      document.getElementById("go-tianli-blog").style.display = "none";
      startAI("你好，我是本站摘要生成助理AnZhiYu GPT，是一个基于GPT-4的生成式AI。我在这里只负责摘要的预生成和显示，你无法与我直接沟通。")
    }

  });

  aiTitleRefreshIcon.addEventListener("click", () => {
    const truncateDescription = ("" + "一、前言, 二、语言基础, 2.1标识符, 1.2.1标识符, 1.2.2关键字, 2.1.3变量, 2.2数据类型, 1.整型int, 2.浮点数float, 3.复数complex, 4.布尔bool, 5.字符串str, 6.列表 list, 7.元组 tuple, 8.字典 dict, 9.集合 set, 2.3赋值语句、运算符, 2.3.1赋值语句的格式, 2.3.2运算符, 1.算数运算符, 2.关系运算符, 3.测试运算符, 4.逻辑运算符, 2.4从控制台输入和输出, 1. input()函数, 2.类型转换函数, 3.数据的输出, 2.5内置函数, 三、流程控制, 3.1分支结构, 3.2循环结构, 3.2.1for循环语句, 3.2.2 break语句和continue语句, 3.2.3 带else的循环语句（与C语言不同不建议用）, 3.2.4循环嵌套, 四、常用数据结构, 4.1 序列, 4.1.1列表 list, 1.列表的创建, 2.列表的元素访问, 3.修改元素, 4.列表切片, 5. del命令, 7.列表方法：类型本身的方法, 9.列表遍历, 4.1.2元组, 1.元组的创建, 2.元组的访问, 4.1.3 列表与元组的转换, 1.列表–gt元组, 2.元组–gt列表, 4.2 字典, 4.2.1 创建字典, 4.2.2 字典操作, 1.字典中键-值对的数量, 2.查找与特定键相关联的值：键—gt值, 3.修改字典中的数据, 4.删除字典条目, 4.2.3 字典方法, 1.keys()、values(), 2.items(), 3.setdefault(), 4.update(), 5.clear(), 6.pop(), 7.popitem(), 8.get(), 4.2.4遍历字典, 1.遍历字典的key, 2.遍历字典的值Value, 3.遍历字典的键值对, 4.2.5列表、元组、字典的转换, 1.列表与字典之间的转化：字典–gt列表, 2.元组与字典之间的转化：字典–gt元组, 4.3 集合 Set, 4.3.1 集合的创建, 4.3.2 集合的运算, 1.len() 、max()、min()、sum(), 2.in, 3.并集、交集, 4.差集, 5.对称差, 6.子集和超集, 4.3.3 集合的方法, 1.union()、intersection(), 2.update(), 3.difference(), 4.symmetric_difference(), 5.issubset()和issuperset(), 6.add(), 7.remove(), 8.discard(), 9.pop(), 10.clear(), 4.4 可迭代对象Iterable 与 迭代器Iterator, 4.4.1 可迭代(Iterable)对象, 4.4.2 相关内置函数, 4.5 推导式, 4.5.1 列表推导式, 4.5.2 字典推导式, 4.5.3 集合推导式, 4.5.4 生成器推导式, 五、字符串, 5.1 字符串的编码, 5.2 字符串的构建, 5.3 字符串格式化, 5.4 字符串截取, 5.5 字符串常用内置函数, 5.6字符串常用方法, 5.7 字符串string模块, 5.8正则表达式一前言这是哪托针对老师的课件整理的复习笔记基础入门希望能对广大基础小白受用内容如有错误的地方劳请留言指正笔记所有代码使用的插件编译二语言基础标识符标识符标识符可以包括英文数字以及下划线并且开头必须是字母或下划线不能以数字开头开头区分大小写的不能出现分隔符标点符号或者运算符不能使用关键字等最好不要使用内置模块名类型名函数名已经导入的模块及其成员名合法的标识符连续两个下画线等非法的标识符中间用了空格关键字等关键字关键字是一个特殊的对象不是不是也不是空字符串空列表等有自己的数据类型和任何其他数据类型进行是否相等比较永远返回可以将赋值给任何变量但是不能创建其他对象变量变量与与语言相比相同点用于储存计算结果或能表示值可以通过变量名访问变量值通常是可变的变量具有名字不同变量是通过名字相互区分的不同点变量的数据类型不需要声明变量的数据类型可以变化是动态类型语言变量使用之前必须赋值常量没有常量即没有语法规则限制改变一个常量的值怎么办呢使用人为约定通常用全大写字母表示常量编程时不要修改它的值常量示例你喜欢我吗运行运行数据类型整型整数没有小数部分的数值分为正整数和负整数十进制二进制八进制十六进制浮点数浮点数包含小数点的数科学计数法运行运行复数复数由两部分组成实部和虚部复数的形式为实部虚部都是复数复数的实部复数的虚部运行运行两个注意点支持任意大的数字仅受内存大小的限制所以在使用时不用考虑的范围为了提高可读性在数值中可以使用下画线布尔布尔类型是用来表示逻辑是非的一种类型它只有两个值和首字母和是大写的将布尔值实现为类型实现为所以可以参与整型运算但不建议这么做字符串语言中的字符串是一种序列字符串用单引号双引号三引号作为定界符等列表列表也是一种序列类型列表用方括号和将列表中的元素括起来元素之间以逗号进行分隔和元组元组也是一种序列元组用和作为边界将元素括起来元素之间以逗号分隔和字典字典是唯一内建的映射类型可用来实现通过数据查找关联数据的功能字典是键值对的无序集合字典中的每一个元素都包含两部分键和值字典用大括号和来表示每个元素的键和值用冒号分隔元素之间用逗号分隔张三徐虎张林集合集合是由各种不可变类型的元素组成但元素之间无序并且元素都不重复赋值语句运算符赋值语句的格式变量表达式常规同特殊多变量赋值两变量的交换运行运行运算符算数运算符在中算术运算符有加减乘真除法求整商取模幂需要说明的几点运算符不支持不同类型的对象之间的连接错误不同类型正确通过类型转换函数将数字转换成字符串运算符可以用于列表元组或字符串与整数的相乘用于将这些序列重复整数所指定的次数它不适用于字典和集合与整数的相乘列表元组字符串字典不可以因为字典的键不能重复运算符幂运算与内置函数相同真除法与整数除法真除取商的整数部分操作数为实数时则取实数形式的整数即运行运行关系运算符六个小于小于等于大于大于等于等于不等于结果布尔值或所有的字符串都是字符串单个字符可以通过函数获取该字符的码通过函数把编码转换为对应的字符得到对应的字符我我运行运行注意字符串和数字属于不可比较大小的列表比较大小也是从左到右逐个元素的依次比较类似字符串之间的比较列表中字符串与数值也是不能比较的出错出错关系运算符可以连用等价于某几个用连接起来的表达式注意语言和语言均不可这么用与下式含义相同与下式含义相同运行运行因为精度问题可能导致实数运算有一定的误差要尽可能地避免在实数之间进行相等性判断有误差了误差导致不相等解决方法使用实数之间的差值的绝对值是否小于某一个很小的数来作为实数之间是否相等的判断表示和是相等的运行运行测试运算符四个结果返回布尔值或列表测试字符串虽然内容一样但不是同一个对象运行运行同一性测试运算符和测试是否为同一个对象或内存地址是否相同返回布尔值和测试是否为同一个对象相等但不是同一个对象测试是否相等运行运行注意是否相等只是测试值是否相同是否为同一个对象指的是是否指向同一个对象如果指向同一个对象则内存地址应该相同当然也相等内置函数返回对象的标识内存地址每个人运行得到的内存地址可能会不一样赋值语句则和不仅值相等而且指向同一个对象的内存地址相同逻辑运算符在中逻辑运算符有与或非通过逻辑运算符可以将任意表达式连接在一起哪些是数值类型中的空字符串空元组空列表空字典空集合等非零值为零值为运行运行逻辑操作符和也称作短路操作符具有惰性求值的特点短路运算表达式从左向右解析一旦结果可以确定就停止注意逻辑运算符不一定会返回布尔值和与运算结果不一定为或当计算表达式时先计算的值当的值为或非空值非非值非空的其他数据类型才计算并输出的值当的值为或空值值为空的其他数据类型直接输出的值不再计算第一个为则输出第二个的值结果与第二个值有关下同的值为则计算并输出的值第一个为则不再计算第二个的值直接输出第一个的值下同直接输出直接输出运行运行或运算结果不一定为或当计算表达式时先计算的值当的值为或非空值非非值非空的其他数据类型直接输出的值不再计算当的值为或空值值为空的其他数据类型才计算并输出的值第一个为则不再计算第二个的值直接输出第一个的值下同的值为则直接输出第一个为则继续计算第二个的值输出第二个的值下同运行运行赋值运算符复合赋值运算符位运算符等等此处基本同语言特别注意没有自加与自减优先级小括号最高从控制台输入和输出函数用于输入数据无论用户输入什么内容该函数都返回字符串类型其格式如下表示提示语默认为空请输入值请输入值查看的类型为运行运行类型转换函数函数格式功能截取数字的整数部分或将字符串转换成一个整数如果不给定参数则返回没有参数时浮点数直接截取整数部分不进行四舍五入整数字符串浮点数字符串错误注意函数不接受带小数的数字字符串格式功能把进制的字符串转换为十进制为基数进制默认为十进制的有效值范围为和二进制的数转换为十进制数十六进制的数转换为十进制数八进制的数转换为十进制数不允许二进制的小数不接受带小数的数字二进制的数转换为十进制数函数格式功能将一个数字或字符串转换成浮点数默认参数为无穷大不区分大小写错误错误不能转换表达式字符串所以引入函数函数格式功能将字符串当做一个表达式进行解析和计算返回计算结果参数说明是一个字符串这个字符串能表示成表达式或者是能够通过编译的代码是可选的参数默认为如果设置属性不为的话就必须是对象也是可选的参数默认为如果设置属性不为的话可以是任何对象字符串中是表达式返回表达式的值字符串中是列表元组或字典得到真正的列表元组或字典字符串中是能够通过编译的代码执行代码表达式返回列表返回字典执行语句执行语句获取当前目录组合使用函数和请输入值输入列表格式获得列表请输入值输入字典格式获得字典数据的输出函数格式如下各参数的解释如下需要输出的对象一次可以输出一个或者多个对象其中表示任意多个对象对象之间要用逗号分隔对象之间的间隔符默认用一个空格分隔以何字符结尾默认值是换行符表示输出位置可将输出到文件指定的对象要有写的方法默认值是标准输出即控制台屏幕将缓存里面的内容是否强制刷新输出默认值是一般不需要一次输出三个对象中间默认用空格隔开一次输出三个对象中间用隔开一次输出三个对象中间无分隔因为参数值被设置为空字符串了一次输出三个对象以结尾不换行一次输出三个对象以分隔以结尾运行运行可以看出函数默认输出是换行的如果要实现不换行需要在变量末尾设置参数内置函数函数功能返回数字的绝对值如果给出复数返回值就是该复数的模把整数转换为二进制函数返回整商和余数的元组计算字符串中表达式的值并返回返回对象的帮助信息返回对象的标识内存地址接受键盘输入显示提示信息返回字符串返回对象列表元组字典字符串集合对象的元素个数包含若干函数值的对象其中表示函数表示迭代对象将函数作用于迭代对象返回给定参数的最大值最小值参数可以为可迭代对象函数返回以为底为指数的幂如果给出值该函数就计算的次幂值被取模的值输出对象默认输出到屏幕相邻数据之间使用空格分隔结尾以换行符结束返回对象该对象包含按参数范围内为步长生成的整数返回浮点数的四舍五入值若不给出值则返回整数给出值则代表舍入到小数点后的位数返回排序后的列表其中表示要排序的序列或迭代对象表示排序规则表示升序或降序默认升序返回序列中所有元素之和如果指定起始值则返回如果为空则返回返回编码为所对应的字符把字符串或数字转换为复数如果第个参数是字符串不能使用第个参数把一个数字或字符串转换成浮点数把整数转换成十六进制串把数字和字符串转换成一个整数或把进制的字符串转换为十进制为可选的基数默认为十进制将对象转换成列表元组字典集合或生成空列表空元组空字典空集合把给出的整数转换成八进制串返回一个字符的编码三流程控制分支结构单分支语句双分支语句多分支语句选择结构的嵌套选择结构的三元运算注意没有语句语法类似于此处省略循环结构定义给定的判断条件为真包括非零非空时重复执行某些操作判断条件为假包括零空时结束循环循环分类语句语句循环中断带的循环语句特有与类似相关内容请参考循环语句语句通过遍历一个序列字符串列表元组或迭代器等可迭代对象中的每个元素来建立循环语句的语法形式如下所示变量序列或迭代器等可迭代对象循环体补充函数返回可迭代对象语法格式如下功能产生一个从开始包括默认为到结束不包括两个整数对象之间间隔默认为的可迭代对象可以用循环直接遍历函数产生的可迭代对象默认运行运行对象可以被转换成列表或元组例如对象转换为列表对象对象转换为元组对象语句和语句详细解释语句可以用在和循环中在循环进行过程中如果某个条件被满足一般通过语句判断是否满足执行语句的条件则可以通过语句立即终止本层循环如果语句在具有两层循环嵌套的内层循环中则只终止内层循环进入到外层循环的下一条语句继续执行语句可以用在和循环中在循环体执行过程中如果遇到语句程序会跳过本次循环的循环体剩余语句回到循环开始的地方重新判断是否进入下一次循环精简语句终止整个当前循环语句的执行不会终止整个当前循环只是提前结束本次循环跳过循环体中本次循环的剩余语句提前进入到下一次循环再精简同语言带的循环语句与语言不同不建议用中的和语句后面还可以带有语句块语句语法如下条件表达式循环体语句块三种执行流程正常循环当条件表达式为真非空非零时反复执行循环体执行一次当条件表达式为假零空而导致循环终止或无法进入循环语句块执行一次然后结束该循环结构不执行如果该循环是因为执行了循环体中的语句而导致循环终止语句块不会执行直接结束该循环结构例从键盘输入一个正整数用循环找出小于等于该整数且能被整除的最大正整数如果找到了输出该整数如果没有找到则输出未找到请输入一个正整数小于等于且能被整除的最大正整数是未找到运行运行带的语句语法如下变量序列或迭代器等可迭代对象循环体语句块循环嵌套四常用数据结构序列列表列表是中最基本的数据结构是最常用的数据类型列表的特点列表将由若干数据作为元素的序列放置在一对方括号中元素之间以逗号分隔列表中的元素允许重复列表是可以修改的增删改查以上类似数组列表元素可以由任意类型的数据构成同一列表中各元素的类型可以各不相同不同于数组列表的操作汇总创建列表访问元素更改元素值切片形式列表计算列表列表列表整数列表方法查增删序序列函数不仅仅用于列表命令列表列表的创建创建一维列表方式普通列表方式创建空列表函数创建二维列表运行运行列表的元素访问索引列表中的每个元素被关联一个序号即元素的位置索引值是从开始第二个则是以此类推从左向右逐渐变大列表也可以从后往前索引值从开始从右向左逐渐变小适用于所有序列类型的对象列表元组字符串修改元素通过重新赋值来更改某个元素的值注意合法索引范围超过范围则会出错列表切片在列表中可以使用切片操作来选取指定位置上的元素组成新的列表简单的切片方式为步长默认为原列表名左封闭能取到右开放取不到左索引为时可缺省右索引为列表长度时可缺省取第号元素缺省为缺省为列表长度长度从开始计算都缺省全列表等于时空列表运行运行也可以使用负数作索引索引为和位置上的元素依然是从左往右取索引从至列表末尾位置上的元素运行运行切片步长非零整数即可正可负但不能为跳着切片原列表名步长为时参数可以省略步长不为时该参数不可省略函数为的可迭代对象用函数转换为从到的列表步长为索引值从开始每次增长但索引值必须小于步长为负数时不能小于值超过范围实际索引从最后一个元素开始不出错这里步长为负数表示在整个列表内从后往前取值作用逆序运行运行利用切片还可以更改元素值有点类似多变量赋值的感觉分别更改索引号为和的位置上元素值分别更改索引号为三个位置上的元素值少给个数呢少的那个数被删掉了命令注意是命令不是函数或方法从列表中删除元素也可以删除整个列表删除了删除列表列表不存在了再次使用出错补充方法函数命令的概念上的区别命令内置命令没有括号函数是指内置函数或用导入的某模块的函数直接可以使用比如方法是指某个对象的方法格式为对象名方法名比如是指列表对象的方法列表运算列表相加通过列表相加的方法生成新列表支持复合赋值结果为新列表原列表不变复合赋值语句不支持减运算出错列表乘法列表整数生成一个新列表新列表原来列表的元素重复次相乘语句复合赋值语句相当于重新定义了列表运行运行列表方法类型本身的方法返回第一个值元素索引位置没指定则从索引为的位置开始查找否则从索引为的位置开始查找没指定可以查找到列表最后元素否则在位于内的索引区间查找如果找不到匹配项就会引发异常整个列表范围内第次出现的索引位置是在从索引为开始第次出现的索引位置是运行运行统计某个元素在列表中出现的次数追加单个元素到列表的尾部只接受一个元素元素可以是任何数据类型被追加的元素在列表中保持着原结构类型在列表的末尾一次性追加另一个列表中的多个值只能有一个参数应用用新列表扩展原有的列表将一个元素插入到指定位置两个参数第一个参数是索引点即插入的位置第二个参数是插入的元素插入后在位置注意插入后的位置在位置的前面运行运行用于移除列表中与某值匹配的第一个元素如果找不到匹配项就会引发异常移除列表中的一个元素默认为最后一个元素并且返回该元素的值出栈可以指定索引位置当不在索引范围内或者是空列表中均会触发异常删除列表中所有元素但保留列表对象请注意与命令的区别命令删除整个列表时列表对象不再保留方法用于将列表中的元素位置反向存放列表中可以有不同类型的元素方法只是将位置反转元素排序默认按升序排列两个参数参数默认为升序若等于表示降序排序如果包含的是字符串按字符串排序规则参数指定排序方式按数值大小升序降序按转换为字符串后的大小升序排列码排序的元素必须是可比较大小字符串和数值不能比较列表函数不单单用于列表的函数也可用于其他数据结构列表遍历通过语句或者语句循环遍历所有元素直接遍历每一个元素循环通过索引遍历每一个元素运行运行元组元组和列表十分相似元组是用一对圆括号括起用逗号分隔的多个元素的组合属于序列有顺序可以重复元组是不可更改的是不可变对象元组创建之后就不能修改添加删除成员元组的上述特点使得其在处理数据时效率较高而且可以防止出现误修改操作元组的创建创建多个元素的元组创建单一元素的元组后面的逗号不能省略省略后就变成字符串类型了创建空元组使用函数创建空元组运行运行元组的访问和列表一样可以通过索引访问单个切片访问多个来访问元组的成员索引方式切片方式元组不能更改元素值不能赋值报错元组的运算元组相加通过元组相加的方法生成新元组正确重新定义了运行运行元组相乘用数字乘以一个元组会生成一个新元组在新元组中原来的元组元素将依次被重复次运行运行元组的遍历通过语句或者语句同列表方法列表与元组的转换列表元组函数接受一个列表并返回一个包含同样元素的元组从结果上看函数冻结了列表元组运行运行元组列表函数接受一个元组并返回一个包含同样元素的列表从结果上看函数融化了元组运行运行字典字典是中唯一内建的映射类型用一对花括号和作为边界元素之间以逗号分隔每个元素是一对键和值键和值之间用英文冒号分隔映射可通过数据查找关联数据无序字典的元素没有顺序因此不能像序列那样通过位置索引来查找成员数据但是每一个值都有一个对应的键不重复字典的键是不重复的用法通过键来访问相应的值值是可以重复的创建字典创建创建需注意键外面不能加引号列表元组由序列构建对象由对象创建字典以给定序列元组或者列表为键创建值为空的字典创建空字典无参的函数运行运行键必须是不可修改类型的数据如数值字符串和元组等列表是可变的不能作为字典的键键对应的值可以是任何类型的数据字典是无序集合字典的显示次序由字典在内部的存储结构决定字典操作字典中键值对的数量返回字典中项键值对的数量运行运行查找与特定键相关联的值键值运行运行修改字典中的数据在字典中某个键相关联的值可以通过赋值语句来修改如果指定的键不存在则相当于向字典中添加新的键值对有则修改无则添加运行运行删除字典条目命令用来删除字典条目或者整个字典键存在删除整个检查字典中是否含有某键的项命令查找某键值是否在字典中如果存在返回否则返回字典方法方法将字典中的键以可迭代的对象返回方法将字典中的值以可迭代的对象形式返回转换成列表转换成元组运行运行将字典中的所有键和值以可迭代的对象返回每对键值对组成元组作为一个元素转换成列表转换成元组运行运行使用时如果字典中包含参数对应的键则返回该键对应的值否则以参数的值为键以参数的值为该键对应的值在字典中插入键值对元素并返回该元素的值部存在这个键返回对应的值控制单元存在这个键默认值和原有的值不一样返回对应的原值有则修改不存在这个键插入新的键值对和之前比较无则添加不存在这个键也未指定新值运行运行将另一个字典中的所有键值对一次性地添加到当前字典中如果两个字典中存在有相同的键则以另一个字典中的值更新当前字典方法将字典中的所有条目删除变成空字典方法能够弹出并删除字典中的键值对返回键为的值并在字典中删除该键值对方法能够弹出字典的一个元素如果字典为空则触发异常返回指定键所对应的值如果键不存在则返回默认值默认值为也可以自己指定遍历字典遍历字典的默认遍历字典的键和上面相同遍历字典的值遍历字典的键值对列表元组字典的转换列表与字典之间的转化字典列表中的函数可以将字典转换列表但列表不能转换为字典默认将键转化为列表键值键值对元组与字典之间的转化字典元组中的函数可以将字典转换元组但元组不能转换为字典默认将键转化为元组键值键值对集合集合是一组用括起来的无序不重复元素元素之间用逗号分隔元素可以是各种类型的不可变对象集合想象成只有没有值的字典集合的创建集合类型的值有两种创建方式用一对花括号将多个元素括起来元素之间用逗号分隔函数将字符串列表元组等类型的数据转换为集合类型直接赋值函数注意空集合只能用来创建而不能用空的花括号表示因为已将空用于表示空字典无参的函数空集合运行运行集合中没有相同的元素因此创建集合时会自动删除掉重复的元素利用这一点可以快速去重集合的运算返回集合中元素的个数生成排序后的列表集合本身无序不能反序集合本身无序判断某元素是否存在于集合之中判断结果用布尔值或表示并集交集并集创建一个新的集合该集合包含两个集合中的所有元素交集创建一个新的集合该集合为两个集合中的公共部分并集交集运行运行差集表示集合与的差集返回由出现在集合中但不出现在集合中的元素所构成的集合对称差返回由两个集合中那些不重叠的元素所构成的集合子集和超集子集如果集合的每个元素都是集合中的元素则集合是集合的子集超集超集是仅当集合是集合的一个子集集合才是集合的一个超集检测是否是的子集检测是否是的真子集检测是否是的超集检测是否是的真超集以上结果只返回或将的元素并入中集合的方法同样以面向对象方式实现集合类型的运算方法相当于并集运算方法相当于交集运算并集新的集合未发生改变未发生改变交集产生新集合运行运行方法相当于集合元素合并运算注意与方法的区别发生了改变相当于差集运算新集合原集合没有变化相当于对称差运算结果相同和方法判断是否子集方法判断是否超集是向集合中添加元素重复元素只保留一个是从集合中删除元素如果集合中没有该元素则出错作用是从集合中删除元素如果集合中没有该元素也不提示出错方法的作用是从集合中删除任一元素并返回该元素如果集合为空则抛出异常从集合中删除所有元素变成一个空集合可迭代对象与迭代器简单解释可迭代对象是存放元素的容器可以被遍历其中的元素类比链表迭代器由可迭代对象容器提供的因为只有该容器知道怎么遍历它的每一个元素用于遍历容器元素的一个工具类比链表的遍历指针可迭代对象列表元组字符串字典可以用进行遍历表面只要可以用进行遍历的对象就是可迭代对象那么列表元组字符串字典都是可迭代对象本质如果一个对象实现了方法那么这个对象就是可迭代对象方法查看对象的方法是否有方法类似于中查看某一个类可实现的方法运行运行方法可以通过调用内置函数来判断一个对象是否属于可迭代对象列表是可迭代对象吗数值是可迭代对象吗不是运行运行迭代器实现了方法和方法并且可以通过方法不断返回下一个值的对象迭代器还可以通过内置函数访问下一个元素可以通过调用内置函数来判断一个对象是否属于迭代器列表是迭代器吗列表是迭代器吗字典是迭代器吗集合是迭代器吗字符串是迭代器吗函数生成的数列是迭代器吗数值是迭代器吗以上对象均不能成为迭代器注意迭代器和可迭代对象不同运行运行可迭代对象容器迭代器迭代工具虽然列表元组字符串字典集合都是可迭代对象而不是迭代器但可以通过函数获得一个迭代器列表取的迭代器自带方法返回下一个值也可以用内置函数函数没有下一个元素了触发异常内置函数访问下一个值同样异常运行运行相关内置函数枚举组合映射逐个计算过滤挑选共同点这四个函数都会返回一个特定对象它们都既是迭代器也是可迭代对象枚举格式功能返回下标和值的对象参数第个参数表示可迭代对象第个参数表示下标的开始值默认从开始通俗将容器的每个元素取出来搭配一个下标对象既是对象容器也是对象容器的遍历工具列表用其他容器也可以取得的枚举器迭代器可以使用语句也可以使用函数也可以使用方法将剩余的对象元素转换为列表对象转换为元组下标从开始返回下一个值遍历对象中的元素遍历对象元素的下标和值对象转换为字典枚举号转为枚举值转为对象转换为集合格式功能将多个迭代器对象或者可迭代对象中的元素压缩到一起返回一个对象通俗将多个容器的逐个对应元素拼合在一起同样对象既是一个可迭代对象也是一个迭代器对象只有一个参数字符串容器每个元素是元组有两个参数有两个容器作为参数对象是可迭代对象容器可以使用运算第二个参数是枚举也是容器不同长短时匹配短的更多参数更多容器格式功能把一个函数依次映射到可迭代对象的每个元素上返回一个对象通俗将每个元素传入函数把结果放入里对象既是一个可迭代对象也是一个迭代器对象将每个元素变为类型将改为字符串定义一个函数中的每个元素都执行一次函数结果放入运行运行格式函数名可迭代对象功能把一个带有一个参数的函数作用到一个可迭代对象上返回一个对象对象中的元素由可迭代对象中使得函数返回值为的那些元素组成如果指定函数为则返回可迭代对象中等价于的元素通俗将容器中的元素用函数过滤挑选一下对象既是一个可迭代对象也是一个迭代器对象只保留满足条件的元素用法函数定义函数为奇数返回否则返回将中的每个元素作为参数带入将返回值为的元素保留下来是一个对象用法函数匿名函数不用单独定义函数了用法指定函数为函数就不起作用了就看元素本身是否为运行运行推导式利用列表推导式字典推导式集合推导式可以从一个数据对象构建另一个新的数据对象利用生成器推导式可以构建生成器对象语法糖列表推导式列表推导式是开发时用得最多的技术之一表示对可迭代对象的元素进行遍历过滤或再次计算生成满足条件的新列表它的结构是在一个方括号里包含一个函数或表达式再次计算接着是一个语句遍历然后是个或多个遍历或者语句过滤在逻辑上等价于循环语句但是形式上更简洁语法形式函数表达式值可迭代对象条件值可迭代对象条件值可迭代对象条件列表推导式和循环语句如果要将一个列表中的元素均扩大倍组成新列表列表推导式运行运行两点利用列表推导式更加简洁由于内部对列表推导式做了大量优化还能保证较快的运行速度循环可以嵌套列表推导式中也可以有多个语句如果要将一个一层嵌套数字列表中的元素展开后扩大倍组成新列表一层嵌套列表常规写法每一行行中的每一列列表推导式运行运行列表推导式和条件语句在列表推导式中条件语句对可迭代对象中的元素进行筛选起到过滤的作用接着上面的例子如果是将一个数字列表中的是正数的元素扩大倍组成新列表运行运行另外在列表推导式中还可以使用语句将一个数字列表中的正偶数扩大倍正奇数扩大倍组成新列表运行运行列表推导式和函数在列表推导式中可以使用函数利用列表推导式快速生成包含个包含之间的随机整数列表使用函数对中的元素如果被整除则该数除以如果被整除则该数扩大倍其他的数扩大倍这些数组成新列表使用自定义的函数运行运行同时遍历多个列表或可迭代对象有两个成绩列表和将中分数及以上和中分数及以下的元素两两分别组成元组将这些元组组成列表中的元素运行运行字典推导式字典推导式和列表推导式的使用方法类似将方括号变成花括号需要两个表达式一个生成键一个生成值两个表达式之间使用冒号分隔最后生成的是字典语法形式函数表达式值可迭代对象条件值可迭代对象条件值可迭代对象条件列表存储若干人的名字唯一列表在对应的位置上存储这些人的成绩利用字典推导式以名字为键成绩为值组成新字典以名字为键成绩为值组成新字典新字典中的键值对只包含成绩及以上的增加一个以名字为键名字的长度为值组成新字典运行运行集合推导式集合也有自己的推导式跟列表推导式类似只不过将方括号变成花括号最后生成的是集合语法形式函数表达式值可迭代对象条件值可迭代对象条件值可迭代对象条件运行运行不难发现构建和的时候除了方括号和花括号不同以外其他语法均相同生成一个列表里面的元素是元组中每个元素的倍而且元素位置一一对应生成一个集合里面的元素是元组中每个元素的倍去掉重复元素后的结果并且并非与元组的元素位置一一对应需要说明的是元组没有推导式生成器推导式生成器推导式用法与列表推导式类似把列表推导式的方括号改成圆括号它与列表推导式最大的区别是生成器推导式的结果是一个生成器对象是一种迭代器而列表推导式的结果是一个列表生成器对象可以通过循环或者方法函数进行遍历也可以转换为列表或元组但是不支持使用下标访问元素已经访问过的元素也不支持再次访问当所有元素访问结束之后如果想再次访问就必须重新创建该生成器对象生成器对象转换为列表不能再次访问访问下一个元素循环遍历五字符串字符串的编码码标准码为位编码包括英文字母数字标点符号等个字符用个字节存储最高位为扩展码个字节存储最高位为编码把所有语言统一到一套编码里采用个字节或个字节生僻字符的编码缺点全部是英文的话比码多用一倍存储空间编码可变长编码英文字符用个字节兼容码中文字符用个字节其他语言也有用或个字节等中文编码一般用个字节支持两种类型字符串类型支持编码和类型而且类型和类型可以相互转换可以转换为类型转换为类型除此之外其他方法都一样我类型编码编码成类型编码格式进制个字节位进制数用位进制数表示编码成类型编码格式进制个字节解码目前是编码的字符串使用进行解码目前是编码的字符串使用进行解码我是类型字符串中文字符串不能以编码英文字符串可以以编码也可以使用和完成两种类型的相互转换阳光用编码转换用编码转换个字节用编码转换类型是用转换来的阳光个字节结果有误运行运行完全支持中文字符解析器默认采用解析源程序无论是数字字符英文字母汉字都按一个字符来对待和处理字符串的构建在中字符串的构建主要通过两种方法来实现一是使用函数二是用单引号双引号或三引号单引号或双引号构造字符串要求引号成对出现合法如不合法字符串本身有单引号或双引号时字符串包含了单引号且不用转义字符整个字符串就要用双引号来构造字符串包含了双引号且不用转义字符整个字符串要用单引号来构造字符串本身有单引号字符串本身有双引号函数输出时是没有外层的引号的运行运行对引号转义运行运行对其他字符转义转义字符以开头后接某些特定的字符或数字转义字符含义转义字符含义转义字符含义行尾续行符换行符换页符一个反斜杠回车位进制数对应的字符如单引号横向水平制表符位进制数对应的字符如双引号纵向垂直制表符位进制数表示的字符你好再见表示换行相当于敲了一个回车键进制数对应的字符是进制数对应的字符运行运行原始字符串假设在文件夹中有一个文件夹如何输出完整路径呢可能你想到的是错误运行运行第种方法使用表示反斜杠则和不再形成和运行运行第种方法在原始字符串前加前缀在字符串前面加上字母或表示原始字符串所有的字符都是原始的本义而不会进行任何转义运行运行三重引号字符串三重引号将保留所有字符串的格式信息如字符串跨越多行行与行之间的回车符引号制表符或者其他任何信息都将保存下来在三重引号中可以自由的使用单引号和双引号字符串格式化用符号格式化字符串格式以开头格式化运算符用表示用对象代替格式串中的格式最终得到个字符串基本同语言字符串格式的书写中的内容可以省略简单的格式是加格式字符如等当最小宽度及精度都出现时它们之间不能有空格格式字符和其他选项之间也不能有空格如常用格式字符的含义基本同语言最小宽度和精度最小宽度转换后的值所保留的最小字符个数精度对于数字来说结果中应该包含的小数位数浮点数总宽度为保留位小数四舍五入单独的默认保留位小数保留位小数第位四舍五入四舍五入为宽度位保留位小数空位填空格宽度位保留位小数空位填实际宽度允许超出最小宽度宽度位保留位小数正数加正号空位填宽度位保留位小数空位填空格左对齐输出左对齐左对齐右补空格字符串用格式化整数输出引发异常类型必须一致与等价多对象后用元组常量元组我叫今年岁变量元组我叫今年岁进位制和科学计数法转换为八进制串转换为十六进制串进制数前添加转换为科学计数法串基底小数点前有一位非零数字小数点后是位小数科学计数法基底科学计数法基底采用浮点数形式根据值的大小采用或采用浮点数形式采用科学计数法形式基底运行运行方法格式化字符串方法是通过和来代替传统方式首先看和参数的对应关系我叫今年岁张清以下输出均为我叫张清今年岁我叫今年岁张清我叫今年岁张清张清我叫今年岁列表前加自动解包我叫今年岁列表不加则需要用列表的索引元素后的表示第一个参数若有第个参数则为中的数字表示列表元素的索引我叫今年岁张清直接写变量名我叫今年岁张清有了名字之后就可以任意顺序张清我叫今年岁字典前加自动解包十进制的二进制八进制十六进制千分位格式化右对齐左对齐居中对齐放在和中间作为分隔符起到千分位的作用运行运行带前缀的格式化字符串张清我叫今年岁运行运行字符串截取字符串属于序列类型同样可以使用索引或者切片单个字符索引取出单个字符切片字符取出一片字符同序列的切片取出位置为到位置为的字符不包括位置的字符取出从头至位置为的字符取出从倒数第个位置开始的所有字符从左往右取步长默认是正序全部字符逆序全部字符步长为运行运行字符串属于不可变序列类型不支持字符串修改字符串常用内置函数字符串长度最大字符最小字符本处为空格获取该字符的码把编码转换为对应的字符好汉字的编码运行运行字符串常用方法由于字符串属于不可变序列下述方法中涉及到返回字符串的都是新字符串原有字符串对象不变格式居中对齐左对齐右对齐说明指定宽度填充的字符默认为空格功能返回一个宽度为的新字符串原字符串居中左对齐或右对齐出现在新字符串中如果大于字符串长度则使用进行填充你好居中对齐以空格填充你好你好居中对齐以填充你好你好右对齐以填充你好你好左对齐以填充你好运行运行方法将大写字母转换为小写字母其他字符不变并返回新字符串全部为小写字母方法将小写字母转换为大写字母其他字符不变并返回新字符串全部为大写字母用处解决有关不区分大小写问题将整个字符串首字母转换为大写形式其他字母转换为小写形式将每个单词的首字母转换为大写形式其他部分的字母转换为小写形式将大小写互换提醒均返回新字符串原字符串对象不做任何修改功能测试字符串是否为全小写大写数字如果是则返回否则返回其他的方法请通过自行查看帮助信息格式说明字符串子串开始位置结束位置查找范围开始结束不包括功能在字符串中在范围内查找并返回子串首次出现的位置索引如果没有找到则返回默认范围是整个字符串其中方法从左往右查找方法从右往左查找格式功能在字符串中查找并返回在范围内子串首次出现的位置索引如果不存在则抛出异常和的不同点默认范围是整个字符串其中方法从左往右查找方法从右往左查找格式功能在字符串中查找并返回范围内子串出现的次数如果不存在则返回默认范围是整个字符串功能以指定字符为分隔符从左往右将字符串分割开来并将分割后的结果组成列表返回如果字符串中的某种字符出现次或多次可以利用方法根据该字符把字符串分离成多个子串组成的列表对于如果不指定分隔符实际上表示以任何空白字符包括连续出现的作为分隔符空白字符包括空格换行符制表符等除了还有表示从右往左将字符串分割开来这两种方法还能指定最大分隔次数方法可用来连接序列中的元素并在两个元素之间插入指定字符返回一个字符串方法是方法的逆方法用空格分割用空格接上运行运行格式功能查找字符串中子串并用子串来替换参数默认值为表示替换所有匹配项否则为其他值时最多替换次返回替换后的新字符串原字符串不变中国北京北京地铁地铁沿线北京沿线城市北京指定最大替换次数运行运行生成字符映射表根据字符映射表替换字符这两种方法联合起来使用可以一次替换多个字符两个序列中的元素按照次序一一对应用于替换运行运行去除字符串两侧的空白字符空格回车制表符等或指定字符并返回新字符串从两端逐一去除或字符直到不是这两个字符为止中间的字符不能去除运行运行字符串模块字符串模块定义了类类函数和常量熟悉模块可以简化某些字符串的操作请输入英文单词用空格分隔用到了函数单词首字母大写运行运行说明这种方法直接用到模块中的常量和模块中方法方法的功能是在一个非空的序列中随机选择一个元素运行运行正则表达式正则表达式的元字符正则表达式模式串中的字符根据作用不同分为两类普通字符大多数字母和字符一般都会和自身匹配元字符有些字符比较特殊它们和自身并不匹配而是表明应和一些特殊的东西匹配或者会影响重复次数因为在模式串中常常有特殊字符为了书写方便在字符串前加前缀不对其进行转义第一种情况模式串中全部是普通字符导入模块模式串中全部是普通字符无匹配两处匹配查找到两个运行运行第二种情况模式串中含有元字符常用的元字符表示任意单个字符除换行符以外在中匹配所有的运行运行三引号字符串中可以有换行符本结果中没有匹配两个换行符匹配后面跟除换行符以外的任意字符的形式必须是两个字符第一个是第个是换行符以外的任意字符可以是空白符指定字符集用来指定一个字符集合例如从字符集合中必须选一个也只能选一个字符即单个字符有些元字符在方括号中不起作用作为普通字符例如和中元字符都不起作用方括号内的表示补集匹配不在区间范围内的字符例如表示除以外的字符匹配后跟或者再跟形式查找个字符第字符必须是第字符必须是中间字符只能是中的一个运行运行匹配行首匹配每行中以后面的字符开头的字符串必须放在模式串的开头英文称为英语发音记忆法数学上读作帽子戴头上可以形象的想象成首部匹配模式默认只匹配多行字符串的首行多行匹配需要单独设置参数匹配行尾匹配每行中以匹配行尾匹配每行中以匹配行尾匹配每行中以之前的字符结束的字符串英语读作音标记忆法可以形象的想象成弯曲的尾巴行尾匹配模式默认只匹配多行字符串的末行多行匹配需要单独设置参数反斜杠后面可以加不同的字符以表示不同的特殊意义四对匹配单词头或单词尾放前面会匹配单词头放后面会匹配单词尾相当于或但这两个只能用于整个字符串不能切分单词与相反匹配非单词头或单词尾不查找单词头或单词尾只查其他部分匹配任何数字字符相当于与相反匹配任何非数字字符相当于匹配任何空白字符相当于与相反匹配任何非空白字符相当于是制表符是换页符是垂直制表符匹配任何字母数字或下画线字符相当于与相反匹配任何非字母数字和下画线字符相当于也可以用于取消所有的元字符这些特殊字符都可以包含在中如将匹配任何空白字符或第一对和字符串中切分单词的分隔符包括空格换行制表符各种标点符号单词头单词尾注意不是整个字符串而是分隔后的每个单词和相反不查开头结尾的只查其他部分的第二对与数字字符等同于和相反等同于非数字字符第三对与匹配查找任何空白字符相当于横向制表符换行回车换页符纵向制表符和相反不匹配查找任何空白字符相当于与区别表示任意单个字符换行符除外表示任意单个字符空白符除外注意是大写的第四对与匹配任何字母数字或下画线字符相当于和相反不匹配任何字母数字或下画线字符相当于第五点用取消元字符此时的就是元字符匹配查找任意字符此时的就是普通的字符匹配查找第六点也可以用在内以上类元字符都是表示单个字符任意单个字符换行符除外集合中的任意单个字符行首行尾量词正则表达式能指定正则表达式的一部分的重复次数用到的元字符有").trim().substring(0, 1000);
    let value = Math.floor(Math.random() * 3) + 1000;
    while (value === prevParam || truncateDescription.length - value === prevParam) {
      value = Math.floor(Math.random() * 3) + 1000;
    }
    aiTitleRefreshIcon.style.opacity = "0.2";
    aiTitleRefreshIcon.style.transitionDuration = "0.3s";
    aiTitleRefreshIcon.style.transform = "rotate(" + 360 * refreshNum + "deg)";
    if (truncateDescription.length <= 1000) {
      let param = truncateDescription.length - Math.floor(Math.random() * 3);
      while (param === prevParam) {
        param = truncateDescription.length - Math.floor(Math.random() * 3);
      }
      aiAbstract(param);
      prevParam = param;
    } else {
      aiAbstract(value);
      prevParam = value;
    }
    showAiBtn();
    refreshNum++;
  });

  document.getElementById("go-tianli-blog").addEventListener("click", () => {
    window.open("https://afdian.net/item/886a79d4db6711eda42a52540025c377", "_blank");
  });
  
  if (false) {
    document.getElementById("ai-Toggle").addEventListener("click", () => {
      changeShowMode()
    });
  }

  function showAiBtn() {
    document.querySelectorAll(".ai-btn-item").forEach(item => {
      if (item.id !== "go-tianli-blog") {
        item.style.display = "block";
      }
      if (item.id === "go-tianli-blog") {
        item.style.display = "none";
      }
    });
  }


  aiAbstract();
  showAiBtn()
})()</script></div><article class="post-content" id="article-container"><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>这是哪托针对老师的课件整理的复习笔记，基础入门，希望能对广大基础小白受用。内容如有错误的地方，劳请留言指正。</p>
<p>笔记所有代码使用Microsoft VS Code的 Python、Jupyter 插件编译。</p>
<h1 id="二、语言基础"><a href="#二、语言基础" class="headerlink" title="二、语言基础"></a>二、语言基础</h1><h2 id="2-1标识符"><a href="#2-1标识符" class="headerlink" title="2.1标识符"></a>2.1标识符</h2><h3 id="1-2-1标识符"><a href="#1-2-1标识符" class="headerlink" title="1.2.1标识符"></a>1.2.1标识符</h3><p>标识符可以包括英文、数字以及下划线，并且：</p>
<p> 开头必须是字母或下划线；</p>
<p> 不能以数字开头开头；</p>
<p> 区分大小写的；</p>
<p> 不能出现分隔符、标点符号或者运算符；</p>
<p> 不能使用关键字：def if for while class等</p>
<p> 最好不要使用内置模块名、类型名、函数名、已经导入的模块 及其成员名</p>
<p>合法的标识符：A、ABC、aBc、a1b2、ab_123、__（连续两个下画线）、_123 等<br>非法的标识符：6a2b、abc-123、hello world（中间用了空格）、for（关键字）等</p>
<h3 id="1-2-2关键字"><a href="#1-2-2关键字" class="headerlink" title="1.2.2关键字"></a>1.2.2关键字</h3><p>关键字None</p>
<p>None是一个特殊的Python对象，不是False，不是0，也不是空字符串、空列表等。<br>None有自己的数据类型NoneType，None和任何其他数据类型进行是否相等比较永远返回False。<br>可以将None赋值给任何变量，但是不能创建其他NoneType对象。</p>
<h3 id="2-1-3变量"><a href="#2-1-3变量" class="headerlink" title="2.1.3变量"></a>2.1.3变量</h3><p>变量： 与 C与Java语言相比</p>
<p>相同点：</p>
<p>用于储存计算结果或能表示值<br>可以通过变量名访问，变量值通常是可变的。<br>变量具有名字，不同变量是通过名字相互区分的。<br>不同点：</p>
<p>变量的数据类型：不需要声明<br>变量的数据类型：可以变化（Python是动态类型语言）。<br>变量使用之前：必须赋值。<br>常量：Python没有常量，即没有语法规则限制改变一个常量的值。</p>
<p>怎么办呢？<br>使用人为约定。通常用全大写字母表示常量，编程时不要修改它的值。</p>
<p>常量示例</p>
<p>TAX_RATE &#x3D; 0.17<br>PI &#x3D; 3.14<br>CUMTXHC &#x3D; “你喜欢我吗”<br>1<br>2<br>3<br>4<br>‘<br>运行运行</p>
<h2 id="2-2数据类型"><a href="#2-2数据类型" class="headerlink" title="2.2数据类型"></a>2.2数据类型</h2><h3 id="1-整型int"><a href="#1-整型int" class="headerlink" title="1.整型int"></a>1.整型int</h3><p>整数：没有小数部分的数值，分为正整数、0和负整数。</p>
<p>100、0、 -100</p>
<p>100			#十进制<br>ob101		#二进制<br>0o11		#八进制<br>0x2F		#十六进制<br>1<br>2<br>3<br>4</p>
<h3 id="2-浮点数float"><a href="#2-浮点数float" class="headerlink" title="2.浮点数float"></a>2.浮点数float</h3><p>浮点数：包含小数点的数。</p>
<p> 15.0、0.37、-11.2、2.3e2、3.14e-2</p>
<p>15.0<br>2.3e2		#科学计数法<br>3.14e-2<br>1<br>2<br>3<br>‘<br>运行运行</p>
<h3 id="3-复数complex"><a href="#3-复数complex" class="headerlink" title="3.复数complex"></a>3.复数complex</h3><p>复数由两部分组成：实部和虚部。复数的形式为：实部+虚部j。</p>
<p> 2+3j、0.5-0.9j都是复数。</p>
<p>2+3j<br>z&#x3D;0.5-0.9j<br>z.real		#复数的实部<br>z.imag		#复数的虚部<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>两个注意点：</p>
<p>Python支持任意大的数字，仅受内存大小的限制（所以在使用时，不用考虑int、float的范围）<br>为了提高可读性，在数值中可以使用下画线</p>
<h3 id="4-布尔bool"><a href="#4-布尔bool" class="headerlink" title="4.布尔bool"></a>4.布尔bool</h3><p>布尔类型是用来表示逻辑“是”、“非”的一种类型，它只有两个值，True和False （首字母T和F是大写的）</p>
<p>Python将布尔值True实现为1（int类型），False实现为0，所以可以参与整型运算，但不建议这么做</p>
<h3 id="5-字符串str"><a href="#5-字符串str" class="headerlink" title="5.字符串str"></a>5.字符串str</h3><p>Python语言中的字符串是一种序列。字符串用单引号、双引号、三引号作为定界符。</p>
<p>“Python”、’ Hello,World ‘、“123”、’’’abcd8 ^ ‘’’等。</p>
<h3 id="6-列表-list"><a href="#6-列表-list" class="headerlink" title="6.列表 list"></a>6.列表 list</h3><p>列表也是一种序列类型。列表用方括号“［”和“］”将列表中的元素括起来。元素之间以逗号进行分隔。</p>
<p>［1,2,3,True］、［“one”,“two”,“three”,“four”］和［3,4.5, “abc”］</p>
<h3 id="7-元组-tuple"><a href="#7-元组-tuple" class="headerlink" title="7.元组 tuple"></a>7.元组 tuple</h3><p>元组也是一种序列。元组用“(”和“)”作为边界将元素括起来。元素之间以逗号分隔。</p>
<p>(1,2,3,True)、(“one”,“two”,“three”,“four”)和(3,4.5, “abc”)。</p>
<h3 id="8-字典-dict"><a href="#8-字典-dict" class="headerlink" title="8.字典 dict"></a>8.字典 dict</h3><p>字典是唯一内建的映射类型，可用来实现通过数据查找关联数据的功能。字典是键值对的无序集合。字典中的每一个元素都包含两部分：键和值。字典用大括号“{”和“}”来表示，每个元素的键和值用冒号分隔，元素之间用逗号分隔。</p>
<p>{‘1801’:‘张三’, ‘1802’:‘徐虎’, ‘1803’:‘张林’}</p>
<h3 id="9-集合-set"><a href="#9-集合-set" class="headerlink" title="9.集合 set"></a>9.集合 set</h3><p>集合是由各种不可变类型的元素组成，但元素之间无序，并且元素都不重复。</p>
<p>{‘car’, ‘ship’, ‘train’, ‘bus’}。</p>
<h2 id="2-3赋值语句、运算符"><a href="#2-3赋值语句、运算符" class="headerlink" title="2.3赋值语句、运算符"></a>2.3赋值语句、运算符</h2><h3 id="2-3-1赋值语句的格式"><a href="#2-3-1赋值语句的格式" class="headerlink" title="2.3.1赋值语句的格式"></a>2.3.1赋值语句的格式</h3><p>&lt;变量&gt;&#x3D;&lt;表达式&gt;</p>
<p>#常规：同java<br>#特殊：多变量赋值<br>x,y&#x3D;1,2<br>a &#x3D; b &#x3D; 3<br>#两变量的交换<br>x,y&#x3D;1,2<br>x,y&#x3D;y,x<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>‘<br>运行运行</p>
<h3 id="2-3-2运算符"><a href="#2-3-2运算符" class="headerlink" title="2.3.2运算符"></a>2.3.2运算符</h3><h5 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h5><p>在Python中，算术运算符有：+（加）、-（减）、*（乘）、&#x2F;（真除法）、&#x2F;&#x2F;（求整商）、%（取模）、**（幂）。</p>
<p>需要说明的几点：</p>
<p>（1） + 运算符不支持不同类型的对象之间的连接</p>
<p>3+”ab”			#错误：不同类型<br>str(3)+”ab”		#正确：通过类型转换函数str()将数字3转换成字符串’3’<br>1<br>2<br>（2） * 运算符可以用于列表、元组或字符串与整数的相乘，用于将这些序列重复整数所指定的次数。它不适用于字典和集合与整数的相乘。</p>
<p>[1,3,5] * 2         # 列表list<br>#[1, 3, 5, 1, 3, 5]<br>(‘a’,’b’,’c’) * 2   # 元组tuple<br>#(‘a’, ‘b’, ‘c’, ‘a’, ‘b’, ‘c’)<br>‘Hello’ * 2         # 字符串str<br>#’HelloHello’<br>{1801:’Lily’} * 2   # 字典dict：不可以。因为字典的键key不能重复。<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>（3）** 运算符：幂运算，与内置函数pow()相同</p>
<p>（4）&#x2F; 真除法 与 &#x2F;&#x2F;整数除法</p>
<p>5&#x2F;3         # 真除 1.6666666666666667<br>5&#x2F;&#x2F;3        # 取商的整数部分 1<br>7.4&#x2F;&#x2F;3      # 操作数为实数时，则取实数形式的整数（即*.0） 2.0<br>1<br>2<br>3<br>‘<br>运行运行</p>
<h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h4><p>六个：&lt;（小于）、&lt;&#x3D;（小于等于）、&gt;（大于）、&gt;&#x3D;（大于等于）、&#x3D;&#x3D;（等于）、!&#x3D;（不等于）。</p>
<p>结果：布尔值True或False</p>
<p>所有的字符串都是Unicode字符串；</p>
<p>单个字符：可以通过ord()函数获取该字符的Unicode码，<br>通过chr()函数把编码转换为对应的字符。<br>ord(‘a’)   #97<br>chr(97)  #得到对应的字符 a<br>ord(‘我’)  #25105<br>chr(25105)  #我<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>注意：字符串和数字属于不可比较大小的</p>
<p>列表比较大小：也是从左到右逐个元素的依次比较，类似 字符串之间的比较</p>
<p>列表中：字符串与数值也是不能比较的</p>
<p>[1,2,3]&gt;[‘a’,’b’]          # 出错<br>[‘ab’,’c’,6]&gt;[‘ab’,3,’a’]  # 出错<br>1<br>2<br>（5）关系运算符可以连用，等价于某几个用and连接起来的表达式。注意：C语言和Java语言均不可这么用。</p>
<p>3&lt;5&gt;2         #与 下式 含义相同 True<br>3&lt;5 and 5&gt;3		#True<br>3&lt;5&#x3D;&#x3D;5        #与 下式 含义相同 True<br>3&lt;5 and 5&#x3D;&#x3D;5  #True<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>（6）因为精度问题可能导致实数运算有一定的误差</p>
<p>要尽可能地避免在实数之间进行相等性判断<br>0.4-0.3          # 有误差了<br>#0.10000000000000003<br>0.1&#x3D;&#x3D;0.4-0.3     # 误差 导致 不相等<br>#Flase<br>#解决方法：使用实数之间的差值的绝对值是否小于某一个很小的数来作为实数之间是否相等的判断。<br>abs(0.1-(0.4-0.3))&lt;0.00000000001    # True，表示 0.1 和 0.4-0.3是相等的<br>#True<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>‘<br>运行运行</p>
<h4 id="3-测试运算符"><a href="#3-测试运算符" class="headerlink" title="3.测试运算符"></a>3.测试运算符</h4><p>四个：in、not in、is、is not。<br>结果：返回布尔值True或False</p>
<p>2 in [2,3,4]        # 列表 True<br>a &#x3D; 3<br>a in [2,3,4]        #True</p>
<p>b&#x3D;”abcedfg”        # 测试 字符串str<br>“ab” in b           #True</p>
<p>a &#x3D; (1,2,3)<br>b &#x3D; (1,2,3)<br>a is b              # False: 虽然a、b内容一样，但不是同一个对象。<br>a is not b          # True<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>‘<br>运行运行<br>（7）同一性测试运算符is和is not测试是否为同一个对象或内存地址是否相同，返回布尔值True和False。</p>
<p>x&#x3D;[1,3,5]<br>y&#x3D;[1,3,5]<br>x is y      #测试x、y是否为同一个对象：x，y相等，但不是同一个对象   Flase<br>x is not y  #True<br>x&#x3D;&#x3D;y        #测试x、y是否相等  True<br>1<br>2<br>3<br>4<br>5<br>‘<br>运行运行<br>注意：</p>
<p>是否相等&#x3D;&#x3D;：只是测试值是否相同，<br>是否为同一个对象is：指的是是否指向同一个对象（如果指向同一个对象，则内存地址应该相同，当然也相等）<br>内置函数id()返回对象的标识（内存地址）</p>
<p>id(x)       # 每个人运行得到的内存地址可能会不一样   3055563066432<br>z&#x3D;x         # 赋值语句z&#x3D;x，则z和x不仅值相等而且指向同一个对象，z、x的内存地址相同。<br>z is x  #True<br>1<br>2<br>3</p>
<h4 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h4><p>在Python中，逻辑运算符有：and（与）、or（或）、not（非）。通过逻辑运算符可以将任意表达式连接在一起。</p>
<p>哪些是False：False、None、数值类型中的0、空字符串’’、空元组()、空列表[]、空字典{}、空集合{}等</p>
<p>not False  #True<br>not True   #Flase<br>not 3           # 非零值为True  Flase<br>not 0           # 零值为false   True<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>（10）逻辑操作符and和or也称作短路操作符，具有惰性求值的特点：</p>
<p>短路运算：表达式从左向右解析，一旦结果可以确定就停止。<br>注意：逻辑运算符and、or不一定会返回布尔值True和False。<br>and(与运算)：结果不一定为True或False</p>
<p>当计算表达式exp1 and exp2时，<br>①先计算exp1的值，当exp1的值为True或非空值（非0、非None、值非空的其他数据类型），才计算并输出exp2的值；<br>②当exp1的值为False或空值（0、None、值为空的其他数据类型），直接输出exp1的值，不再计算exp2。</p>
<p>True and 3     # 第一个为True，则输出第二个的值（结果与第二个值有关）：下同   3<br>4 and False  #Flase<br>3&lt;4 and 4&gt;5           # 3&lt;4的值为True，则计算并输出4&gt;5的值False<br>False and 4    # 第一个为False，则不再计算第二个的值，直接输出第一个的值：下同<br>0 and ‘c’             # 直接输出0<br>() and ‘c’            # 直接输出()<br>1<br>2<br>3<br>4<br>5<br>6<br>‘<br>运行运行<br>or或运算：结果不一定为True或False</p>
<p>当计算表达式exp1 or exp2时：<br>①先计算exp1的值，当exp1的值为True或非空值（非0、非None、值非空的其他数据类型），直接输出exp1的值，不再计算exp2；<br>②当exp1的值为False或空值（0、None、值为空的其他数据类型），才计算并输出exp2的值。</p>
<p>True or 3    #第一个为True，则不再计算第二个的值，直接输出第一个的值：下同<br>3&lt;4 or 4&gt;5                   #3&lt;4的值为True，则直接输出True<br>False or 4    #第一个为False，则继续计算第二个的值，输出第二个的值：下同<br>0 or ‘c’<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>（11）赋值运算符（&#x3D;）、复合赋值运算符（+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、&#x2F;&#x2F;&#x3D;、%&#x3D;、**&#x3D;）、位运算符（&amp;、|、^等）等。<br>此处基本同C语言。</p>
<p>(12)特别注意： Python没有自加++与自减–</p>
<p>（13）优先级小括号（）最高</p>
<h2 id="2-4从控制台输入和输出"><a href="#2-4从控制台输入和输出" class="headerlink" title="2.4从控制台输入和输出"></a>2.4从控制台输入和输出</h2><h3 id="1-input-函数"><a href="#1-input-函数" class="headerlink" title="1. input()函数"></a>1. input()函数</h3><pre><code>用于输入数据，无论用户输入什么内容，该函数都返回字符串类型。
</code></pre>
<p>其格式如下：</p>
<p>input(prompt&#x3D;None) # prompt&#x3D;None，表示提示语默认为空</p>
<p>x &#x3D; input(“请输入x值：”)    # 请输入x值：100<br>type(x)                     # 查看x的类型，为&lt;class ‘str’&gt;   #str<br>1<br>2<br>‘<br>运行运行</p>
<h3 id="2-类型转换函数"><a href="#2-类型转换函数" class="headerlink" title="2.类型转换函数"></a>2.类型转换函数</h3><p>1）int()函数<br>格式1：int([x])<br>功能：截取数字的整数部分或将字符串转换成一个整数；如果不给定参数则返回0。</p>
<p>int()           #1、没有参数时：0<br>int(23.74)      #2、浮点数：直接截取整数部分（不进行四舍五入）<br>int(-3.52)<br>int(‘4’)        #3、整数字符串<br>int(‘45.6’)     #4、浮点数字符串：错误  。<br>1<br>2<br>3<br>4<br>5<br>注意：int()函数不接受带小数的数字字符串</p>
<p>格式2 ：int(x, base&#x3D;10)<br>功能：把base进制的字符串x转换为十进制，base为基数(进制)，默认为十进制<br>base的有效值范围为0和2-36</p>
<p>int(‘1001001’,2)     #1、二进制的数1001001转换为十进制数    73<br>int(‘2ef’,16)        #2、十六进制的数2ef转换为十进制数   751<br>int(‘27’,8)          #3、八进制的数27转换为十进制数  23<br>int(‘101.001’,2)     #4、不允许二进制的小数（不接受带小数的数字）<br>int(‘0b110’, base&#x3D;0) #5、二进制的数110转换为十进制数  6</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>2)float()函数<br>格式：float(x&#x3D;0, &#x2F;)<br>功能：将一个数字或字符串转换成浮点数</p>
<p>float()         # 默认参数x为0<br>float(‘inf’)  #无穷大，inf不区分大小写<br>int(“3+5”)      # 错误<br>float(“3.5*2”)  # 错误<br>#int()、float()不能转换表达式字符串，所以引入eval()函数<br>1<br>2<br>3<br>4<br>5</p>
<ol start="3">
<li>eval()函数<br> 格式 ：eval(source, globals&#x3D;None, locals&#x3D;None, &#x2F;)<br> 功能：将 source 字符串 当做一个python 表达式 进行解析和计算，返回计算结果。<br> 参数说明：<br> source是一个字符串，这个字符串能表示成Python表达式，或者是能够通过编译的代码；<br> globals是可选的参数，默认为None，如果设置属性不为None的话，就必须是dictionary对象；<br> locals也是可选的参数，默认为None，如果设置属性不为None的话，可以是任何map对象。</li>
</ol>
<p>字符串中是表达式：返回表达式的值；<br>字符串中是列表、元组或字典：得到真正的列表、元组或字典；<br>字符串中是能够通过编译的代码：执行代码。<br>x&#x3D;3<br>eval(‘x+1’)            # 表达式：x+1<br>eval(‘3+5’)            #8<br>eval(‘[1,2,3]’)        # 返回列表[1,2,3]<br>eval(‘{1:23,2:32}’)    # 返回字典{1:23,2:32}<br>eval(‘print(3<strong>2)’)     # 执行print(3</strong>2)语句  9<br>eval(“<strong>import</strong>(‘os’).getcwd()”) # 执行语句：获取当前目录<br>#####组合使用： int()、float()、eval()函数和input（）<br>x&#x3D;eval(input(“请输入x值：”))    #输入列表格式：[1,2,3]<br>x                              #获得列表<br>x&#x3D;eval(input(“请输入x值：”))    #输入字典格式：{‘a’:1,’b’:2}<br>x                              #获得字典<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<h3 id="3-数据的输出"><a href="#3-数据的输出" class="headerlink" title="3.数据的输出"></a>3.数据的输出</h3><p>print()函数<br>格式如下:</p>
<p>print(value, …, sep&#x3D;’ ‘, end&#x3D;’\n’, file&#x3D;sys.stdout, flush&#x3D;False)</p>
<p>各参数的解释如下:</p>
<p>value：需要输出的对象，一次可以输出一个或者多个对象(其中…表示任意多个对象)，对象之间要用逗号(,)分隔<br>sep：对象之间的间隔符，默认用一个空格分隔；<br>end：以何字符结尾，默认值是换行符；<br>file：表示输出位置，可将输出到文件，file指定的对象要有“写”的方法，默认值是sys.stdout(标准输出，即控制台屏幕)；<br>flush：将缓存里面的内容是否强制刷新输出，默认值是False（一般不需要）。</p>
<p>print(‘1.hello’,’world’,’!’)          #一次输出三个对象，中间默认用空格隔开<br>print(‘2.hello’,’world’,’!’,sep&#x3D;’<em>‘)  #一次输出三个对象，中间用</em>隔开<br>print(‘3.hello’,’world’,’!’,sep&#x3D;’’)   #一次输出三个对象，中间无分隔，因为sep参数值被设置为空字符串了<br>print(‘4.hello’,’world’,’!’,end&#x3D;’!’)  #一次输出三个对象，以!结尾（不换行）<br>print(‘5.hello’,’world’,’!’,sep&#x3D;’,’, end&#x3D;’!’)  #一次输出三个对象，以，分隔，以！结尾<br>1<br>2<br>3<br>4<br>5<br>‘<br>运行运行<br>可以看出：print函数默认输出是换行的。如果要实现不换行，需要在变量末尾设置 end参数</p>
<h2 id="2-5内置函数"><a href="#2-5内置函数" class="headerlink" title="2.5内置函数"></a>2.5内置函数</h2><p>函数	功能<br>abs(x)	返回数字x的绝对值，如果给出复数，返回值就是该复数的模<br>bin(x)	把整数x转换为二进制<br>divmod(x,y)	函数返回整商和余数的元组<br>eval(s[,globals[,locals]])	计算字符串中表达式的值并返回<br>help(obj)	返回对象obj的帮助信息<br>id(obj)	返回对象obj的标识（内存地址）<br>input(prompt&#x3D;None, &#x2F;)	接受键盘输入，显示提示信息，返回字符串<br>len(obj)	返回对象obj（列表、元组、字典、字符串、集合、range对象）的元素个数<br>map(func, *iterables)	包含若干函数值的map对象，其中func表示函数，iterables表示迭代对象，将函数作用于迭代对象<br>max(x[,y,z…])、min(x[,y,z…])	返回给定参数的最大值、最小值，参数可以为可迭代对象<br>pow(x,y[,z])	pow()函数返回以x为底，y为指数的幂。如果给出z值，该函数就计算x的y次幂值被z取模的值<br>print(value, …, sep&#x3D;’ ‘, end&#x3D;’\n’, file&#x3D;sys.stdout, flush&#x3D;False)	输出对象，默认输出到屏幕，相邻数据之间使用空格分隔，结尾以换行符结束<br>range([start,]end[,step])	返回range对象，该对象包含按参数（[start,end)范围内，step为步长）生成的整数<br>round(x[,n])	返回浮点数x的四舍五入值，若不给出n值，则返回整数；给出n值，则代表舍入到小数点后的位数<br>sorted(iterable, &#x2F;, *, key&#x3D;None, reverse&#x3D;False)	返回排序后的列表，其中iterable表示要排序的序列或迭代对象，key表示排序规则，reverse表示升序或降序，默认升序<br>sum(iterable, start&#x3D;0, &#x2F;)	返回序列iterable中所有元素之和，如果指定起始值start，则返回start+sum(iterable);如果iterable为空，则返回start<br>chr(i)	返回Unicode编码为i所对应的字符，0 &lt;&#x3D; i &lt;&#x3D; 0x10ffff<br>complex(real[,imag])	把字符串或数字转换为复数，如果第1个参数是字符串，不能使用第2个参数<br>float(x&#x3D;0, &#x2F;)	把一个数字或字符串转换成浮点数<br>hex(x)	把整数转换成十六进制串<br>int(x[,base])	把数字和字符串转换成一个整数，或把base进制的字符串x转换为十进制，base为可选的基数，默认为十进制<br>list([x])、tuple([x])、dict([x])、set([x])	将对象x转换成列表、元组、字典、集合，或生成空列表、空元组、空字典、空集合<br>oct(x)	把给出的整数x转换成八进制串<br>ord(x)	返回一个字符的Unicode编码</p>
<h1 id="三、流程控制"><a href="#三、流程控制" class="headerlink" title="三、流程控制"></a>三、流程控制</h1><h2 id="3-1分支结构"><a href="#3-1分支结构" class="headerlink" title="3.1分支结构"></a>3.1分支结构</h2><p>单分支if语句</p>
<p>双分支if&#x2F;else语句</p>
<p>多分支if&#x2F;elif&#x2F;else语句</p>
<p>选择结构的‘嵌套’</p>
<p>选择结构的三元运算</p>
<p>【注意】：Python没有switch语句</p>
<p>语法类似于java此处省略</p>
<h2 id="3-2循环结构"><a href="#3-2循环结构" class="headerlink" title="3.2循环结构"></a>3.2循环结构</h2><p>定义：</p>
<p>给定的判断条件为真（包括非零、非空）时，重复执行某些操作；<br>判断条件为假（包括零、空）时，结束循环。<br>循环分类：</p>
<p>while语句<br>for语句<br>循环中断:</p>
<p>break<br>continue<br>带else的循环语句（Python特有）</p>
<p>与java类似相关内容请参考java</p>
<h3 id="3-2-1for循环语句"><a href="#3-2-1for循环语句" class="headerlink" title="3.2.1for循环语句"></a>3.2.1for循环语句</h3><p>for语句通过遍历一个序列（字符串、列表、元组）或迭代器等可迭代对象中的每个元素来建立循环。<br>for语句的语法形式如下所示：</p>
<p>for  变量   in   序列或迭代器等可迭代对象:<br>    循环体<br>1<br>2<br>补充<br>range（）函数：返回可迭代对象。</p>
<p>语法格式如下：<br>range(start, stop[, step])</p>
<p>功能：<br>产生一个从start开始（包括start,默认为0），到stop结束（不包括stop），两个整数对象之间间隔step（默认为1）的可迭代对象。</p>
<p>可以用for循环直接遍历range函数产生的可迭代对象</p>
<p>for i in range(0,10):   # 默认step：1<br>    print(i,end&#x3D;’ ‘)<br>for i in range(3,15):<br>    print(i,end&#x3D;’ ‘)<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>range对象可以被转换成列表或元组，例如：</p>
<p>y&#x3D;list(x)   # range对象转换为list列表对象<br>z&#x3D;tuple(x)  # range对象转换为tuple元组对象<br>1<br>2</p>
<h3 id="3-2-2-break语句和continue语句"><a href="#3-2-2-break语句和continue语句" class="headerlink" title="3.2.2 break语句和continue语句"></a>3.2.2 break语句和continue语句</h3><p>详细解释：</p>
<p>break语句：可以用在while和for循环中。在循环进行过程中，如果某个条件被满足（一般通过if语句判断是否满足执行break语句的条件），则可以通过break语句立即终止本层循环。如果break语句在具有两层循环嵌套的内层循环中，则只终止内层循环，进入到外层循环的下一条语句继续执行。<br>continue语句：可以用在while和for循环中。在循环体执行过程中，如果遇到continue语句，程序会跳过本次循环的循环体剩余语句，回到循环开始的地方重新判断是否进入下一次循环。<br>精简：</p>
<p>break语句终止整个当前循环；<br>continue语句的执行不会终止整个当前循环，只是提前结束本次循环，跳过循环体中本次循环的剩余语句，提前进入到下一次循环。<br>再精简：</p>
<p>同C语言。</p>
<h3 id="3-2-3-带else的循环语句（与C语言不同，不建议用）"><a href="#3-2-3-带else的循环语句（与C语言不同，不建议用）" class="headerlink" title="3.2.3 带else的循环语句（与C语言不同，不建议用）"></a>3.2.3 带else的循环语句（与C语言不同，不建议用）</h3><p>Python中的while和for语句后面还可以带有else语句块。</p>
<p>语句语法如下：</p>
<p>while 条件表达式:<br>    循环体<br>else：<br>    else语句块<br>1<br>2<br>3<br>4<br>三种执行流程：</p>
<p>1）正常循环：当条件表达式为真（True、非空、非零）时，反复执行循环体。</p>
<p>2）执行一次else：当条件表达式为假（False、零、空）而导致循环终止（或无法进入循环），else语句块执行一次，然后结束该循环结构。</p>
<p>3）不执行else：如果该循环是因为执行了循环体中的break语句而导致循环终止，else语句块不会执行，直接结束该循环结构。</p>
<p>例：从键盘输入一个正整数n，用while循环找出小于等于该整数n且能被23整除的最大正整数。如果找到了，输出该整数；如果没有找到，则输出“未找到”</p>
<p>n&#x3D;int(input(‘请输入一个正整数：’))<br>i&#x3D;n<br>while i&gt;0:<br>    if i % 23 &#x3D;&#x3D; 0:<br>        print(“小于等于”,n,”且能被23整除的最大正整数是：”,i)<br>        break<br>    i &#x3D; i-1<br>else:<br>    print(“未找到。”)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>‘<br>运行运行<br>带else的for语句语法如下：</p>
<p>for 变量 in 序列或迭代器等可迭代对象:<br>    循环体<br>else:<br>    else语句块<br>1<br>2<br>3<br>4</p>
<h3 id="3-2-4循环嵌套"><a href="#3-2-4循环嵌套" class="headerlink" title="3.2.4循环嵌套"></a>3.2.4循环嵌套</h3><h1 id="四、常用数据结构"><a href="#四、常用数据结构" class="headerlink" title="四、常用数据结构"></a>四、常用数据结构</h1><h2 id="4-1-序列"><a href="#4-1-序列" class="headerlink" title="4.1 序列"></a>4.1 序列</h2><h3 id="4-1-1列表-list"><a href="#4-1-1列表-list" class="headerlink" title="4.1.1列表 list"></a>4.1.1列表 list</h3><p>列表是Python中最基本的数据结构，是最常用的数据类型。</p>
<p>列表的特点：</p>
<p>1.列表将由若干数据作为元素的序列放置在一对方括号中，元素之间以逗号分隔。</p>
<p>2.列表中的元素允许重复。</p>
<p>3.列表是可以修改的：增删改查。(以上类似数组)</p>
<p>4.列表元素可以由任意类型的数据构成。同一列表中各元素的类型可以各不相同。（不同于数组）</p>
<p>列表的操作汇总：</p>
<p>创建列表： [,]、list()</p>
<p>访问元素: list1[n]</p>
<p>更改元素值</p>
<p>切片: [::]形式</p>
<p>列表计算： 列表+列表，列表 * 整数</p>
<p>列表</p>
<p>方法<br>1<br>-查：.index()、.count()、<br>-增：.extend()、.insert()、.append()、<br>-删：.pop()、.remove()、.clear()<br>-序：.sort()、.reverse()）</p>
<p>序列函数（不仅仅用于列表）：len()、max()、min()、sorted()、reversed()</p>
<p>命令：del 列表</p>
<h3 id="1-列表的创建"><a href="#1-列表的创建" class="headerlink" title="1.列表的创建"></a>1.列表的创建</h3><p>创建 一维列表</p>
<p>list1 &#x3D; [3.14, 1.61, 0, -9, 6,3.14]  # 1.[,…,]方式: 普通列表<br>list2 &#x3D; [‘train’, ‘bus’, ‘car’, ‘ship’]<br>list3 &#x3D; [‘a’,200,’b’,150, ‘c’,100.5]<br>list4 &#x3D; []                           # 2.[]方式：创建空列表<br>list5&#x3D;list()                         # 3.list()函数</p>
<p>创建 二维列表</p>
<p>list_sample&#x3D;[[‘IBM’,’Apple’,’Lenovo’],[‘America’,’America’,’China’]]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>‘<br>运行运行</p>
<h2 id="2-列表的元素访问"><a href="#2-列表的元素访问" class="headerlink" title="2.列表的元素访问"></a>2.列表的元素访问</h2><p>索引：列表中的每个元素被关联一个序号，即元素的位置。<br>索引值是从0开始，第二个则是 1，以此类推，从左向右逐渐变大；<br>列表也可以从后往前，索引值从-1开始，从右向左逐渐变小。<br>适用于所有序列类型的对象：列表、元组、字符串</p>
<h2 id="3-修改元素"><a href="#3-修改元素" class="headerlink" title="3.修改元素"></a>3.修改元素</h2><p>通过重新赋值来更改某个元素的值<br>注意合法索引范围，超过范围则会出错。</p>
<h2 id="4-列表切片"><a href="#4-列表切片" class="headerlink" title="4.列表切片"></a>4.列表切片</h2><p>在列表中，可以使用切片操作来选取指定位置上的元素组成新的列表。</p>
<p>简单的切片方式为（步长默认为1）：原列表名[start : end]</p>
<p>[start：end)：左封闭(能取到)，右开放(取不到)<br>左索引start为0时可缺省，右索引end为列表长度时可缺省。<br>vehicle &#x3D; [‘train’, ‘bus’, ‘car’, ‘ship’]<br>vehicle[0:3]<br>vehicle[0:1]    # 取第0号元素<br>vehicle[:3]     # start缺省：为 0<br>vehicle[3:]     # end缺省：为列表长度4（长度从1开始计算）<br>vehicle[:]      # start、end都缺省：全列表<br>vehicle[3:3]    # start等于end时：空列表<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>‘<br>运行运行<br>也可以使用负数作索引</p>
<p>vehicle &#x3D; [‘train’,’bus’,’car’,’ship’]<br>vehicle[-3:-1]	    # 索引为-3和-2位置上的元素:依然是从左往右取     [‘bus’, ‘car’]<br>vehicle[-2:]	    # 索引从-2至列表末尾位置上的元素     [‘car’, ‘ship’]<br>1<br>2<br>3<br>‘<br>运行运行<br>切片步长：非零整数（即可正可负，但不能为0）（跳着切片）</p>
<p>原列表名[start : end : step]</p>
<p>步长为1时：参数可以省略。<br>步长不为1时：该参数不可省略。<br>n&#x3D;list(range(10))   # range()函数为0-9的可迭代对象，用list()函数转换为从0到9的列表n<br>n[0:10:2]		    # 步长为2，索引值从0开始，每次增长2，但索引值必须小于10。    [0, 2, 4, 6, 8]<br>n[::3]              # [0,3,6,9]<br>n[7:2:-1]	        # 步长为负数时，start不能小于end值。    [7, 6, 5, 4, 3]<br>n[11::-2]  	        # 11超过范围，实际索引从最后一个元素开始。不出错。     [9, 7, 5, 3, 1]<br>n[::-2]	            # 这里步长为负数，表示在整个列表内，从后往前取值。     [9, 7, 5, 3, 1]<br>n[::-1]             # 作用：逆序   [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>‘<br>运行运行<br>利用切片还可以更改元素值。有点类似多变量赋值的感觉。</p>
<p>n[2:4]&#x3D;[110,1]		# 分别更改索引号为2和3的位置上元素值。<br>n[-5::2]&#x3D;[-1,-2,-3]	# 分别更改索引号为-5、-3、-1三个位置上的元素值。<br>n[2:5]&#x3D;[10,11]      # 少给1个数呢？少的那个数，被删掉了<br>1<br>2<br>3</p>
<h3 id="5-del命令"><a href="#5-del命令" class="headerlink" title="5. del命令"></a>5. del命令</h3><pre><code>注意是命令，不是函数或方法。
</code></pre>
<p>从列表中删除元素，也可以删除整个列表</p>
<p>vehicle &#x3D; [‘train’, ‘bus’, ‘car’, ‘ship’]<br>del vehicle[3]<br>vehicle             # 删除了’ship’<br>del vehicle         # 删除列表vehicle<br>vehicle             # 列表vehicle不存在了：再次使用出错<br>1<br>2<br>3<br>4<br>5<br>补充：方法、函数、命令的概念上的区别</p>
<p>命令：内置命令，没有括号<br>函数：是指内置函数（或用import导入的某模块的函数），直接可以使用，比如pow(2,3)<br>方法：是指某个对象的方法，格式为对象名.方法名()，比如list.sort()，是指列表list对象的sort()方法<br>6.列表运算<br>1)列表相加</p>
<p>通过列表相加的方法生成新列表<br>支持 复合赋值 +&#x3D;<br>vehicle1 &#x3D; [‘train’, ‘bus’, ‘car’, ‘ship’]<br>vehicle2 &#x3D; [‘subway’, ‘bicycle’]<br>vehicle2 + vehicle1         # 结果为新列表，原列表不变<br>vehicle+&#x3D;[‘bike’]           # 复合赋值语句<br>vehicle1-vehicle2           # 不支持 减 运算：出错<br>1<br>2<br>3<br>4<br>5<br>2)列表乘法</p>
<p>列表 * 整数n：生成一个新列表。<br>新列表：原来列表的元素重复n次。<br>vehicle1 &#x3D; [‘train’, ‘bus’]<br>vehicle1 * 3      #[‘train’, ‘bus’, ‘train’, ‘bus’, ‘train’, ‘bus’]<br>vehicle &#x3D; vehicle1 * 2  # 相乘语句<br>vehicle *&#x3D; 2            # 复合赋值语句，相当于重新定义了vehicle列表<br>1<br>2<br>3<br>4<br>‘<br>运行运行</p>
<h3 id="7-列表方法：类型本身的方法"><a href="#7-列表方法：类型本身的方法" class="headerlink" title="7.列表方法：类型本身的方法"></a>7.列表方法：类型本身的方法</h3><ol>
<li><p>index(value[,start&#x3D;0[,stop]])<br> 返回第一个value值元素索引位置。<br> start没指定：则从索引为0的位置开始查找，否则从索引为strat的位置开始查找。<br> stop没指定：可以查找到列表最后元素，否则在位于[start, stop)内的索引区间查找。<br> 如果找不到匹配项，就会引发异常。<br> vehicle &#x3D; [‘train’, ‘bus’, ‘car’, ‘subway’, ‘ship’, ‘bicycle’, ‘car’]<br> vehicle.index(‘car’)          # 整个列表范围内’car’第1次出现的索引位置是2<br> vehicle.index(‘car’, 3)       # 在从索引为3开始，’car’第1次出现的索引位置是<br> 1<br> 2<br> 3<br> ‘<br> 运行运行</p>
</li>
<li><p>count()<br> 统计某个元素在列表中出现的次数。</p>
</li>
<li><p>append()<br> 追加单个元素到列表的尾部，只接受<strong>一个</strong>元素<br> 元素可以是任何数据类型，被追加的元素在列表中保持着原结构类型。</p>
</li>
<li><p>extend()<br> 在列表的末尾一次性追加另一个列表中的多个值（只能有一个参数）<br> 应用：用新列表扩展原有的列表<br> insert()<br> 将一个元素插入到指定位置。<br> 两个参数：第一个参数是索引点，即插入的位置，第二个参数是插入的元素。<br> vehicle &#x3D; [‘train’, ‘bus’, ‘car’, ‘ship’]<br> vehicle.insert(3,’plane’)   # 插入后，在3位置<br> vehicle.insert(-2,’bike’)   # 注意插入后的位置，在-2位置的前面<br> 1<br> 2<br> 3<br> ‘<br> 运行运行</p>
</li>
<li><p>remove()<br> 用于移除列表中与某值匹配的第一个元素<br> 如果找不到匹配项，就会引发异常</p>
</li>
<li><p>pop()<br> 移除列表中的一个元素（默认为最后一个元素），并且返回该元素的值（出栈）<br> 可以指定索引位置<br> 当不在索引范围内或者是空列表中，均会触发异常</p>
</li>
<li><p>clear()<br> 删除列表中所有元素，但保留列表对象。<br> 请注意与del命令的区别：del命令删除整个列表时，列表对象不再保留</p>
</li>
<li><p>reverse()方法<br> 用于将列表中的元素位置反向存放。<br> 列表中可以有不同类型的元素，reverse()方法只是将位置反转</p>
</li>
<li><p>sort()<br> 元素排序：默认按<em><strong>升序</strong></em>排列。</p>
</li>
</ol>
<p>两个参数：</p>
<p>reverse参数：默认为False（升序），若等于True表示降序排序（如果包含的是字符串，按字符串排序规则）。<br>key参数：指定排序方式。<br>numbers&#x3D;[12,34,3.14,99,-10]<br>numbers.sort()              # 按数值大小升序<br>numbers.sort(reverse&#x3D;True)  # 降序<br>numbers.sort(key&#x3D;str)       # 按转换为字符串后的大小升序排列，ASCII码<br>nv&#x3D;[12,’bus’,99,’train’]    # 排序的元素必须是可比较大小（字符串和数值不能比较）<br>nv.sort()<br>1<br>2<br>3<br>4<br>5<br>6<br>8.列表函数：不单单用于列表的函数，也可用于其他数据结构</p>
<h3 id="9-列表遍历"><a href="#9-列表遍历" class="headerlink" title="9.列表遍历"></a>9.列表遍历</h3><p>通过for语句或者while语句循环遍历所有元素<br>vehicle&#x3D;[‘train’, ‘bus’, ‘car’, ‘subway’, ‘ship’, ‘bicycle’]<br>for i in vehicle:		      #1.直接遍历每一个元素<br>    print(i,end&#x3D;’ ‘)<br>i&#x3D;0<br>while i&lt;len(vehicle):	       #3.while循环：通过索引遍历每一个元素<br>    print(vehicle[i],end&#x3D;’ ‘)<br>    i+&#x3D;1<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>‘<br>运行运行</p>
<h2 id="4-1-2元组"><a href="#4-1-2元组" class="headerlink" title="4.1.2元组"></a>4.1.2元组</h2><p>元组和列表十分相似，元组是用一对圆括号（）括起、用逗号分隔的多个元素的组合。</p>
<p>属于序列：有顺序，可以重复；<br>元组是不可更改的，是不可变对象：元组创建之后就不能修改、添加、删除成员。<br>元组的上述特点使得其在处理数据时效率较高，而且可以防止出现误修改操作。</p>
<h3 id="1-元组的创建"><a href="#1-元组的创建" class="headerlink" title="1.元组的创建"></a>1.元组的创建</h3><p>tuple1 &#x3D; (‘a’,200,’b’,150, ‘c’,100)  # 1.创建多个元素的元组<br>tuple3 &#x3D; (3,)  #创建单一元素的元组，后面的逗号不能省略(省略后，就变成字符串类型了<br>tuple4&#x3D;()            # 2.创建空元组<br>tuple5 &#x3D; tuple()     # 3.使用tuple函数，创建空元组<br>1<br>2<br>3<br>4<br>‘<br>运行运行</p>
<h3 id="2-元组的访问"><a href="#2-元组的访问" class="headerlink" title="2.元组的访问"></a>2.元组的访问</h3><p>和列表一样，可以通过索引(访问单个)、切片(访问多个)来访问元组的成员</p>
<p>vehicle&#x3D;(‘train’, ‘bus’, ‘car’, ‘ship’, ‘subway’, ‘bicycle’)<br>vehicle[-3]           # 索引方式<br>vehicle[0:3:2]        # 切片方式<br>vehicle[1]&#x3D;’bike’     #元组：不能更改元素值。不能赋值。 报错<br>1<br>2<br>3<br>4<br>3.元组的运算<br>1)元组相加<br>通过元组相加的方法生成新元组</p>
<p>vehicle1 &#x3D; (‘train’, ‘bus’, ‘car’, ‘ship’)<br>vehicle2 &#x3D; (‘subway’, ‘bicycle’)<br>vehicle1 &#x3D; vehicle1 + vehicle2  # 正确：重新定义了vehicle1<br>1<br>2<br>3<br>‘<br>运行运行<br>2)元组相乘<br>用数字n乘以一个元组，会生成一个新元组。<br>在新元组中原来的元组元素将依次被重复n次。<br>vehicle1 &#x3D; (‘train’, ‘bus’, ‘car’, ‘ship’)<br>vehicle1*2<br>1<br>2<br>‘<br>运行运行<br>3).元组的遍历<br>通过for语句或者while语句(同列表方法)</p>
<h3 id="4-1-3-列表与元组的转换"><a href="#4-1-3-列表与元组的转换" class="headerlink" title="4.1.3 列表与元组的转换"></a>4.1.3 列表与元组的转换</h3><h4 id="1-列表–-gt-元组"><a href="#1-列表–-gt-元组" class="headerlink" title="1.列表–&gt;元组"></a>1.列表–&gt;元组</h4><p>tuple()函数：接受一个列表，并返回一个包含同样元素的元组。<br>从结果上看，tuple()函数冻结了列表<br>vehicle &#x3D; [‘train’, ‘bus’, ‘car’, ‘ship’, ‘subway’, ‘bicycle’]  #list<br>tuple(vehicle) #元组<br>t &#x3D; tuple(vehicle)<br>1<br>2<br>3<br>‘<br>运行运行</p>
<h4 id="2-元组–-gt-列表"><a href="#2-元组–-gt-列表" class="headerlink" title="2.元组–&gt;列表"></a>2.元组–&gt;列表</h4><p>list()函数：接受一个元组，并返回一个包含同样元素的列表。<br>从结果上看， list()函数融化了元组<br>vehicle&#x3D;(‘train’,’bus’,’car’,’ship’,’subway’,’bicycle’)<br>list1 &#x3D; list(vehicle)<br>1<br>2<br>‘<br>运行运行</p>
<h2 id="4-2-字典"><a href="#4-2-字典" class="headerlink" title="4.2 字典"></a>4.2 字典</h2><p>字典是Python中唯一内建的映射类型<br>用一对花括号“{”和“}”作为边界，元素之间以逗号分隔：{123:“zhangsan”,456:“lisi”}</p>
<p>每个元素是一对键（key）和值（value），键和值之间用英文冒号分隔。<br>映射：可通过数据key查找关联数据value。<br>无序：字典的元素没有顺序，因此不能像序列那样通过位置索引来查找成员数据。但是每一个值都有一个对应的键。<br>不重复：字典的键是不重复的。<br>用法：通过键key来访问相应的值value（值value是可以重复的）。</p>
<h3 id="4-2-1-创建字典"><a href="#4-2-1-创建字典" class="headerlink" title="4.2.1 创建字典"></a>4.2.1 创建字典</h3><p>abbreviation &#x3D;{‘WAN’:’Wide Area Network’, ‘CU’:’Control Unit’, ‘LAN’:’Local Area Network’, ‘GUI’:’Graphical User Interface’} #1.{‘’:’’,’’:’’}创建<br>a&#x3D;dict(WAN&#x3D;’Wide Area Network’,CU&#x3D;’Control Unit’,LAN&#x3D;’Local Area Network’) #2.dict()创建,需注意：键外面不能加引号<br>keys&#x3D;[‘WAN’,’CU’,’LAN’]  #列表list<br>values&#x3D;(‘Wide Area Network’,’Control Unit’,’Local Area Network’) #元组<br>b&#x3D;dict(zip(keys,values))		#3.由序列构建zip对象，由zip对象创建字典<br>c&#x3D;dict.fromkeys([‘WAN’,’CU’,’LAN’])	#4.以给定序列(元组或者列表)为键，创建值为空的字典<br>d&#x3D;{} 		   #5-1.创建空字典<br>e&#x3D;dict()       #5-2.无参的dict函数<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>‘<br>运行运行<br>键key必须是不可修改类型的数据，如数值、字符串和元组等(列表是可变的，不能作为字典的键)<br>键对应的值value可以是任何类型的数据。<br>字典是无序集合，字典的显示次序由字典在内部的存储结构决定。</p>
<h3 id="4-2-2-字典操作"><a href="#4-2-2-字典操作" class="headerlink" title="4.2.2 字典操作"></a>4.2.2 字典操作</h3><h4 id="1-字典中“键-值”对的数量"><a href="#1-字典中“键-值”对的数量" class="headerlink" title="1.字典中“键-值”对的数量"></a>1.字典中“键-值”对的数量</h4><p>len()：返回字典中项（键-值对）的数量</p>
<p>abbreviation &#x3D;{‘WAN’:’Wide Area Network’, ‘CU’:’Control Unit’, ‘LAN’:’Local Area Network’, ‘GUI’:’Graphical User Interface’}<br>len(abbreviation)<br>1<br>2<br>‘<br>运行运行</p>
<h4 id="2-查找与特定键相关联的值：键—-gt-值"><a href="#2-查找与特定键相关联的值：键—-gt-值" class="headerlink" title="2.查找与特定键相关联的值：键—&gt;值"></a>2.查找与特定键相关联的值：键—&gt;值</h4><p>abbreviation &#x3D;{‘WAN’:’Wide Area Network’, ‘CU’:’Control Unit’, 1:’Local Area Network’, ‘GUI’:’Graphical User Interface’}<br>abbreviation[1]<br>1<br>2<br>‘<br>运行运行</p>
<h4 id="3-修改字典中的数据"><a href="#3-修改字典中的数据" class="headerlink" title="3.修改字典中的数据"></a>3.修改字典中的数据</h4><p>在字典中，某个键相关联的值可以通过赋值语句来修改.<br>如果指定的键不存在，则相当于向字典中添加新的键值对</p>
<p>abbreviation &#x3D;{‘WAN’:’Wide Area Network’, ‘CU’:’Control Unit’, ‘LAN’:’Local Area Network’, ‘GUI’:’Graphical User Interface’}<br>abbreviation[‘CU’]&#x3D;’control unit’   #有则修改<br>abbreviation[‘FTP’]&#x3D;’File Transfer Protocol’ #无则添加<br>1<br>2<br>3<br>‘<br>运行运行</p>
<h4 id="4-删除字典条目"><a href="#4-删除字典条目" class="headerlink" title="4.删除字典条目"></a>4.删除字典条目</h4><p>del 命令：用来删除字典条目或者整个字典</p>
<p>del abbreviation[‘CU’]      #键存在<br>del abbreviation             #删除整个<br>1<br>2<br>检查字典中是否含有某键的项<br>in命令：查找某键值是否在字典中。如果存在返回“True”，否则返回“False”</p>
<h3 id="4-2-3-字典方法"><a href="#4-2-3-字典方法" class="headerlink" title="4.2.3 字典方法"></a>4.2.3 字典方法</h3><h4 id="1-keys-、values"><a href="#1-keys-、values" class="headerlink" title="1.keys()、values()"></a>1.keys()、values()</h4><p>keys()方法将字典中的键以可迭代的dict_keys对象返回。values()方法将字典中的值以可迭代的dict_values对象形式返回</p>
<p>abbreviation &#x3D;{‘WAN’:’Wide Area Network’, ‘CU’:’Control Unit’, ‘LAN’:’Local Area Network’, ‘GUI’:’Graphical User Interface’}<br>abbreviation.keys()<br>#dict_keys([‘WAN’, ‘CU’, ‘LAN’, ‘GUI’])<br>list(abbreviation.values())   #转换成 列表<br>tuple(abbreviation.values())  #转换成 元组<br>1<br>2<br>3<br>4<br>5<br>‘<br>运行运行</p>
<h4 id="2-items"><a href="#2-items" class="headerlink" title="2.items()"></a>2.items()</h4><p>将字典中的所有键和值以可迭代的dict_items对象返回，每对键值对组成元组作为一个元素</p>
<p>abbreviation &#x3D;{‘WAN’:’Wide Area Network’, ‘CU’:’Control Unit’, ‘LAN’:’Local Area Network’, ‘GUI’:’Graphical User Interface’}<br>abbreviation.items()<br>#dict_items([(‘WAN’, ‘Wide Area Network’), (‘CU’, ‘Control Unit’), (‘LAN’, ‘Local Area Network’), (‘GUI’, ‘Graphical User Interface’)])<br>list(abbreviation.items())  #转换成 列表<br>tuple(abbreviation.items()) #转换成 元组<br>1<br>2<br>3<br>4<br>5<br>‘<br>运行运行</p>
<h4 id="3-setdefault"><a href="#3-setdefault" class="headerlink" title="3.setdefault()"></a>3.setdefault()</h4><p>使用dict.setdefault(key, default&#x3D;None)时，</p>
<p>如果字典中包含参数key对应的键，则返回该键对应的值；<br>否则以参数key的值为键，以参数default的值为该键对应的值，在字典中插入键-值对元素，并返回该元素的值部<br>abbreviation &#x3D;{‘WAN’:’Wide Area Network’, ‘CU’:’Control Unit’, ‘LAN’:’Local Area Network’, ‘GUI’:’Graphical User Interface’}<br>abbreviation.setdefault(‘CU’)             #1.存在这个键：返回对应的值value<br>abbreviation.setdefault(‘CU’,”控制单元”)   #2.存在这个键，默认值和原有的值不一样：返回对应的原值value<br>abbreviation[‘CU’]&#x3D;’control unit’   #有则修改<br>abbreviation.setdefault(‘FTP’,’File Transfer Protocol’)  #3.不存在这个键：插入新的键值对<br>abbreviation[‘FTP’]&#x3D;’File Transfer Protocol’ #和之前比较：无则添加<br>abbreviation.setdefault(‘cu’)              #4.不存在这个键，也未指定新值    ‘cu’: None<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>‘<br>运行运行</p>
<h4 id="4-update"><a href="#4-update" class="headerlink" title="4.update()"></a>4.update()</h4><p>将另一个字典中的所有键值对一次性地添加到当前字典中<br>如果两个字典中存在有相同的键，则以另一个字典中的值更新当前字典</p>
<h4 id="5-clear"><a href="#5-clear" class="headerlink" title="5.clear()"></a>5.clear()</h4><p>clear()方法将字典中的所有条目删除，变成空字典</p>
<h4 id="6-pop"><a href="#6-pop" class="headerlink" title="6.pop()"></a>6.pop()</h4><p>pop()方法能够弹出并删除字典中的键值对</p>
<p>abbreviation.pop(‘CU’)         #返回键为’CU’的值，并在字典中删除该键值对<br>1</p>
<h4 id="7-popitem"><a href="#7-popitem" class="headerlink" title="7.popitem()"></a>7.popitem()</h4><p>popitem()方法能够弹出字典的一个元素，如果字典为空则触发异常</p>
<h4 id="8-get"><a href="#8-get" class="headerlink" title="8.get()"></a>8.get()</h4><p>返回指定键所对应的值，如果键不存在则返回默认值。默认值为None，也可以自己指定。</p>
<h3 id="4-2-4遍历字典"><a href="#4-2-4遍历字典" class="headerlink" title="4.2.4遍历字典"></a>4.2.4遍历字典</h3><h4 id="1-遍历字典的key"><a href="#1-遍历字典的key" class="headerlink" title="1.遍历字典的key"></a>1.遍历字典的key</h4><p>for i in abbreviation:        #默认遍历字典的键<br>    print(i)<br>    print(i,abbreviation[i])<br>for i in abbreviation.keys(): #和上面相同<br>    print(i,abbreviation[i])<br>1<br>2<br>3<br>4<br>5</p>
<h4 id="2-遍历字典的值Value"><a href="#2-遍历字典的值Value" class="headerlink" title="2.遍历字典的值Value"></a>2.遍历字典的值Value</h4><p>for i in abbreviation.values():<br>    print(i)<br>1<br>2</p>
<h4 id="3-遍历字典的键值对"><a href="#3-遍历字典的键值对" class="headerlink" title="3.遍历字典的键值对"></a>3.遍历字典的键值对</h4><p>for i in abbreviation.items():  #keys() values() items()<br>    print(i)<br>1<br>2</p>
<h3 id="4-2-5列表、元组、字典的转换"><a href="#4-2-5列表、元组、字典的转换" class="headerlink" title="4.2.5列表、元组、字典的转换"></a>4.2.5列表、元组、字典的转换</h3><h4 id="1-列表与字典之间的转化：字典–-gt-列表"><a href="#1-列表与字典之间的转化：字典–-gt-列表" class="headerlink" title="1.列表与字典之间的转化：字典–&gt;列表"></a>1.列表与字典之间的转化：字典–&gt;列表</h4><p>Python中的list()函数可以将字典转换列表，但列表不能转换为字典</p>
<p>list(abbreviation)         #默认将键转化为列表<br>list(abbreviation.keys())   #键<br>list(abbreviation.values()) #值<br>list(abbreviation.items())  #键值对<br>1<br>2<br>3<br>4</p>
<h4 id="2-元组与字典之间的转化：字典–-gt-元组"><a href="#2-元组与字典之间的转化：字典–-gt-元组" class="headerlink" title="2.元组与字典之间的转化：字典–&gt;元组"></a>2.元组与字典之间的转化：字典–&gt;元组</h4><p>Python中的tuple()函数可以将字典转换元组，但元组不能转换为字典</p>
<p>tuple(abbreviation)          #默认将键转化为元组<br>tuple(abbreviation.keys())   #键<br>tuple(abbreviation.values()) #值<br>tuple(abbreviation.items())  #键值对<br>1<br>2<br>3<br>4</p>
<h2 id="4-3-集合-Set"><a href="#4-3-集合-Set" class="headerlink" title="4.3 集合 Set"></a>4.3 集合 Set</h2><p>集合是一组用{ }括起来的无序,不重复元素，元素之间用逗号分隔。<br>元素可以是各种类型的不可变对象。</p>
<p>集合，想象成 只有key 没有value值的字典dict</p>
<h3 id="4-3-1-集合的创建"><a href="#4-3-1-集合的创建" class="headerlink" title="4.3.1 集合的创建"></a>4.3.1 集合的创建</h3><p>集合类型的值有两种创建方式：</p>
<p>用一对花括号将多个元素括起来，元素之间用逗号分隔：{1,3,‘a’}<br>函数set()：将字符串、列表、元组等类型的数据转换为集合类型。<br>vehicle&#x3D;{‘train’,’bus’,’car’,’ship’}       # 1、直接赋值<br>vehicle&#x3D;set([‘train’,’bus’,’car’,’ship’])  # 2、Set()函数，list（） tuple（）  dict()<br>#注意：空集合只能用set()来创建，而不能用空的花括号{}表示，因为Python已将空{}用于表示空字典<br>a&#x3D;set()     # 无参的set函数，空集合<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>集合中没有相同的元素，因此创建集合时会自动删除掉重复的元素（利用这一点，可以快速去重）。</p>
<h3 id="4-3-2-集合的运算"><a href="#4-3-2-集合的运算" class="headerlink" title="4.3.2 集合的运算"></a>4.3.2 集合的运算</h3><h4 id="1-len-、max-、min-、sum"><a href="#1-len-、max-、min-、sum" class="headerlink" title="1.len() 、max()、min()、sum()"></a>1.len() 、max()、min()、sum()</h4><p>返回集合中元素的个数</p>
<p>nums &#x3D; {4,3,8,9,0,-5,7}<br>max(nums)<br>sum(nums)<br>sorted(nums)    # 生成排序后的列表：集合本身无序<br>reversed(nums)  # 不能反序：集合本身无序<br>1<br>2<br>3<br>4<br>5</p>
<h4 id="2-in"><a href="#2-in" class="headerlink" title="2.in"></a>2.in</h4><p>判断某元素是否存在于集合之中，判断结果用布尔值True或False表示</p>
<h4 id="3-并集、交集"><a href="#3-并集、交集" class="headerlink" title="3.并集、交集"></a>3.并集、交集</h4><p>并集：创建一个新的集合，该集合包含两个集合中的所有元素。<br>交集：创建一个新的集合，该集合为两个集合中的公共部分</p>
<p>vehicle1&#x3D;{‘train’,’bus’,’car’,’ship’}<br>vehicle2&#x3D;{‘subway’,’bicycle’,’bus’}<br>vehicle1|vehicle2   #并集<br>vehicle1&amp;vehicle2   #交集<br>1<br>2<br>3<br>4<br>‘<br>运行运行</p>
<h4 id="4-差集"><a href="#4-差集" class="headerlink" title="4.差集"></a>4.差集</h4><p>A-B表示集合A与B的差集，返回由出现在集合A中但不出现在集合B中的元素所构成的集合。</p>
<p>vehicle1-vehicle2<br>1</p>
<h4 id="5-对称差"><a href="#5-对称差" class="headerlink" title="5.对称差"></a>5.对称差</h4><p>返回由两个集合中那些不重叠的元素所构成的集合</p>
<p>vehicle1^vehicle2<br>1</p>
<h4 id="6-子集和超集"><a href="#6-子集和超集" class="headerlink" title="6.子集和超集"></a>6.子集和超集</h4><p>子集：如果集合A的每个元素都是集合B中的元素，则集合A是集合B的子集。<br>超集：超集是仅当集合A是集合B的一个子集，集合B才是集合A的一个超集。<br>A&lt;&#x3D;B，检测A是否是B的子集；<br>A&lt;B，检测A是否是B的真子集；<br>A&gt;&#x3D;B，检测A是否是B的超集；<br>A&gt;B，检测A是否是B的真超集；<br>以上结果只返回True或False<br>A |&#x3D; B将B的元素并入A中。</p>
<h3 id="4-3-3-集合的方法"><a href="#4-3-3-集合的方法" class="headerlink" title="4.3.3 集合的方法"></a>4.3.3 集合的方法</h3><p>同样以面向对象方式实现集合类型的运算</p>
<h4 id="1-union-、intersection"><a href="#1-union-、intersection" class="headerlink" title="1.union()、intersection()"></a>1.union()、intersection()</h4><p>union()方法相当于并集运算。<br>intersection()方法相当于交集运算<br>vehicle1&#x3D;{‘train’,’bus’,’car’,’ship’}<br>vehicle2&#x3D;{‘subway’,’bicycle’,’bus’}<br>vehicle1.union(vehicle2)  #并集，新的集合<br>vehicle1                  # vehicle1未发生改变<br>vehicle2                  # vehicle2未发生改变<br>vehicle1.intersection(vehicle2) #交集，产生新集合<br>1<br>2<br>3<br>4<br>5<br>6<br>‘<br>运行运行</p>
<h4 id="2-update"><a href="#2-update" class="headerlink" title="2.update()"></a>2.update()</h4><p>update()方法相当于集合元素合并运算，注意与union()方法的区别</p>
<p>vehicle1.update(vehicle2)<br>vehicle1                  # vehicle1发生了改变<br>1<br>2</p>
<h4 id="3-difference"><a href="#3-difference" class="headerlink" title="3.difference()"></a>3.difference()</h4><p>相当于差集运算</p>
<p>vehicle1.difference(vehicle2)  #新集合<br>vehicle1   #原集合没有变化<br>1<br>2</p>
<h4 id="4-symmetric-difference"><a href="#4-symmetric-difference" class="headerlink" title="4.symmetric_difference()"></a>4.symmetric_difference()</h4><p>相当于对称差运算</p>
<p>vehicle1.symmetric_difference(vehicle2)  #结果相同<br>vehicle2.symmetric_difference(vehicle1)<br>1<br>2</p>
<h4 id="5-issubset-和issuperset"><a href="#5-issubset-和issuperset" class="headerlink" title="5.issubset()和issuperset()"></a>5.issubset()和issuperset()</h4><p>issubset()方法：判断是否子集。&lt;&#x3D;<br>issuperset()方法：判断是否超集&gt;&#x3D;<br>vehicle2.issubset(vehicle1)<br>vehicle1.issuperset(vehicle2)<br>1<br>2</p>
<h4 id="6-add"><a href="#6-add" class="headerlink" title="6.add()"></a>6.add()</h4><p>是向集合中添加元素</p>
<p>vehicle1.add(‘ship’)  #重复元素，只保留一个<br>1</p>
<h4 id="7-remove"><a href="#7-remove" class="headerlink" title="7.remove()"></a>7.remove()</h4><p>是从集合中删除元素，如果集合中没有该元素，则出错</p>
<h4 id="8-discard"><a href="#8-discard" class="headerlink" title="8.discard()"></a>8.discard()</h4><p>作用是从集合中删除元素，如果集合中没有该元素，也不提示出错</p>
<h4 id="9-pop"><a href="#9-pop" class="headerlink" title="9.pop()"></a>9.pop()</h4><p>pop()方法的作用是从集合中删除任一元素，并返回该元素；<br>如果集合为空，则抛出KeyError异常。</p>
<h4 id="10-clear"><a href="#10-clear" class="headerlink" title="10.clear()"></a>10.clear()</h4><p>从集合中删除所有元素，变成一个空集合</p>
<h2 id="4-4-可迭代对象Iterable-与-迭代器Iterator"><a href="#4-4-可迭代对象Iterable-与-迭代器Iterator" class="headerlink" title="4.4 可迭代对象Iterable 与 迭代器Iterator"></a>4.4 可迭代对象Iterable 与 迭代器Iterator</h2><p>简单解释：</p>
<p>可迭代对象 是 存放元素的容器，可以被遍历其中的元素。（类比：链表）</p>
<p>迭代器 由可迭代对象（容器）提供的(因为只有该容器知道怎么遍历它的每一个元素)，用于遍历容器元素的一个工具。（类比：链表的遍历指针p）</p>
<h3 id="4-4-1-可迭代-Iterable-对象"><a href="#4-4-1-可迭代-Iterable-对象" class="headerlink" title="4.4.1 可迭代(Iterable)对象"></a>4.4.1 可迭代(Iterable)对象</h3><p>列表、元组、字符串、字典可以用 for…in…进行遍历。</p>
<p>表面：只要可以用 for…in…进行遍历的对象就是可迭代对象，那么列表、元组、字符串、字典都是可迭代对象。</p>
<p>本质：如果一个对象实现了__iter__()方法，那么这个对象就是可迭代(Iterable)对象</p>
<p>help(list)  #方法1：查看list对象的方法，是否有__iter__方法（类似于java中查看某一个类可实现的方法）<br>1<br>‘<br>运行运行<br>方法2：可以通过调用内置函数isinstance()来判断一个对象是否属于可迭代(Iterable)对象</p>
<p>from collections.abc import Iterable<br>isinstance([‘abc’,1,8.5],Iterable)     #1.列表list是可迭代对象吗？<br>isinstance(123,Iterable)               #7.数值int float 是可迭代对象吗？不是<br>1<br>2<br>3<br>‘<br>运行运行<br>迭代器（Iterator）：实现了__iter__方法和__next__方法，并且可以通过__next__方法不断返回下一个值的对象</p>
<p>迭代器(Iterator)还可以通过内置函数next()访问下一个元素。</p>
<p>可以通过调用Python内置函数isinstance()来判断一个对象是否属于迭代器(Iterator)</p>
<p>from collections.abc import Iterator<br>isinstance([],Iterator)                #列表list 是迭代器吗？<br>isinstance([],Iterator)                #列表list 是迭代器吗？<br>isinstance({1:’one’,2:’two’},Iterator) #字典dict 是迭代器吗？<br>isinstance({‘one’,’two’},Iterator)     #集合set 是迭代器吗？<br>isinstance(‘abcdefg’,Iterator)         #字符串str 是迭代器吗？<br>isinstance(range(10),Iterator)         #range函数生成的数列 是迭代器吗？<br>isinstance(123,Iterator)               #数值 是迭代器吗？<br>#以上对象均不能成为迭代器（注意迭代器和可迭代对象不同）<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>‘<br>运行运行<br>可迭代对象（容器）—&gt; 迭代器(迭代工具)</p>
<p>虽然列表、元组、字符串、字典、集合都是可迭代(Iterable)对象而不是迭代器(Iterator)，但可以通过iter()函数获得一个迭代器(Iterator)<br>from collections.abc import Iterator<br>vehicle&#x3D;[‘train’,’bus’,’car’,’ship’]  #列表 list<br>v&#x3D;iter(vehicle)  #取list的迭代器<br>v.<strong>next</strong>()   #1、自带方法__next__()：返回下一个值<br>next(v)        #2、也可以用内置函数next()函数<br>v.<strong>next</strong>()       #没有下一个元素了，触发StopIteration异常<br>next(v)            #内置函数：next()访问下一个值(同样异常)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>‘<br>运行运行</p>
<h3 id="4-4-2-相关内置函数"><a href="#4-4-2-相关内置函数" class="headerlink" title="4.4.2 相关内置函数"></a>4.4.2 相关内置函数</h3><p>enumerate（）枚举<br>zip() 组合<br>map() 映射（逐个计算）<br>filter（）过滤（挑选）<br>共同点：这四个函数都会返回一个 特定对象，它们都既是迭代器、也是可迭代对象。</p>
<p>1.enumerate() 枚举<br>格式：enumerate(iterable, start&#x3D;0)<br>功能：返回下标和值的enumerate对象。<br>参数：第1个参数表示可迭代(Iterable)对象，第2个参数表示下标的开始值，默认从0开始。<br>通俗：将容器的每个元素取出来，搭配一个下标</p>
<p>enumerate对象：既是Iterable对象（容器），也是Iterator对象（容器的遍历工具）</p>
<p>vehicle&#x3D;[‘train’,’bus’,’car’,’ship’]  #列表list（用其他容器也可以）<br>vv1&#x3D;enumerate(vehicle)     #取得list的枚举器<br>for i in vv1:              #迭代器 可以使用for in语句<br>    print(i,” “)<br>#(0, ‘train’)<br>#(1, ‘bus’)<br>#(2, ‘car’)<br>#(3, ‘ship’)<br>next(vv1)                   #也可以使用next()函数<br>vv1.<strong>next</strong>()              #也可以使用 <strong>next</strong>()方法<br>list(vv1)                   # 将剩余的enumerate对象vv1元素转换为列表<br>tuple(vv2)      #enumerate对象vv2转换为元组<br>vv2&#x3D;enumerate(vehicle,1)    #下标从1开始<br>vv2.<strong>next</strong>()              #返回下一个值<br>for i in enumerate(vehicle):  #遍历enumerate对象中的元素<br>    print(i,end&#x3D;’ ‘)    #(0, ‘train’) (1, ‘bus’) (2, ‘car’) (3, ‘ship’)<br>for i,x in enumerate(vehicle):<br>    print(i,x,end&#x3D;’ ‘)        #遍历enumerate对象元素的下标和值       0 train 1 bus 2 car 3 ship<br>vv1&#x3D;enumerate(vehicle)<br>dict(vv1)                     #enumerate对象vv1转换为字典:枚举号转为key，枚举值转为value<br>#{0: ‘train’, 1: ‘bus’, 2: ‘car’, 3: ‘ship’}<br>vv1&#x3D;enumerate(vehicle)<br>set(vv1)                      #enumerate对象vv1转换为集合</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>2.zip()<br>格式：zip(iter1 [,iter2 […]])<br>功能：将多个迭代器(Iterator)对象（或者可迭代(Iterable)对象）中的元素压缩到一起，返回一个zip对象。<br>通俗：将多个容器的逐个对应元素拼合在一起</p>
<p>同样，zip对象既是一个可迭代(Iterable)对象，也是一个迭代器(Iterator)对象。</p>
<p>vv1&#x3D;zip(‘abcd’)  #1、只有一个参数：字符串（容器），每个元素是元组<br>list(vv1)   #[(‘b’,), (‘c’,), (‘d’,)]<br>vv3 &#x3D; zip(‘abcd’,vehicle)   #2、有两个参数：有两个容器作为参数<br>list(vv3)  #[(‘c’, ‘car’), (‘d’, ‘ship’)]<br>(‘b’, ‘bus’) in zip(‘abcd’,vehicle)    #zip对象是可迭代对象（容器），可以使用in运算<br>vv2&#x3D;zip(‘abcd’,enumerate(vehicle))  #第二个参数是 枚举（也是容器）<br>next(vv2)   #(‘a’, (0, ‘train’))<br>vv3&#x3D;zip(range(2),vehicle)             #不同长短时：匹配短的<br>list(vv3)<br>vv4&#x3D;zip(‘abcd’,range(4),vehicle)     #3、更多参数：更多容器<br>next(vv4)  #(‘a’, 0, ‘train’)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>3.map()<br>格式：map(func, *iterables)<br>功能：把一个函数func依次映射到可迭代(Iterable)对象的每个元素上，返回一个map对象。<br>通俗：将每个元素 传入 func函数，把结果放入map里</p>
<p>map对象：既是一个可迭代(Iterable)对象，也是一个迭代器(Iterator)对象</p>
<p>aa&#x3D;[‘1’,’5.6’,’7.8’,’9’]<br>bb1&#x3D;map(float,aa)      #将每个元素变为float类型<br>next(bb1)  #1.0<br>list(map(str,range(5)))  #将0-4改为字符串<br>#[‘0’, ‘1’, ‘2’, ‘3’, ‘4’]<br>def fun(x):                  # 2、定义一个 函数<br>    return x**2<br>list(map(fun,[1,2,3,4]))        #list中的每个元素，都执行一次fun函数，结果放入map<br>#[1, 4, 9, 16]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>‘<br>运行运行<br>4.filter()<br>格式：filter(函数名 or None, 可迭代对象)<br>功能：把一个带有一个参数的函数function作用到一个可迭代(Iterable)对象上，返回一个filter对象。<br>filter对象中的元素由可迭代(Iterable)对象中使得函数function返回值为True的那些元素组成。<br>如果指定函数为None，则返回可迭代(Iterable)对象中等价于True的元素。<br>通俗：将容器中的元素用函数过滤（挑选）一下</p>
<p>filter对象：既是一个可迭代(Iterable)对象，也是一个迭代器(Iterator)对象。</p>
<p>只保留满足条件的元素</p>
<p>aa&#x3D;[5,6,-9,-56,-309,206]  #用法1：函数<br>def func(x):        #定义函数func，x为奇数返回True，否则返回False<br>    return x%2!&#x3D;0</p>
<p>bb&#x3D;filter(func,aa)  #将aa中的每个元素，作为参数，带入func(x)。将返回值为True的元素保留下来。<br>type(bb)            #bb是一个filter对象<br>next(bb)            #5<br>cc&#x3D;filter(lambda x:x%2!&#x3D;0,aa)  #用法2：lambda函数（匿名函数，不用单独定义函数了）<br>dd&#x3D;[6,True,1,0,False]<br>ee&#x3D;filter(None,dd)             #用法4：指定函数为None（函数就不起作用了。就看元素本身，是否为True）<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>‘<br>运行运行</p>
<h2 id="4-5-推导式"><a href="#4-5-推导式" class="headerlink" title="4.5 推导式"></a>4.5 推导式</h2><p>利用列表推导式、字典推导式、集合推导式可以从一个数据对象构建另一个新的数据对象。<br>利用生成器推导式可以构建生成器对象。<br>语法糖</p>
<h3 id="4-5-1-列表推导式"><a href="#4-5-1-列表推导式" class="headerlink" title="4.5.1 列表推导式"></a>4.5.1 列表推导式</h3><p>列表推导式（list comprehension）是Python开发时用得最多的技术之一，表示对可迭代(Iterable)对象的元素进行遍历、过滤或再次计算，生成满足条件的新列表。<br>它的结构是在一个方括号里包含一个函数或表达式（再次计算），接着是一个for语句（遍历），然后是0个或多个for（遍历）或者if语句（过滤），在逻辑上等价于循环语句，但是形式上更简洁。<br>语法形式：<br>[函数 &#x2F; 表达式<br>for 值1 in 可迭代对象1 if 条件1<br>for 值2 in 可迭代对象2 if 条件2<br>……<br>for 值n in 可迭代对象n if 条件n ]</p>
<p>1.列表推导式和循环语句for<br>如果要将一个列表中的元素均扩大2倍组成新列表：</p>
<p>n&#x3D;[10,-33,21,5,-7,-9,3,28,-16,37]   #列表推导式：<br>number&#x3D;[i*2 for i in n]<br>number<br>1<br>2<br>3<br>‘<br>运行运行<br>两点：</p>
<p>利用列表推导式更加简洁。<br>由于Python内部对列表推导式做了大量优化，还能保证较快的运行速度<br>for循环可以嵌套。列表推导式中也可以有多个for语句。<br>如果要将一个一层嵌套数字列表中的元素展开后扩大2倍组成新列表：</p>
<p>n&#x3D;[[10,-33,21],[5,-7,-9,3,28,-16,37]]   #一层嵌套列表<br>number&#x3D;[]                               #常规写法：<br>for i in n:  #每一行<br>    for j in i:   #行中的每一列<br>        number.append(j<em>2)<br>number<br>n&#x3D;[[10,-33,21],[5,-7,-9,3,28,-16,37]]   #列表推导式：<br>number&#x3D;[j</em>2 for i in n for j in i]<br>number<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>‘<br>运行运行<br>2.列表推导式和条件语句if<br>在列表推导式中，条件语句if对可迭代(Iterable)对象中的元素进行筛选，起到过滤的作用。</p>
<p>#接着上面的例子，如果是将一个数字列表中的是正数的元素扩大2倍组成新列表：<br>n&#x3D;[10,-33,21,5,-7,-9,3,28,-16,37]<br>number&#x3D;[i*2 for i in n if i&gt;0]<br>number<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>另外，在列表推导式中还可以使用if else语句。</p>
<p>#将一个数字列表中的正偶数扩大2倍、正奇数扩大3倍组成新列表<br>n&#x3D;[10,-33,21,5,-7,-9,3,28,-16,37]<br>number&#x3D;[i<em>2 if i%2&#x3D;&#x3D;0 else i</em>3 for i in n if i&gt;0]<br>number<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>3.列表推导式和函数function<br>在列表推导式中可以使用函数function。</p>
<p>#利用列表推导式快速生成包含15个30~80（包含30、80）之间的随机整数列表rlist。<br>import random<br>rlist&#x3D;[random.randint(30,80) for i in range(15)] #使用randint()函数<br>rlist</p>
<p>对rlist中的元素，如果被3整除则该数除以3，如果被7整除则该数扩大2倍，其他的数扩大5倍，这些数组成新列表number</p>
<p>def ff(x):<br>    if x%3&#x3D;&#x3D;0:<br>        x&#x2F;&#x3D;3<br>    elif x%7&#x3D;&#x3D;0:<br>        x*&#x3D;2<br>    else:<br>        x*&#x3D;5<br>    return x<br>number&#x3D;[ff(i) for i in rlist] #使用自定义的ff()函数<br>number<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>‘<br>运行运行<br>4.同时遍历多个列表或可迭代对象<br>#有两个成绩列表score1和score2，将score1中分数90及以上和score2中分数85及以下的元素两两分别组成元组，将这些元组组成列表nn中的元素<br>score1&#x3D;[86,78,98,90,47,80,90]<br>score2&#x3D;[87,78,89,92,90,47,85]<br>nn&#x3D;[(i,j) for i in score1 if i&gt;&#x3D;90 for j in score2 if j&lt;&#x3D;85]<br>nn<br>1<br>2<br>3<br>4<br>5<br>‘<br>运行运行</p>
<h3 id="4-5-2-字典推导式"><a href="#4-5-2-字典推导式" class="headerlink" title="4.5.2 字典推导式"></a>4.5.2 字典推导式</h3><p>字典推导式和列表推导式的使用方法类似</p>
<p>将方括号变成花括号<br>需要两个表达式，一个生成键，一个生成值，两个表达式之间使用冒号分隔<br>最后生成的是字典<br>语法形式：<br>{函数 &#x2F; 表达式<br>for 值1 in 可迭代对象1 if 条件1<br>for 值2 in 可迭代对象2 if 条件2<br>……<br>for 值n in 可迭代对象n if 条件n }</p>
<p>列表name存储若干人的名字（唯一），列表score在对应的位置上存储这些人的成绩，利用字典推导式，以名字为键、成绩为值组成新字典dd。</p>
<p>name&#x3D; [‘Bob’,’Tom’,’Alice’,’Jerry’,’Wendy’,’Smith’]<br>score&#x3D;[86,78,98,90,47,80]<br>dd&#x3D;{i:j for i,j in zip(name,score)}</p>
<p>以名字为键、成绩为值组成新字典exdd，新字典中的键值对只包含成绩80及以上的</p>
<p>exdd&#x3D;{i:j for i,j in zip(name,score) if j&gt;&#x3D;80}       #增加一个if</p>
<p>以名字为键、名字的长度为值组成新字典nd</p>
<p>nd&#x3D;{i:len(i) for i in name}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>‘<br>运行运行</p>
<h3 id="4-5-3-集合推导式"><a href="#4-5-3-集合推导式" class="headerlink" title="4.5.3 集合推导式"></a>4.5.3 集合推导式</h3><p>集合也有自己的推导式，跟列表推导式类似</p>
<p>只不过将方括号变成花括号<br>最后生成的是集合<br>语法形式：<br>{函数 &#x2F; 表达式<br>for 值1 in 可迭代对象1 if 条件1<br>for 值2 in 可迭代对象2 if 条件2<br>……<br>for 值n in 可迭代对象n if 条件n }<br>alist&#x3D;[i<em>2 for i in (1,2,3,3,2,1,4)]<br>bset&#x3D;{i</em>2 for i in (1,2,3,3,2,1,4)}<br>1<br>2<br>‘<br>运行运行<br>不难发现，构建alist和bset的时候，除了方括号和花括号不同以外其他语法均相同，alist生成一个列表，里面的元素是元组(1,2,3,3,2,1,4)中每个元素的2倍，而且元素位置一一对应；blist生成一个集合，里面的元素是元组(1,2,3,3,2,1,4)中每个元素的2倍去掉重复元素后的结果，并且并非与元组的元素位置一一对应。</p>
<p>需要说明的是：元组没有推导式</p>
<h3 id="4-5-4-生成器推导式"><a href="#4-5-4-生成器推导式" class="headerlink" title="4.5.4 生成器推导式"></a>4.5.4 生成器推导式</h3><p>生成器推导式用法与列表推导式类似，把列表推导式的方括号改成圆括号。它与列表推导式最大的区别是：生成器推导式的结果是一个生成器对象，是一种迭代器(Iterator)；而列表推导式的结果是一个列表。<br>生成器对象可以通过for循环或者next()方法、next()函数进行遍历，也可以转换为列表或元组，但是不支持使用下标访问元素，已经访问过的元素也不支持再次访问。当所有元素访问结束之后，如果想再次访问就必须重新创建该生成器对象。</p>
<p>gen&#x3D;(int(i&#x2F;3) for i in range(1,10) if i%3&#x3D;&#x3D;0)<br>gen  #&lt;generator object <genexpr> at 0x00000110CC45C970&gt;<br>list(gen) #生成器对象转换为列表<br>gen.<strong>next</strong>() #不能再次访问<br>next(gen)       #访问下一个元素<br>gen&#x3D;(int(i&#x2F;3) for i in range(1,10) if i%3&#x3D;&#x3D;0)<br>for i in gen:       #for循环遍历<br>    print(i,end&#x3D;’ ‘)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p>
<h1 id="五、字符串"><a href="#五、字符串" class="headerlink" title="五、字符串"></a>五、字符串</h1><h2 id="5-1-字符串的编码"><a href="#5-1-字符串的编码" class="headerlink" title="5.1 字符串的编码"></a>5.1 字符串的编码</h2><p>ASCII码</p>
<p>标准ASCII码为7位编码，包括英文字母、数字、标点符号等128个字符。用1个字节存储，最高位为0.<br>扩展ASCII码：1个字节存储，最高位为1。</p>
<p>Unicode编码</p>
<p>.把所有语言统一到一套编码里<br>.采用2个字节或4个字节（生僻字符）的编码<br>.缺点：全部是英文的话，比ASCII码多用一倍存储空间</p>
<p>UTF-8编码</p>
<p>可变长编码，英文字符用1个字节（兼容ASCII码），中文字符用3个字节，其他语言也有用2或4个字节</p>
<p>GB2312、GBK等中文编码</p>
<p>一般用2个字节</p>
<p>Python3支持两种类型字符串：str类型（支持Unicode编码）和bytes类型，而且str类型和bytes类型可以相互转换。</p>
<p>str.encode()可以转换为bytes类型<br>bytes.decode()转换为str类型<br>除此之外，其他方法都一样<br>s&#x3D;’我’ #str类型<br>#编码（str–&gt;bytes）<br>s1&#x3D;s.encode(‘gbk’)   	#编码成bytes类型，gbk编码格式<br>s1                      #b’\xce\xd2’，16进制，2个字节（1位16进制数，用4位2进制数表示）<br>s2&#x3D;s.encode(‘utf-8’) 	#编码成bytes类型，utf-8编码格式<br>s2                      #b’\xe6\x88\x91’，16进制，3个字节<br>#解码（bytes–&gt;str）<br>s3&#x3D;s1.decode(‘gbk’)	    #s1目前是gbk编码的bytes字符串，使用gbk进行解码<br>s4&#x3D;s2.decode(‘utf-8’) 	#s2目前是utf-8编码的bytes字符串，使用utf-8进行解码<br>s5&#x3D;s.encode(‘ascii’)   	#s(‘我’)是str类型字符串，中文字符串不能以ascii编码<br>‘ABC’.encode(‘ascii’) 	#英文字符串可以以ascii编码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>也可以使用bytes(string, encoding) 和str(bytes_or_buffer[, encoding])完成两种类型的相互转换</p>
<p>s&#x3D;’阳光’<br>b&#x3D;bytes(s,encoding&#x3D;’gbk’)    #str–&gt;bytes，用gbk编码转换<br>u&#x3D;bytes(s,encoding&#x3D;’utf-8’)   #用utf-8编码转换,3个字节<br>bs&#x3D;str(b,encoding&#x3D;’gbk’)      #bytes–&gt;str，用gbk编码转换<br>us&#x3D;str(u,encoding&#x3D;’utf-8’)#str类型<br>ub &#x3D; str(u,encoding&#x3D;’gbk’)  #u是用utf-8转换来的,’阳光’,3个字节<br>ub     #结果有误<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>‘<br>运行运行<br>Python3.x完全支持中文字符，解析器默认采用UTF-8解析源程序，<br>无论是数字字符、英文字母、汉字都按 一个 字符来对待和处理</p>
<h2 id="5-2-字符串的构建"><a href="#5-2-字符串的构建" class="headerlink" title="5.2 字符串的构建"></a>5.2 字符串的构建</h2><p>在Python中字符串的构建，主要通过两种方法来实现，一是使用str函数，二是用单引号、双引号或三引号</p>
<p>1.单引号或双引号构造字符串 ：要求引号成对出现<br>合法：如：‘Python World!’、‘ABC’、“what is your name？”<br>不合法：’string”<br>2.字符串本身有 单引号或双引号时：<br>字符串包含了 单引号，且不用转义字符：整个字符串就要用 双引号 来构造。<br>字符串包含了 双引号，且不用转义字符：整个字符串要用 单引号 来构造。</p>
<p>print(“Let’s go!”)               #字符串本身有单引号<br>‘“Hello world!”,he said.’        #字符串本身有双引号<br>print(‘“Hello world!”,he said.’) #print函数输出时，是没有外层的引号的<br>1<br>2<br>3<br>‘<br>运行运行<br>3.对引号转义<br>‘Let&#39;s go!’<br>print(‘Let&#39;s go!’)<br>“&quot;Hello world!&quot;he said”<br>print(“&quot;Hello world!&quot;he said”)<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>4.对其他字符转义<br>转义字符以“\”开头，后接某些特定的字符或数字</p>
<p>转义字符	含义	转义字符	含义	转义字符	含义<br>\（行尾）	续行符	\n	换行符	\f	换页符<br>\	一个反斜杠	\r	回车	\ooo	3位8进制数ooo对应的字符，如\123<br>’	单引号’	\t	横向（水平）制表符	\xhh	2位16进制数hh对应的字符，如\x6a<br>“	双引号”	\v	纵向（垂直）制表符	\uhhhh	4位16进制数hhhh表示的Unicode字符<br>print(“你好\n再见！”) 		#\n表示换行，相当于敲了一个回车键<br>print(‘\123\x6a’) #8进制数123对应的字符是“S”，16进制数6a对应的字符“j   sj<br>1<br>2<br>‘<br>运行运行<br>5.原始字符串<br>假设在C:\test文件夹中有一个文件夹net，如何输出完整路径呢？可能你想到的是</p>
<p>print(“c:\test\net”)      #错误<br>1<br>‘<br>运行运行<br>第1种方法：使用“\”表示反斜杠，则t和n不再形成\t和\n</p>
<p>print(“c:\test\net”)<br>1<br>‘<br>运行运行<br>第2种方法：在原始字符串前加 r 前缀<br>在字符串前面加上字母 r 或 R 表示原始字符串，所有的字符都是原始的本义而不会进行任何转义。</p>
<p>print(r”c:\test\net”)<br>1<br>‘<br>运行运行<br>6.三重引号字符串<br>三重引号将保留所有字符串的格式信息。</p>
<p>如字符串跨越多行，行与行之间的回车符、引号、制表符或者其他任何信息，都将保存下来。<br>在三重引号中可以自由的使用单引号和双引号。<br> ‘’’”What’s your name?”<br>  “My name is Jone”‘’’<br> #’”What&#39;s your name?”\n “My name is Jone”‘<br>print(‘’’”What’s your name?”</p>
<pre><code>   &quot;My name is Jone&quot;&#39;&#39;&#39;)
</code></pre>
<p>“What’s your name?”</p>
<pre><code>   &quot;My name is Jone&quot;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<h2 id="5-3-字符串格式化"><a href="#5-3-字符串格式化" class="headerlink" title="5.3 字符串格式化"></a>5.3 字符串格式化</h2><p>5.3.1 用 % 符号格式化字符串<br>格式以%开头<br>格式化运算符用%表示用对象代替格式串中的格式，最终得到1个字符串<br>基本同C语言</p>
<p>1.字符串格式的书写<br>[ ]中的内容可以省略；<br>简单的格式是：% 加格式字符，如%f、%d、%c等；<br>当最小宽度及精度都出现时，它们之间不能有空格，格式字符和其他选项之间也不能有空格，如%8.2f。<br>2.常用格式字符的含义（基本同C语言）</p>
<p>3.最小宽度和精度<br>最小宽度：转换后的值所保留的最小字符个数。<br>精度（对于数字来说）：结果中应该包含的小数位数。</p>
<p>#浮点数<br>a&#x3D;3.1416<br>‘a&#x3D;%6.2f’%a         #总宽度为6，保留2位小数，四舍五入  ‘a&#x3D;  3.14’<br>‘%f’%3.1416 		#单独的%f，默认保留6位小数  ‘3.141600’<br>‘%.2f’%3.1416 		#保留2位小数，第2位四舍五入，3.14<br>‘%.2f’%3.1476       #四舍五入为3.15<br>‘%7.2f’%3.1416 		 #宽度7位，保留2位小数，空位填空格  ‘   3.14’<br>‘%07.2f’%3.1416 	 #宽度7位，保留2位小数，空位填0  ‘0003.14’<br>‘%7.2f’%1234567.8901 #实际宽度，允许超出最小宽度  ‘1234567.89’<br>‘%+07.2f’%3.1416     #宽度7位，保留2位小数，正数加正号，空位填0   ‘+003.14’<br>‘%-7.2f’%-3.1416     #宽度7位，保留2位小数，空位填空格，左对齐输出  ‘-3.14  ‘<br>“%-2d”%156           #左对齐<br>“%-2d”%5             #左对齐，右补空格<br>‘%d’%’5’   	        #字符串’5’用格式化整数%d输出，引发异常（类型必须一致）<br>‘%s’%5  		    #与str()等价<br>#多对象：%后用元组<br>‘%.2f,%4d,%s’%(3.456727,89,’Lily’)   #常量–&gt;元组<br>‘3.46,  89,Lily’<br>name&#x3D;’Lily’<br>age&#x3D;18<br>‘我叫%s，今年%d岁’%(name,age)        #变量–&gt;元组    ‘我叫Lily，今年18岁’</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>4.进位制和科学计数法<br>a&#x3D;123456<br>y&#x3D;’%o’%a   	    #转换为八进制串<br>z&#x3D;’%x’%a   	    #转换为十六进制串<br>za&#x3D;’%0x’%a  	#16进制数前添加0x<br>se&#x3D;’%e’%a 	    #转换为科学计数法串，基底e<br>se              #小数点前有一位非零数字，小数点后是6位小数<br>‘%e’%12345.678 	#科学计数法，基底e  ‘1.234568e+04’<br>‘%E’%12345.678 	#科学计数法，基底E   ‘1.234568E+04’<br>‘%g’%12345.678    	#采用浮点数形式，根据值的大小采用%e或%f<br>‘%G’%12345.678    	#采用浮点数形式<br>‘%.4G’%12345.678  	#采用科学计数法形式，基底E<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>‘<br>运行运行<br>5.3.2 format()方法格式化字符串<br>format()方法是通过{}和:来代替传统%方式</p>
<p>首先看{}和参数的对应关系</p>
<p>‘我叫{},今年{}岁’.format(‘张清’,18)   #以下输出均为’我叫张清,今年18岁’<br>‘我叫{0},今年{1}岁’.format(‘张清’,18)<br>‘我叫{1},今年{0}岁’.format(18,’张清’)</p>
<p>my&#x3D;[‘张清’,18]<br>‘我叫{},今年{}岁’.format(<em>my)         #列表前加</em>，自动解包<br>‘我叫{0[0]},今年{0[1]}岁’.format(my)  #列表不加*，则需要用列表的索引元素<br>      #{后的0表示第一个参数(若有第2个参数，则为1)，[]中的数字表示列表元素的索引<br>‘我叫{name},今年{age}岁’.format(name&#x3D;’张清’,age&#x3D;18)  #直接写变量名<br>‘我叫{name},今年{age}岁’.format(age&#x3D;18,name&#x3D;’张清’)  #有了名字之后，就可以任意顺序</p>
<p>my&#x3D;{‘name’:’张清’,’age’:18}<br>‘我叫{name},今年{age}岁’.format(<strong>my)  #字典前加</strong>，自动解包</p>
<p>‘{0:.2f}’.format(2&#x2F;3)  #十进制的0.67<br>‘{0:b}’.format(8)      #二进制<br>‘{0:o}’.format(8)      #八进制<br>‘{0:x}’.format(18)     #十六进制<br>‘{:,}’.format(1234567890)  	#千分位格式化，1,234,567,890<br>‘{0:<em>&gt;10}’.format(18)  		#右对齐  ‘*<strong>*<em><strong><em>18’<br>‘{0:</em>&lt;10}’.format(18)  		#左对齐  ‘18</strong></em>*</strong>*</em>‘<br>‘{0:<em>^9}’.format(18)  		#居中对齐 ‘<em><strong>18</strong></em></em>‘<br>‘{0:0&#x3D;10}’.format(-18) 		    #0放在-和18中间  ‘-000000018’<br>‘{0:_},{0:#x}’.format(9999) 	#_作为分隔符（起到千分位的作用）   ‘9_999,0x270f’</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>‘<br>运行运行<br>5.3.3 带f前缀的格式化字符串<br>name&#x3D;’张清’<br>age&#x3D;18<br>f’我叫{name},今年{age}岁’<br>1<br>2<br>3<br>‘<br>运行运行</p>
<h2 id="5-4-字符串截取"><a href="#5-4-字符串截取" class="headerlink" title="5.4 字符串截取"></a>5.4 字符串截取</h2><p>字符串 属于 序列 类型，同样，可以使用索引或者切片。</p>
<p>单个字符</p>
<p>索引str[index]取出单个字符<br>切片字符</p>
<p>str[start : end : step]取出一片字符。同序列的切片。<br>s&#x3D;”student”<br>s[1:3]       #取出位置为1到位置为2的字符，不包括位置3的字符  ‘tu’<br>s[:3]        #取出从头至位置为2的字符   ‘stu’<br>s[-2:]       #取出从倒数第2个位置开始的所有字符,从左往右取（步长默认是1）  ‘nt’<br>s[:]         #正序全部字符<br>s[::-1]      #逆序全部字符<br>s[::2]       #步长为2<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>‘<br>运行运行<br>字符串属于不可变序列类型，不支持字符串修改</p>
<h2 id="5-5-字符串常用内置函数"><a href="#5-5-字符串常用内置函数" class="headerlink" title="5.5 字符串常用内置函数"></a>5.5 字符串常用内置函数</h2><p>s&#x3D;’Merry days will come,believe.’<br>len(s)        #字符串长度<br>max(s)        #最大字符<br>min(s)        #最小字符：本处为空格<br>ord(‘M’)      #获取该字符的Unicode码  77<br>chr(77)       #把编码转换为对应的字符  ‘M’<br>ord(‘好’)     #汉字的编码<br>chr(22909)</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>‘<br>运行运行</p>
<h2 id="5-6字符串常用方法"><a href="#5-6字符串常用方法" class="headerlink" title="5.6字符串常用方法"></a>5.6字符串常用方法</h2><p>由于字符串属于不可变序列，下述方法中涉及到返回字符串的都是新字符串，原有字符串对象不变。</p>
<p>1.center()、ljust()、rjust()<br>格式：</p>
<p>center(width, fillchar&#x3D;’ ‘) 居中对齐<br>ljust(width, fillchar&#x3D;’ ‘) 左对齐<br>rjust(width, fillchar&#x3D;’ ‘) 右对齐<br>说明：</p>
<p>width：指定宽度；<br>fillchar：填充的字符，默认为空格。<br>功能：</p>
<p>返回一个宽度为width的新字符串，原字符串居中（左对齐或右对齐）出现在新字符串中，如果width大于字符串长度，则使用fillchar进行填充。<br>‘你好’.center(10) 	#居中对齐，以空格填充    ‘    你好    ‘<br>‘你好’.center(11,”<em>“) 	#居中对齐，以</em>填充   ‘*<strong><strong>你好</strong></strong>‘<br>‘你好’.ljust(10,”!”) 	#右对齐，以！填充   ‘你好!!!!!!!!’<br>‘你好’.rjust(10,”-“) 	#左对齐，以-填充  ‘——–你好’<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>2.lower()、upper()<br>lower()方法将大写字母转换为小写字母，其他字符不变，并返回新字符串（全部为小写字母）。<br>upper()方法将小写字母转换为大写字母，其他字符不变，并返回新字符串（全部为大写字母）。<br>用处：解决有关不区分大小写问题</p>
<p>3.capitalize()、title()、swapcase()<br>capitalize()：将整个字符串 首字母转换为大写形式，其他字母转换为小写形式。<br>title()： 将每个单词的首字母转换为大写形式，其他部分的字母转换为小写形式。<br>swapcase()：将大小写互换。<br>提醒：均返回新字符串，原字符串对象不做任何修改。</p>
<p>4.islower()、isupper()、isdigit()<br>功能：测试字符串是否为全小写、大写、数字。如果是，则返回True；否则返回False。</p>
<p>其他的方法，请通过“help(str)”自行查看帮助信息。</p>
<p>5.find()、rfind()<br>格式：</p>
<p>S.find(sub[, start[, end]])<br>S.rfind(sub[, start[, end]])<br>说明：</p>
<p>sub：字符串（子串）；<br>start：开始位置；<br>end：结束位置。查找范围start开始，end结束，不包括end。<br>功能：</p>
<p>在字符串S中，在[start,end)范围内查找并返回子串sub首次出现的位置索引<br>如果没有找到则返回-1。<br>默认范围是整个字符串。<br>其中find()方法从左往右查找，rfind()方法从右往左查找。<br>6.index()、rindex()<br>格式：</p>
<p>S.index(sub[, start[, end]])<br>S.rindex(sub[, start[, end]])<br>功能：</p>
<p>在字符串S中，查找并返回在[start,end)范围内，子串sub首次出现的位置索引<br>如果不存在则抛出异常。(和find()、rfind()的不同点)<br>默认范围是整个字符串。<br>其中index()方法从左往右查找，rindex()方法从右往左查找。<br>7.count()<br>格式：</p>
<p>S.count(sub[, start[, end]])<br>功能：</p>
<p>在字符串S中，查找并返回[start,end)范围内子串sub出现的次数<br>如果不存在，则返回0。<br>默认范围是整个字符串。<br>8.split()<br>功能：</p>
<p>以指定字符为分隔符，从左往右将字符串分割开来，并将分割后的结果组成列表返回。<br>如果字符串中的某种字符出现0次或多次，可以利用split()方法，根据该字符把字符串分离成多个子串组成的列表。<br>对于split()，如果不指定分隔符，实际上表示以任何空白字符（包括连续出现的）作为分隔符。</p>
<p>空白字符包括空格、换行符、制表符等。</p>
<p>除了split()，还有rsplit()，表示从右往左将字符串分割开来，这两种方法还能指定最大分隔次数</p>
<p>9.join()<br>join()方法可用来连接序列中的元素，并在两个元素之间插入指定字符，返回一个字符串</p>
<p>join()方法是split()方法的逆方法</p>
<p>s&#x3D;’Heart is living in tomorrow’<br>slie&#x3D;s.split()    #用空格分割<br>ss&#x3D;’ ‘.join(slie)  #用空格接上<br>1<br>2<br>3<br>‘<br>运行运行<br>10.replace()<br>格式：</p>
<p>replace(old,new,count&#x3D;-1)<br>功能：</p>
<p>查找字符串中old子串并用new子串来替换。<br>参数count默认值为-1，表示替换所有匹配项，否则(count为其他值时）最多替换count次。<br>返回替换后的新字符串（原字符串不变）。<br>s1&#x3D;’中国北京，北京地铁，地铁沿线，北京沿线城市’<br>s4&#x3D;s1.replace(‘北京’,’Beijing’,2)	    #指定最大替换次数<br>1<br>2<br>‘<br>运行运行<br>11.maketrans()、translate()<br>maketrans()：生成字符映射表<br>translate()：根据字符映射表替换字符。<br>这两种方法联合起来使用可以一次替换多个字符。<br>t&#x3D;’’.maketrans(‘iort’,’mn24’)	#两个序列中的元素按照次序一一对应，用于替换<br>#{105: 109, 111: 110, 114: 50, 116: 52}<br>s&#x3D;’Heart is living in tomorrow’<br>s.translate(t)<br>#’Hea24 ms lmvmng mn 4nmn22nw’<br>#’Heart is living in tomorrow’<br>1<br>2<br>3<br>4<br>5<br>6<br>‘<br>运行运行<br>12.strip()<br>strip()：去除字符串两侧的空白字符(空格、回车、制表符等）或指定字符，并返回新字符串。</p>
<p>s1&#x3D;’HHwHeart is liwving iHn tomorrowHww’<br>s1.strip(‘Hw’)	#从两端逐一去除“H”或“w”字符，直到不是这两个字符为止（中间的字符Hw不能去除）<br>1<br>2<br>‘<br>运行运行</p>
<h2 id="5-7-字符串string模块"><a href="#5-7-字符串string模块" class="headerlink" title="5.7 字符串string模块"></a>5.7 字符串string模块</h2><p>字符串string模块定义了Formatter类、Template类、capwords函数和常量，熟悉string模块可以简化某些字符串的操作。</p>
<p>import string<br>s&#x3D;input(‘请输入英文单词，用空格分隔：’)<br>ss&#x3D;string.capwords(s)      #用到了string.capwords()函数<br>print(‘单词首字母大写：’,ss)<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>说明：这种方法直接用到string模块中的常量ascii_lowercase和random模块中choice()方法。choice()方法的功能是在一个非空的序列中随机选择一个元素。</p>
<p>import random<br>x&#x3D;’012345abcde’<br>random.choice(x)<br>1<br>2<br>3<br>‘<br>运行运行</p>
<h2 id="5-8正则表达式"><a href="#5-8正则表达式" class="headerlink" title="5.8正则表达式"></a>5.8正则表达式</h2><p>5.8.1正则表达式的元字符<br>正则表达式（模式串）中的字符，根据作用不同，分为两类：</p>
<p>普通字符：大多数字母和字符一般都会和自身匹配。<br>元字符：有些字符比较特殊，它们和自身并不匹配，而是表明应和一些特殊的东西匹配，或者会影响重复次数。<br>因为在模式串中常常有特殊字符，为了书写方便，在字符串前加r前缀，不对其进行转义。</p>
<p>第一种情况：<br>模式串中全部是 普通字符</p>
<p>import re      #导入re模块<br>w&#x3D;’abc’                      #模式串中 全部是普通字符<br>re.findall(w,’aabaab’)  			#无匹配<br>re.findall(w,’aabcaabc’) 			#两处匹配（查找到两个）<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>第二种情况：<br>模式串中含有 元字符</p>
<p>常用的元字符：</p>
<p>1.“.”：表示任意单个字符 (除换行符以外)<br>import re<br>s&#x3D;’hi,i am a student.my name is Hilton.’<br>re.findall(r’i’,s) 		    #在s中，匹配所有的i<br>1<br>2<br>3<br>‘<br>运行运行<br>s&#x3D;’’’hi,<br>i student.<br>Hilton.’’’       #三引号字符串中可以有换行符<br>re.findall(r’.’,s)          #本结果中：没有匹配两个换行符<br>1<br>2<br>3<br>4<br>s&#x3D;’hi,i am a student.my name is Hilton.’<br>re.findall(r’i.’,s) 	    #匹配i后面跟除换行符以外的任意字符的形式<br>                   #必须是两个字符：第一个是i，第2个是换行符以外的任意字符，可以是空白符<br>1<br>2<br>3<br>2.“[]”：指定字符集<br>用来指定一个字符集合，例如：[abc]、[a-z]、[0-9]；<br>从字符集合中必须选一个，也只能选一个字符（即单个字符）<br>有些元字符在方括号中不起作用（作为普通字符）,例如：[akm$]和[m.]中元字符都不起作用；<br>方括号内的“”表示补集，匹配不在区间范围内的字符，例如：[3]表示除3以外的字符。<br>import re<br>s&#x3D;’mat mit mee mwt meqwt’<br>re.findall(r’m[iw]t’,s)        #匹配m后跟i或者w再跟t形式：mit  mwt<br>                               #查找3个字符：第1字符必须是m，第3字符必须是t，中间字符只能是iw中的一个<br>1<br>2<br>3<br>4<br>‘<br>运行运行<br>3.“^”：匹配行首，匹配每 行 中以^后面的字符开头的字符串（必须放在模式串的开头）<br>英文称为caret (英语发音：&#x2F;ˈkærət&#x2F;)<br>记忆法：^数学上读作hat，帽子（戴头上），可以形象的想象成 首部</p>
<p>匹配模式：</p>
<p>默认只匹配多行字符串的首行；<br>多行匹配需要单独设置re.M参数。<br>4.“” ： 匹 配 ‘ 行 尾 ‘ ， 匹 配 每 行 中 以 ”：匹配<code>行尾</code>，匹配每行中以”：匹配‘行尾‘，匹配每行中以之前的字符结束的字符串<br>英语读作dollar，音标：[‘dɒlə®]<br>记忆法：$，可以形象的想象成 弯曲的尾巴，“行尾”</p>
<p>匹配模式：</p>
<p>默认只匹配多行字符串的末行；<br>多行匹配需要单独设置re.M参数。<br>5.“\”：反斜杠后面可以加不同的字符以表示不同的特殊意义（四对）<br>\b匹配单词头或单词尾（\b放前面，会匹配单词头；\b放后面，会匹配单词尾）；相当于^或$(但这两个只能用于整个字符串，不能切分单词)</p>
<p>\B与\b相反，匹配非单词头或单词尾（不查找单词头或单词尾，只查其他部分）；</p>
<p>\d匹配任何数字字符；相当于[0-9]；</p>
<p>\D与\d相反，匹配任何非数字字符，相当于[^0-9]；</p>
<p>\s匹配任何空白字符，相当于[\t\n\r\f\v]；</p>
<p>\S与\s相反，匹配任何非空白字符，相当于[^\t\n\r\f\v]；\t是制表符，\f是换页符，\v是垂直制表符</p>
<p>\w匹配任何字母、数字或下画线字符，相当于[a-zA-Z0-9_]；</p>
<p>\W与\w相反，匹配任何非字母、数字和下画线字符，相当于[^a-zA-Z0-9_]；</p>
<p>也可以用于取消所有的元字符：\、[。</p>
<p>这些特殊字符都可以包含在[]中。如：[\s,.]将匹配任何空白字符、”,“或”.”。</p>
<p>第一对：\b和\B</p>
<p>字符串中切分单词的分隔符，包括空格、换行、制表符、各种标点符号。</p>
<p>\b：单词头&#x2F;单词尾：注意不是整个字符串，而是分隔后的每个单词</p>
<p>\B：和\b相反（不查开头&#x2F;结尾的，只查其他部分的）</p>
<p>第二对：\d与\D</p>
<p>\d:数字字符，等同于[0-9]</p>
<p>\D：和\d相反，等同于[^0-9]（非数字字符）</p>
<p>第三对：\s与\S</p>
<p>\s：匹配（查找）任何空白字符，相当于[\t\n\r\f\v]：横向制表符、换行、回车、换页符、纵向制表符</p>
<p>\S：和\s相反，不匹配（查找）任何空白字符，相当于[^\t\n\r\f\v]</p>
<p>\S与“.”区别</p>
<p>“.”， 表示任意单个字符（换行符除外）<br>“\S”，表示任意单个字符（空白符除外）。注意是大写的S。<br>第四对：\w与\W</p>
<p>\w：匹配任何字母、数字或下画线字符，相当于[a-zA-Z0-9_]</p>
<p>\W：和\w相反，不匹配任何字母、数字或下画线字符，相当于[^a-zA-Z0-9_]</p>
<p>第五点：用\取消元字符</p>
<p>s&#x3D;’hi,i am a student.my name is Hilton.’<br>re.findall(r’t.’,s)    #此时的.就是元字符：匹配(查找)t+任意字符<br>re.findall(r’t.‘,s)    #此时的.就是普通的字符：匹配(查找)t.<br>1<br>2<br>3<br>第六点：\d、\D、\s、\S、\w、\W也可以用在[]内</p>
<p>以上5类元字符都是表示单个字符。<br>.:任意单个字符（换行符除外）<br>[]:集合中的任意单个字符<br>^:行首<br>$:行尾<br>:\b\d\s\w</p>
<p>量词<br>正则表达式能指定正则表达式的一部分的重复次数，用到的元字符有“*”、“+”、“?”、“{}”。</p>
</article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.jinyincaibao.online/2023/07/16/5/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=undefined&amp;url=https://www.jinyincaibao.online/2023/07/16/5/&amp;pic=undefined" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>计算机语言<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/66dd47e6d9c307b7e9aae384.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.jinyincaibao.online/2023/07/16/5/">原创</a><a class="post-copyright-title"><span>Python</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"></span><a class="link" href="https://www.jinyincaibao.online">金银财宝</a></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a class="link" href="https://www.jinyincaibao.online/2023/07/16/5/">https://www.jinyincaibao.online/2023/07/16/5/</a></span><span class="copy-button" onclick="rm.copyPageUrl('https://www.jinyincaibao.online/2023/07/16/5/)'"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.jinyincaibao.online" target="_blank">金银财宝</a>！</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/15/1/"><img class="prev-cover" src="https://pic.imgdb.cn/item/66dd3846d9c307b7e99019c2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">编程语言实现的程序</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/19/10/"><img class="next-cover" src="https://pic.imgdb.cn/item/66dd38cfd9c307b7e990ccdf.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">STM32</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author-info-top"> <div class="card-info-avatar"><a class="avatar-img" href="/about"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66daa709d9c307b7e9042d3a.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></a><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="writing_hand" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270d.png">✍️</g-emoji><span>on Studying</span></div></div></div></div><div class="author-info__sayhi" id="author-info__sayhi"></div><h1 class="author-info__name">金银财宝</h1><div class="author-info__description">大好青年，事业有为。</div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/H-jfeng" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/frame_html?sid=dozdw2LJoUeyizdT&amp;r=0d94d63e78efbec9830f1bae3bd0223d&amp;lang=zh" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">二、语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.1.</span> <span class="toc-text">2.1标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.2.1标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2.2关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B4%E5%9E%8Bint"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.整型int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E6%95%B0float"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.浮点数float</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%8D%E6%95%B0complex"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.复数complex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B8%83%E5%B0%94bool"><span class="toc-number">2.2.4.</span> <span class="toc-text">4.布尔bool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2str"><span class="toc-number">2.2.5.</span> <span class="toc-text">5.字符串str</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%97%E8%A1%A8-list"><span class="toc-number">2.2.6.</span> <span class="toc-text">6.列表 list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%85%83%E7%BB%84-tuple"><span class="toc-number">2.2.7.</span> <span class="toc-text">7.元组 tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AD%97%E5%85%B8-dict"><span class="toc-number">2.2.8.</span> <span class="toc-text">8.字典 dict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E9%9B%86%E5%90%88-set"><span class="toc-number">2.2.9.</span> <span class="toc-text">9.集合 set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.</span> <span class="toc-text">2.3赋值语句、运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1赋值语句的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.2.0.1.</span> <span class="toc-text">1.算数运算符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">2.关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">3.测试运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">4.逻辑运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E4%BB%8E%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">2.4.</span> <span class="toc-text">2.4从控制台输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-input-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">1. input()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.类型转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-number">2.4.3.</span> <span class="toc-text">3.数据的输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">2.5内置函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">三、流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">3.1分支结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">3.2循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1for%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1for循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-break%E8%AF%AD%E5%8F%A5%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 break语句和continue语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E5%B8%A6else%E7%9A%84%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%EF%BC%88%E4%B8%8EC%E8%AF%AD%E8%A8%80%E4%B8%8D%E5%90%8C%EF%BC%8C%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 带else的循环语句（与C语言不同，不建议用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4循环嵌套</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">四、常用数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%BA%8F%E5%88%97"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1%E5%88%97%E8%A1%A8-list"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1列表 list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%97%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.列表的创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">4.2.</span> <span class="toc-text">2.列表的元素访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.</span> <span class="toc-text">3.修改元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%97%E8%A1%A8%E5%88%87%E7%89%87"><span class="toc-number">4.4.</span> <span class="toc-text">4.列表切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-del%E5%91%BD%E4%BB%A4"><span class="toc-number">4.4.1.</span> <span class="toc-text">5. del命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.2.</span> <span class="toc-text">7.列表方法：类型本身的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%88%97%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="toc-number">4.4.3.</span> <span class="toc-text">9.列表遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-2%E5%85%83%E7%BB%84"><span class="toc-number">4.5.</span> <span class="toc-text">4.1.2元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%83%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.5.1.</span> <span class="toc-text">1.元组的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%83%E7%BB%84%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">4.5.2.</span> <span class="toc-text">2.元组的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E5%88%97%E8%A1%A8%E4%B8%8E%E5%85%83%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.5.3.</span> <span class="toc-text">4.1.3 列表与元组的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%97%E8%A1%A8%E2%80%93-gt-%E5%85%83%E7%BB%84"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">1.列表–&gt;元组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%83%E7%BB%84%E2%80%93-gt-%E5%88%97%E8%A1%A8"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">2.元组–&gt;列表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%AD%97%E5%85%B8"><span class="toc-number">4.6.</span> <span class="toc-text">4.2 字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.2.1 创建字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%AD%97%E5%85%B8%E6%93%8D%E4%BD%9C"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.2.2 字典操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E5%85%B8%E4%B8%AD%E2%80%9C%E9%94%AE-%E5%80%BC%E2%80%9D%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">1.字典中“键-值”对的数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%89%B9%E5%AE%9A%E9%94%AE%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E5%80%BC%EF%BC%9A%E9%94%AE%E2%80%94-gt-%E5%80%BC"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">2.查找与特定键相关联的值：键—&gt;值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">4.6.2.3.</span> <span class="toc-text">3.修改字典中的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E5%AD%97%E5%85%B8%E6%9D%A1%E7%9B%AE"><span class="toc-number">4.6.2.4.</span> <span class="toc-text">4.删除字典条目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%AD%97%E5%85%B8%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.3.</span> <span class="toc-text">4.2.3 字典方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-keys-%E3%80%81values"><span class="toc-number">4.6.3.1.</span> <span class="toc-text">1.keys()、values()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-items"><span class="toc-number">4.6.3.2.</span> <span class="toc-text">2.items()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-setdefault"><span class="toc-number">4.6.3.3.</span> <span class="toc-text">3.setdefault()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-update"><span class="toc-number">4.6.3.4.</span> <span class="toc-text">4.update()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-clear"><span class="toc-number">4.6.3.5.</span> <span class="toc-text">5.clear()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-pop"><span class="toc-number">4.6.3.6.</span> <span class="toc-text">6.pop()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-popitem"><span class="toc-number">4.6.3.7.</span> <span class="toc-text">7.popitem()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-get"><span class="toc-number">4.6.3.8.</span> <span class="toc-text">8.get()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8"><span class="toc-number">4.6.4.</span> <span class="toc-text">4.2.4遍历字典</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8%E7%9A%84key"><span class="toc-number">4.6.4.1.</span> <span class="toc-text">1.遍历字典的key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8%E7%9A%84%E5%80%BCValue"><span class="toc-number">4.6.4.2.</span> <span class="toc-text">2.遍历字典的值Value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">4.6.4.3.</span> <span class="toc-text">3.遍历字典的键值对</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.6.5.</span> <span class="toc-text">4.2.5列表、元组、字典的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%97%E8%A1%A8%E4%B8%8E%E5%AD%97%E5%85%B8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%EF%BC%9A%E5%AD%97%E5%85%B8%E2%80%93-gt-%E5%88%97%E8%A1%A8"><span class="toc-number">4.6.5.1.</span> <span class="toc-text">1.列表与字典之间的转化：字典–&gt;列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%83%E7%BB%84%E4%B8%8E%E5%AD%97%E5%85%B8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%EF%BC%9A%E5%AD%97%E5%85%B8%E2%80%93-gt-%E5%85%83%E7%BB%84"><span class="toc-number">4.6.5.2.</span> <span class="toc-text">2.元组与字典之间的转化：字典–&gt;元组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E9%9B%86%E5%90%88-Set"><span class="toc-number">4.7.</span> <span class="toc-text">4.3 集合 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E9%9B%86%E5%90%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.7.1.</span> <span class="toc-text">4.3.1 集合的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E9%9B%86%E5%90%88%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">4.7.2.</span> <span class="toc-text">4.3.2 集合的运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-len-%E3%80%81max-%E3%80%81min-%E3%80%81sum"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">1.len() 、max()、min()、sum()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-in"><span class="toc-number">4.7.2.2.</span> <span class="toc-text">2.in</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B9%B6%E9%9B%86%E3%80%81%E4%BA%A4%E9%9B%86"><span class="toc-number">4.7.2.3.</span> <span class="toc-text">3.并集、交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B7%AE%E9%9B%86"><span class="toc-number">4.7.2.4.</span> <span class="toc-text">4.差集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AF%B9%E7%A7%B0%E5%B7%AE"><span class="toc-number">4.7.2.5.</span> <span class="toc-text">5.对称差</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AD%90%E9%9B%86%E5%92%8C%E8%B6%85%E9%9B%86"><span class="toc-number">4.7.2.6.</span> <span class="toc-text">6.子集和超集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.7.3.</span> <span class="toc-text">4.3.3 集合的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-union-%E3%80%81intersection"><span class="toc-number">4.7.3.1.</span> <span class="toc-text">1.union()、intersection()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-update"><span class="toc-number">4.7.3.2.</span> <span class="toc-text">2.update()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-difference"><span class="toc-number">4.7.3.3.</span> <span class="toc-text">3.difference()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-symmetric-difference"><span class="toc-number">4.7.3.4.</span> <span class="toc-text">4.symmetric_difference()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-issubset-%E5%92%8Cissuperset"><span class="toc-number">4.7.3.5.</span> <span class="toc-text">5.issubset()和issuperset()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-add"><span class="toc-number">4.7.3.6.</span> <span class="toc-text">6.add()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-remove"><span class="toc-number">4.7.3.7.</span> <span class="toc-text">7.remove()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-discard"><span class="toc-number">4.7.3.8.</span> <span class="toc-text">8.discard()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-pop"><span class="toc-number">4.7.3.9.</span> <span class="toc-text">9.pop()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-clear"><span class="toc-number">4.7.3.10.</span> <span class="toc-text">10.clear()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1Iterable-%E4%B8%8E-%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator"><span class="toc-number">4.8.</span> <span class="toc-text">4.4 可迭代对象Iterable 与 迭代器Iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E5%8F%AF%E8%BF%AD%E4%BB%A3-Iterable-%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.8.1.</span> <span class="toc-text">4.4.1 可迭代(Iterable)对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E7%9B%B8%E5%85%B3%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.2.</span> <span class="toc-text">4.4.2 相关内置函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">4.9.</span> <span class="toc-text">4.5 推导式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">4.9.1.</span> <span class="toc-text">4.5.1 列表推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">4.9.2.</span> <span class="toc-text">4.5.2 字典推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E9%9B%86%E5%90%88%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">4.9.3.</span> <span class="toc-text">4.5.3 集合推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-4-%E7%94%9F%E6%88%90%E5%99%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">4.9.4.</span> <span class="toc-text">4.5.4 生成器推导式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">五、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 字符串的编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 字符串的构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 字符串格式化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 字符串截取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 字符串常用内置函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">5.6字符串常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%A8%A1%E5%9D%97"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 字符串string模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.8.</span> <span class="toc-text">5.8正则表达式</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://mail.qq.com/cgi-bin/frame_html?sid=-QfjIIHgxSPDpRl-&amp;r=eb57706bd15faba6d3aab058ea4e8d41&amp;lang=zh" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/6378063631" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.facebook.com/profile.php?id=100092208016287&amp;sk=about" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><img class="footer_mini_logo" title="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src="https://pic.imgdb.cn/item/66dd9db5d9c307b7e93f321e.png" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/H-jfeng" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/1463547681?spm_id_from=333.1007.0.0" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.douyin.com/user/self?from_tab_name=main&amp;showTab=like" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" target="_blank" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a><a class="footer-item" title="更新日志" target="_blank" href="/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" target="_blank" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" target="_blank" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" target="_blank" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" target="_blank" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" target="_blank" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" target="_blank" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><div class="copyright">&copy;2020 - 2024 By 金银财宝</div><div id="workboard"><img class="workSituationImg boardsign" src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div></footer></div></div></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://pic.imgdb.cn/item/66daa709d9c307b7e9042d3a.png"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
    Pace.restart()
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://pic.imgdb.cn/item/66dd949dd9c307b7e9308f6b.jpg"/><script async="async" src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66daa709d9c307b7e9042d3a.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 统计图</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9320926809&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button type="button" title="切换背景" onclick="toggleWinbox()"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="center-console" type="button" title="中控台"><i class="anzhiyufont anzhiyu-icon-fish"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><div id="console-music-bg"></div><meting-js id="9320926809" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="console"><div class="close-btn" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-xmark" style="font-size: 35px;"></i></div><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://img1.imgtp.com/2023/08/15/BePdzusW.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/08/15/BePdzusW.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://img1.imgtp.com/2023/08/15/jqcGMBFZ.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/08/15/jqcGMBFZ.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Hexo/" style="font-size: 1.05rem; color: rgb(138, 20, 69);">Hexo<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem; color: rgb(2, 177, 182);">html<sup>1</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem; color: rgb(50, 38, 49);">嵌入式编程<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem; color: rgb(142, 65, 105);">算法<sup>1</sup></a><a href="/tags/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD/" style="font-size: 1.05rem; color: rgb(85, 163, 34);">考研英语<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 1.05rem; color: rgb(112, 111, 174);">计算机<sup>3</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem; color: rgb(127, 138, 78);">计算机语言<sup>3</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem; color: rgb(149, 94, 80);">项目<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8921687509&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@17.3.1/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>var meting_api = "https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r";
</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 1.3.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 金银财宝 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2021 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
      img.title = "下班了就该开开心心的玩耍，嘿嘿~";
      img.alt = "下班了就该开开心心的玩耍，嘿嘿~";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";</script><script>//动态标题
let leaveTitle = 'w(ﾟДﾟ)w 不要走！再看看嘛！';
let backTitle = '♪(^∇^*)欢迎肥来！';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | 金银财宝")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();

anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script>LA.init({id: "3FaQCNdNtNTCmsoI", ck: "3FaQCNdNtNTCmsoI"});
new LingQue.Monitor().init({id: "3Jd73jIfQDR8chQv", sendSuspicious:true});</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.0/icon/ali_iconfont_css.css"><script src="/js/sakura.js"></script><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script src="/js/share.js"></script><script async data-pjax src="/js/imgloaded.js?1"></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script defer="true" src="/js/welcome.js"></script><script async src="/js/fps.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<container><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></container>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/charts/'|| '/charts/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?Fomalhaut-Blog",['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'],'Fomalhaut-Blog')
    }
  </script><!-- hexo injector body_end end --></body></html>