<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++ | 金银财宝</title><meta name="keywords" content="计算机语言"><meta name="author" content="金银财宝"><meta name="copyright" content="金银财宝"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#9796f0"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++"><meta name="application-name" content="C++"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#9796f0"><meta name="description" content="第2章 开始学习C++2.1 进入C++2.1.6 使用cout进行C++输出第6章 分支语句和逻辑运算符6.8 简单文件输入输出第11章 使用类11.6类的自动转换和强制类型转换 数据类型的转换 1234double tine &#x3D; 11;  int side &#x3D; 3.33;  都是正确的，将进行自动类型转换int *p &#x3D; 10;    不会进行自动转换，是不兼容的类型，可进行强制类型转换int">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="https://www.jinyincaibao.online/2023/08/19/2/index.html">
<meta property="og:site_name" content="金银财宝">
<meta property="og:description" content="第2章 开始学习C++2.1 进入C++2.1.6 使用cout进行C++输出第6章 分支语句和逻辑运算符6.8 简单文件输入输出第11章 使用类11.6类的自动转换和强制类型转换 数据类型的转换 1234double tine &#x3D; 11;  int side &#x3D; 3.33;  都是正确的，将进行自动类型转换int *p &#x3D; 10;    不会进行自动转换，是不兼容的类型，可进行强制类型转换int">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/66dd47e6d9c307b7e9aae384.jpg">
<meta property="article:published_time" content="2023-08-19T04:00:00.000Z">
<meta property="article:modified_time" content="2023-08-19T04:00:00.000Z">
<meta property="article:author" content="金银财宝">
<meta property="article:tag" content="计算机语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/66dd47e6d9c307b7e9aae384.jpg"><link rel="shortcut icon" href="https://pic.imgdb.cn/item/66daa709d9c307b7e9042d3a.png"><link rel="canonical" href="https://www.jinyincaibao.online/2023/08/19/2/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="9f1f8e31c0e37a081430a812a31d7ef0"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: undefined,
  navMusic: true,
  changeMainColorPost: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"bottom-lef"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-19 12:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#9796f0')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#9796f0')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button" tabindex="-1"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.jingyingcaibao.online/" title="博客" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66dadacbd9c307b7e94c2e19.png" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" href="https://chatgpt.com/chat" title="ChatGpt" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66daa709d9c307b7e9042d3a.png" alt="ChatGpt"/><span class="back-menu-item-text">ChatGpt</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title"></div><div class="back-menu-list"><a class="back-menu-item" target="_blank"><img class="back-menu-item-icon"/><span class="back-menu-item-text"></span></a></div></div></div></div><a id="site-name" href="/"><div class="title">金银财宝</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8921687509&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 统计图</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" style="display: flex"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div class="nav-button" id="darkmode_navswitch"><a class="darkmode_switchbutton" type="button" href="javascript:void(0);" title="浅色和深色模式转换" onclick="anzhiyu.switchDarkMode()"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke" style="font-size: 1.3rem"></i></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>计算机语言</span></a></span></div></div><h1 class="post-title">C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-19T04:00:00.000Z" title="发表于 2023-08-19 12:00:00">2023-08-19</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-19T04:00:00.000Z" title="更新于 2023-08-19 12:00:00">2023-08-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">18.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>70分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C++"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为湖南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>湖南</span></div></div></div><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><div id="ai-tag">Tianli GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己</div><div class="ai-btn-item">生成本文简介</div><div class="ai-btn-item">推荐相关文章</div><div class="ai-btn-item">前往主页</div><div class="ai-btn-item" id="go-tianli-blog">前往tianli博客</div></div><script data-pjax>(function(){
  // 当前随机到的ai摘要到index
  let lastAiRandomIndex = -1;
  let animationRunning = true; // 标志变量，控制动画函数的运行
  // 当前gpt模式
  let mode = "tianli"
  // 刷新点击次数
  let refreshNum = 0
  // 记录上一次传递给aiAbstract的参数
  let prevParam;
  const aiTitleRefreshIcon = document.querySelector(".ai-title .anzhiyufont.anzhiyu-icon-arrow-rotate-right")
  const explanation = document.querySelector(".ai-explanation");
  const post_ai = document.querySelector(".post-ai-description");
  let ai_str = "";
  let ai_str_length = "";
  let delay_init = 600;
  let i = 0;
  let j = 0;
  let sto = [];
  let elapsed = 0;
  const animate = timestamp => {
    if (!animationRunning) {
      return; // 动画函数停止运行
    }
    if (!animate.start) animate.start = timestamp;
    elapsed = timestamp - animate.start;
    if (elapsed >= 20) {
      animate.start = timestamp;
      if (i < ai_str_length - 1) {
        let char = ai_str.charAt(i + 1);
        let delay = /[,.，。!?！？]/.test(char) ? 150 : 20;
        if (explanation.firstElementChild) {
          explanation.removeChild(explanation.firstElementChild);
        }
        explanation.innerHTML += char;
        let div = document.createElement("div");
        div.className = "ai-cursor";
        explanation.appendChild(div);
        i++;
        if (delay === 150) {
          document.querySelector(".ai-explanation .ai-cursor").style.opacity = "0";
        }
        if (i === ai_str_length - 1) {
          observer.disconnect(); // 暂停监听
          explanation.removeChild(explanation.firstElementChild);
        }
        sto[0] = setTimeout(() => {
          requestAnimationFrame(animate);
        }, delay);
      }
    } else {
      requestAnimationFrame(animate);
    }
  };
  const observer = new IntersectionObserver(
    entries => {
      let isVisible = entries[0].isIntersecting;
      animationRunning = isVisible; // 标志变量更新
      if (animationRunning) {
        delay_init = i === 0 ? 200 : 20;
        sto[1] = setTimeout(() => {
          if (j) {
            i = 0;
            j = 0;
          }
          if (i === 0) {
            explanation.innerHTML = ai_str.charAt(0);
          }
          requestAnimationFrame(animate);
        }, delay_init);
      }
    },
    { threshold: 0 }
  );
  function clearSTO() {
    if (sto.length) {
      sto.forEach(item => {
        if (item) {
          clearTimeout(item);
        }
      });
    }
  }
  function startAI(str, df = true) {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    observer.disconnect(); // 暂停上一次监听
    explanation.innerHTML = df ? "生成中. . ." : "请等待. . .";
    ai_str = str;
    ai_str_length = ai_str.length;
    observer.observe(post_ai); //启动新监听
  }

  async function aiAbstract(num = 1000) {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    observer.disconnect(); // 暂停上一次监听
    if (mode === "tianli") {
      num = Math.max(10, Math.min(2000, num));
      const options = {
        key: "i5m48wFrNQDM9fwUs2Lz",
        Referer: "https://www.jingyingcaibao.club/"
      };
      const truncateDescription = ("C++" + "第2章 开始学习C++, 2.1 进入C++, 2.1.6 使用cout进行C++输出, 第6章 分支语句和逻辑运算符, 6.8 简单文件输入输出, 第11章 使用类, 11.6类的自动转换和强制类型转换, 11.6.1转换函数, 11.6.2转换函数和友元函数, 第12章 类和动态内存分配, 12.1动态内存和类, 12.1.1开发一个动态内存类, 12.1.2 特殊成员函数, 12.1.3 回到Stringbad 复制构造函数的哪里出了问题, 12.1.4 StringBad的其他问题：赋值运算符, 改进后的新Stirng类, 12.2.2比较成员函数, 12.2.3使用中括号表示法访问字符, 12.2.4 静态类成员函数, 12.2.5 进一步重载赋值运算符, 12.3 在构造函数中使用new时应注意的事项, 12.3.1 包含类成员的类的逐成员复制, 12.4 有关返回对象的说明, 12.4.1 返回指向const对象的引用, 12.4.2 返回指向非const对象引用, 12.4.3 返回对象, 12.5 使用指向对象的指针, 12.5.1 再谈定位new运算符, 第13章 类继承, 13.1 一个简单的基类, 13.1.1, 13.1.2 构造函数：访问权限的考虑, 13.1.4 派生类和基类之间的特殊关系, 13.2 继承：is-a关系, 13.3 多态公有继承, 13.3.1 开发Brass类和BrassPlus类, 13.4 静态联编和动态联编, 13.4.1 指针和引用类型的兼容性, 13.5 访问控制：protected, 13.6 抽象基类(ABC), 13.6.1 应用ABC概念, 13.7 继承和动态内存分配, 13.7.1 第一种情况：派生类不使用new, 13.7.2 第二种情况：派生类使用new, 13.7.3 友元的继承, 第14章 c++中的代码重用, 14.1 包含对象成员的类, 14.1.1 valarray类简介, 14.1.2 Student类的设计, 14.2 私有继承, 14.2.1 初始化基类组件, 14.2.2 访问基类的方法, 14.2.3 访问基类对象, 14.2.3 访问基类的友元函数, 14.2.4 使用修改后的Student类, 14.2.5 保护继承, 14.2.6 使用using重新定义访问权限, 14.3 多重继承, 14.4 类模板, 14.4.1 定义模板类, 14.4.2 使用类模板, 14.4.3 指针栈x2F指针模板, 14.4.4 数组模板示例和非类型参数, 14.4.4 模板的多功能性, 14.4.6 模板的具体化, 14.4.7 成员模板, 14.4.8 将模板用作参数, 14.4.8 模板类和友元, 14.4.8 模板别名, 第15章 友元、异常和其他, 15.1 友元, 15.1.1 友元类, 15.1.2 友元成员函数, 15.1.3 其他友元关系, 15.1.4 共同的友元, 15.2 嵌套类, 15.2.1 嵌套类和访问权限, 15.2.2 模板中的嵌套, 15.3异常, 15.4 RTTI, 15.4.1 RTTI的用途, 15.4.2 RTTI的工作原理, 15.5 类型转换运算符, 第16章 string类和标准模板库, 16.1 string类, 16.1.1 构造字符串, 16.1.2 string类输入, 16.1.3  使用字符串, 16.2 智能指针模板类, 16.2.1 使用智能指针, 16.2.3 unique_ptr优于auto_ptr, 16.2.4 选择智能指针, 16.3 标准模板库, 16.3.1 模板类vector, 16.3.2 可执行的操作, 16.3.4 基于范围的for循环, 16.4 泛型编程, 16.4.2 迭代器类型, 16.4.4 概念改进和模型, 16.4.5 容器的种类, 16.4.6 关联容器, 16.4.7 无序关联容器, 16.5 函数对象, 16.5.1 函数符概念, 16.5.2 预定义的函数符, 16.5.3 自适应函数符和函数适配器, 16.6 算法, 16.6.1 算法组, 16.6.2 算法的通用特征, 第17章 泛型编程注意的事项第章开始学习进入使用进行输出第章分支语句和逻辑运算符简单文件输入输出第章使用类类的自动转换和强制类型转换数据类型的转换都是正确的将进行自动类型转换不会进行自动转换是不兼容的类型可进行强制类型转换下面的构造函数用于将类型的值转换为类类型介绍的是转换构造函数只能是接受一个参数的构造函数才能这样可以先创建一个临时的的对象并将作为初始值然后将临时对象的内容复制到中为类的隐式转换是自动进行的是关闭隐式转换但仍然允许显式强制类型转换转换还存在二义性还可以用于将值传递给接受参数的函数如果提供了构造函数并且是成员函数的加法函数则可以这样做但只有友元函数才允许这样做转换函数转换函数的概念是将类类型转换为某种类型是用户定义的强制类型转换转换函数必须是类方法不能指定返回类型不能有参数转换为类型的函数返回一个数注意虽然没有声明返回类型但也将返回所需的值是四舍五入的方式而不是去掉小数部分类类型转换为某种类型也会存在二义性不能用于转换函数但可以使用非转换函数替换只能进行强制转换是非法的可以警告应谨慎地使用隐式转换函数通常使用显式的强制类型转换转换函数和友元函数实现加法时的选择要将量和量相加可以有两种方法第章类和动态内存分配动态内存和类开发一个动态内存类使用动态内存分配来开发类使用指针而不是数组这意味着类声明没有为字符串分配存储空间静态类成员特点无论创建了多少对象所有对象共享同一个静态成员例如成员可以记录所创建的对象数目不能在类声明中初始化静态成员变量只能在文件中初始化类外也不可以初始化但如果静态成员是整数类型或枚举类型见第十章则可以在类声明中初始化创建构造函数不会包括末尾的空字符记录对象的数量字符串并不保存在对象中而是保存在堆内存中对象仅保存了指出到哪里去查找字符串的信息不能这样做这只保存了地址而没有创建字符串副本析构函数的使用对象声明放在一个内部代码块中因为析构函数将在定义对象的代码块执行完毕时调用对象的删除的顺序与创建顺序相反在进行输出类时是运用了重载运算符注意查看重载运算符函数中输出的是什么内容编译器会自动生成成员函数和自动使用你不使用函数构造函数析构函数为复制构造函数会创建对象的一个副本调用了一个函数特殊成员函数特殊成员函数是自动定义的有默认构造函数如果没有定义默认析构函数如果没有定义复制构造函数如果没有定义赋值运算符如果没有定义地址运算符如果没有定义返回调用对象的地址即指针的值新增移动构造函数移动运算符默认构造函数如果定义了构造函数将不会定义默认构造函数如果希望在创建对象时不显示地对它进行初始话则必须显示地定义默认构造函数它还可以来设定特定的值在创建对象时不显示地对它进行初始话带参数的构造函数也可以是默认构造函数只要所有参数都有默认值但只有一个默认构造函数不然会造成二义性复制构造函数它用于初始化过程而不是常规的赋值过程每当程序生成了对象副本时编译器都将使用复制构造函数使用初始化一个匿名对象并将新对象的地址赋给指针当按值传递和返回对象时以及编译器生成临时对象例如将个对象相加时编译器可能生成临时的对象来保存中间结果都将调用复制构造函数复制构造函数初始化函数的形参由于按值传递对象将调用复制构造函数在用类为函数的参数时应该按引用传递对象如果成员本身就是类对象则将使用这个类的复制函数来复制成员对象静态成员不受影响因为它们属于整个类显示复制构造函数如果类中包含这样的静态数据成员即其值将在对象被创建时发生变化则应该提供一个显示复制构造函数来处理计数问题回到复制构造函数的哪里出了问题这里复制的并不是字符串而是一个指向字符串的指针得到两个指向同一个字符串的指针相当于由于私有成员是无法访问的因此这些代码是不能通过编译的指向的内容已经被的析构函数释放定义一个显式复制构造函数以解决问题深度复制该复制构造函数应当复制字符串并将副本的地址赋给成员如果类中包含了使用初始化的指针成员应当定义一个深度复制函数的其他问题赋值运算符赋值运算符的功能以及何时使用它将已有的对象赋给另一个对象时将使用重载的赋值运算符使用函数表示法时与复制构造函数相似赋值运算符也对成员进行逐个复制如果成员本身就是类对象则程序将使用为这个类定义的赋值运算符来复制该成员但静态数据成员不受影响赋值的问题与复制的问题的一样的解决赋值的问题函数返回一个指向调用对象的引用即指针代码首先检查自我复制这是通过查看赋值运算符右边的地址是否与接收对象的地址相同来完成的赋值操作并不创建新的对象因此不需要调整静态数据成员的值改进后的新类标准字符串函数库的功能空指针用于表示空指针重载运算符为对象数组输入内容为对象数组输出到屏幕上找到对象数组中最短的对象比较成员函数将比较函数作为友元有助于对象与常规的字符串进行比较将被转换为然后编译器将使用某个构造函数将代码转换为使用中括号表示法访问字符一般是在类这种数组中不是指它包含有四个对象而是第四个字符将赋给指向的引用访问的是私有数据但由于是类的一个方法因此能够修改数组的内容后三者是等同的是常量只能使用常量函数如果只有定义则下面的代码将出错因此提供常量版本静态类成员函数不能通过对象调用静态成员函数甚至不能使用指针它不属于对象属于类调用它的方式可以使用类名和作用域解析运算符调用它可以访问静态成员但不能访问两种的差别进一步重载赋值运算符将常规字符串复制到对象中一般来说必须释放指向的内存在构造函数中使用时应注意的事项如果有多个构造函数则必须以相同的方式使用要么带中括号要么不带中括号因为只有一个析构函数然而将指针初始化为空两种都兼容包含类成员的类的逐成员复制和都使用动态内存分配但不需要为类编写复制构造函数和赋值运算符会将使用成员类定义的复制构造函数和赋值运算符有关返回对象的说明返回指向对象的引用第一个与返回有关返回的是或和都被声明为引用所有才使用返回指向非对象引用的返回类型必须是而不能仅仅是如果使用返回类型将调用类的复制构造函数而类没有公有的复制构造函数返回对象如果被返回的对象是被调用函数中的局部变量则不应按引用方式返回它只能是返回对象使用指向对象的指针使用结构体的方式来使用成员使用初始化对象将调用复制构造函数这里指针指向创建的未被命名对象但复制构造函数会给它创建内容再谈定位运算符内存缓冲区实则指的是数组要这样做的原因在于不能与定位运算符配合使用将用于将自动调用为指向的的对象调用析构函数用于时不会为使用定位运算符创建的对象调用析构函数而是需要显示的调用析构函数一般情况下将自动调用析构函数这是需要显示调用析构函数的少数几种情况之一对地址输出的不同输出地址的方式不同定位运算符创建的对象的删除顺序与创建的顺序相反原因在于晚创建的对象可能依赖于早创建的对象另外当所有对象都被消除后才能释放缓冲区第章类继承面向对象编程的主要目的之一是提供可重用的代码通过继承完成的一些工作可以在已有的基础上添加功能例如对于数组类可以添加数学运算可以给类添加数据例如对于字符串类可以添加显示颜色的数据成员可以修改类方法的行为例如提供给飞机乘客的服务的类可以提供更高级别服务的类初始化列表语法可以减少一个步骤它直接使用的复制构造函数将初始化为一个简单的基类构造函数必须给新成员和继承的成员提供数据第二个构造函数使用一个类为参数包含继承类的构造函数的写法构造函数访问权限的考虑派生类不能直接访问基类的私有成员而必须通过基类方法进行访问列如构造函数不能直接设置继承的成员派生类构造函数必须使用基类构造函数创建派生类对象时程序首先创建基类对象使用成员初始化列表来完成调用了的构造函数省略了成员初始化列表程序将调用默认的基类构造函数等效有第二个构造函数的代码上述方法声明是在类外声明的与在类内声明的形式有很大的不一样释放对象的顺序与创建对象的顺序相反先执行派生类的析构函数派生类和基类之间的特殊关系基类指针或引用可以指向和引用派生类对象基类指针或引用只能用于调用基类方法不能使用基类指针或引用来调用派生类的方法对于形参为指向基类的指针或引用的函数也可以使用派生类作为实参按值传递将派生类对象的基类部分传递给函数引用兼容性属性让你能够将基类对象初始化为派生类对象要初始化基类要调用构造函数的原型基类定义中没有这样的构造函数但存在隐式复制构造函数同样也可以将派生类对象赋给基类对象将使用隐式重载赋值运算符继承关系公有继承是最常用的方式它建立一种关系新类将继承原始类的所有数据成员公有继承不建立关系关系午餐有水果将水果的对象作为午餐类的数据成员公有继承不建立关系即律师就像鲨鱼不应从鲨鱼类派生出律师类继承可以在基类的基础上添加基础但不能删除基类的属性公有继承不建立关系即作为来实现使用数组来实现栈不可以因为栈不是数组所以坚持使用的关系当满足的关系就可以使用公有继承多态公有继承概念同一个方法在派生类和基类中的行为是不同的即称为多态具有多种形态两种实现方法在派生类中重新定义基类的方法使用虚方法开发类和类虚方法的定义会在派生类中重新定义基类的方法但函数名一样的关键字只用于类声明的方法原型中引用类型或指针类型选择方法在继承类中的使用方法没有使用将根据引用类型或指针类型选择方法本应该这样定义的引用变量的类型为所以都为方法使用将根据引用类型或指针类型选择方法本应该这样定义的第二个是可以在派生类方法中调用基类的方法如果该方法是虚方法是使用作用域解析运算符来调用基类方法而不是派生类对象来调用方法如果不是虚方法则不必使用作用域解析运算符使用格式化方法和将浮点值的输出模式设置为定点创建指向的指针数组可以使用一个数组来表示多种类型的对象这也是多态指针既可以指向对象也可以指向对象与一般的数组定义是完全不一样的是的指针数组所以可以进行分配内存类对象的输入与一般的数据输入是不一样的多态是由下述代码提供的指的是指针不是值为何需要虚构函数静态联编和动态联编在编译过程就知道使用哪一个函数是静态联编因为虚函数的存在编译器不知道用户将选择哪种类型的对象只能在程序运行的时候确定正确的虚函数方法叫动态联编总之编译器对虚方法使用动态联编根据对象类型将关联到或指针和引用类型的兼容性不允许将一种类型地址或引用赋给另一种类型的指针或引用但基类和派生类可以而不必进行类型转换虚函数的工作原理给每个对象添加一个隐藏成员隐藏成员是一个指向函数地址数组的指针被称为虚函数表虚析构函数析构函数应当是虚函数即使它不执行任何操作除非类不用做基类析构函数不应进行操作如果没有虚析构函数语句将调用析构函数将释放派生类对象中的基类部分指向的内存但不会释放新的类成员指向的内存如果有虚析构函数则先调用析构函数在调用析构函数虚函数的参数要相同但返回值可以不同重新定义将隐藏方法两个都将被隐藏重新定义继承的方法并不是重载将隐藏所有的同名基类的方法访问控制与相似在类外只能用公有类成员来访问部分中的类成员区别在于继承方面派生类的成员可以直接访问基类的保护成员但不能直接访问基类的私有成员在派生类中与公有成员相识例如可以编写只有在派生类中可以这样使用保护数据成员可以简化代码的编写工作但又使保护数据成员成为公有变量被轻易修改抽象基类前面已经接受了简单继承和多态继承另一种建立继承的方法类和类有共点可以建立拥有他们共同点的类这个类还包含类和类不的同的方法应被声明为虚函数但至少应有一个纯虚函数抽象函数通过使用纯虚函数来提供未实现的函数当类声明中包含纯虚函数时则不能创建该类的对象只能用做基类因此可以从类派生出类和类类和类被称为具体类具有相同的基类可以用指针数组同时管理这两种对象类的纯虚函数也应该定于应用概念是一种必须实施的接口这种模式在基于组件的编程模式中很常见每个或者派生类是组件继承和动态内存分配第一种情况派生类不使用基类使用动态内存分配包含特殊方法析构函数复制构造函数重载赋值运算符而派生类不需要第二种情况派生类使用必须为派生类定义特殊方法派生类的析构函数派生类的复制构造函数是基类的引用可以指向派生类型派生类的重载赋值运算符显示调用基类赋值运算符对指针的返回返回类型也是引用不可用代替不然编译器会从而形成递归调用友元的继承类的友元访问和的方法使用强制类型转换第章中的代码重用可以定义一个通用的栈模板然后创建表示或值栈的类包含对象成员的类对于考试分数可以使用一个定长数组这限制了数组的长度可以使用动态内存分配的指针并提供大量的支持代码也可以使用动态内存分配的类表示该数组还可以在标准库中查找一个表示这种数据的类自己开发这样的类一点问题也没有类简介它支持将数组中所有元素的值相加以及在数组中找出最大和最小的值的操作提供的算术支持比和的多几个使用其构造函数的例子指定长度的空数组初始化列表先有长度再有数值长度放后面这个类的方法返回数组的长度返回字符串的长度类的设计可以从和这两个类派生出类这是多重公有继承一种关系但这里并不合适学生类与这些类不是的关系模板类一般使用自定义的形式也在放在私有部分意味着可以在类的实现中使用它当在类外面不能使用在类中可以直接使用和这两个类的方法初始化被包含的对象时构造函数将使用成员名因为初始化的是成员对象而不是继承的对象在构造函数有一个参数时考虑隐式转换函数没有使用可以写如下将创建一个个元素的对象但着一般是不允许的如果使用了将会发生错误初始化顺序它们被声明的顺序而不是它们在初始化列表中的顺序先初始化成员而不是成员在一个成员的值作为另一个成员的初始化表达式的一部分使初始化的顺序就非常重要是一个对象所以调用函数可以使用类的方法同样该函数也可以实现的输出但没有重载运算符因此类定义了一个私有辅助方法引用返回的更快在包含函数的文件中一般还自定义函数私有继承另一种实现关系的途径私有继承基类的公有成员和保护成员都将成为派生类的私有成员可以在派生类的成员函数中使用它们即只能在派生类的方法中使用基类的方法是使用接口与包含的特性一致也是将另外两个类的对象做为的成员是使用实现访问限定符的默认类型是私有类应从两个类派生而来使用多个基类的继承被称为多重继承包含与私有继承的区别包含提供了两个对象成员而私有继承提供了两个无名的子对象成员初始化基类组件有隐式地继承组件和显式地包含组件私有继承类的构造函数将使用类名来初始化访问基类的方法在没有确定对象时可以使用类名和作用域解析运算符来调用基类的方法但函数的作用域与方法的作用域不一致时就使用解析运算符访问基类对象使用强制类型转换将对象转换为对象表示对象为避免调用构造函数创建新的对象可使用强制类型转换来创建一个引用访问基类的友元函数用类名显式地限定函数名不合适于友元函数可以使用显示地转换为基类来调用正确的函数不修改的强制类型转换调用时并不是输出类的全部成员而只是要进入函数里面去看过程使用修改后的类两个版本的类的公有接口方法完全相同因此可以使用同一个程序测试它们使用包含比私有继承好如果某个类需要个对象可以使用包含声明个独立的成员如果新类需要访问原有类的保护成员或需要重新定义虚函数则应使用私有继承保护继承第三代类体现出保护继承和私有继承的区别使用重新定义访问权限在派生类类外调用基类对象的方法使用一个声明来指出派生类可以使用特定的基类成员即使采用的是私有派生可以这样使用声明只使用成员名没有圆括号函数特征标和返回类型多重继承类模板不如编写一个泛型栈然后将具体的类型作为参数传递给这个类这样就可以使用不同类型的栈例如栈和栈定义模板类为函数名尖括号中的内容相当于函数的参数列表看作是变量的类型名看作变量的名称可以使用模板成员函数替换原有类的类方法每个函数头都将以相同模板声明打头应改为作用域解析符与类名也要改如果在类声明中定义了方法内联定义则可以省略模板前缀和类限定符不能将模板成员函数放在独立的实现文件中由于模板不是函数它们不能单独编译使用类模板使用的算法必须与类型一致一般与是可以用在同一个模板类中的栈与指针栈有相同的功能但不能用在同一个模板类中指针栈指针模板使用一个指针数组其中每个指针都指向不同的字符串用使用动态数组返回类型为类时也要使用这是缩写只能在类中使用数组模板示例和非类型参数模板常用作容器类主要是为容器类提供可重用代码数组模板的成员是数组为类型参数为非类型或表达式参数编译器将使用替换使用替换表达式参数可以是整型枚举引用或指针因此是不合法的但是合法的模板代码不能修改参数的值也不能使用参数的地址如和用作参数的值必须是常量表达式介绍一个允许指定数组大小的简单数组模板第一种使用动态数组和构造函数参数来提供元素数目第二种使用模板参数来提供常规数组的大小就是这样做的表达式参数方法的缺点每种数组大小都将生成自己的模板将生成两个独立的类声明使用动态数组和构造函数参数的方法的优点更通用数组大小是作为类成员存储在定义中的可以将一种大小的数组赋给另一种大小的数组模板的多功能性模板类可用作基类也可用作组件类还可用作其他模板的类型参数递归使用模板对于前面的数组模板定义这使得是一个包含个元素的数组其中每个元素都是一个包含个元素的数组与之等价的常规数组声明即使没有这样的函数也可以这样使用控制输出宽度的方法使用多个类型参数模板类的类名是而不是默认类型模板参数为型为型模板的具体化隐式实例化显式实例化之后将生成一个类显式具体化假设模板使用运算符来对值进行比较对于数字这管用如果是将不管用这将要求类定义使用而不是来对值进行比较这种情况下可以提供一个显式模板具体化即为一种具体类型定义的模板而不是泛型定义的模板部分具体化第二个声明使用通用模板时将转换为类型如果是部分具体化将转换为模板该考虑的类型常规类型成员模板模板可用作结构类或模板类的成员在模板外定义类和方法模板是嵌套的还必须指出和是类的成员而不能使用将模板用作参数是可以将类进行更改模板类和友元模板别名第章友元异常和其他友元友元类的所有方法都可以访问原始类的私有成员和保护成员友元类编写一个模拟电视机和遥控器的简单程序遥控器可以改变电视机的状态而不是的关系因此将类作为类的一个友元必须先定义放在公有位置满足的是一种先有电视再有遥控器的关系友元成员函数让特定是类成员成为另一个类的友元而不必让整个类成为友元让成为类的友元的方法是在类声明中将其声明为友元使用的是类的成员所以必须是友元必须使用前向声明声明中只包含方法声明并将实际的定义放在类之后其他友元关系共同的友元嵌套类对类进行嵌套与包含并不同包含意味着将类对象作为另一个类成员而对类进行嵌套不创建类成员而是定义了一种类型程序的其他部分在方法文件中定义构造函数则定义必须指出类是在类中定义的嵌套类和访问权限类的默认访问权限是私有的队列类是嵌套类嵌套类是在另一个类的私有部分声明的只有类成员可以使用对象和指向嵌套类对象的指针派生类和外部世界不知道它的存在如果是保护部分声明的派生类可见并且可以创建这种类型的对象但对于外部是不可见的如果是公有部分声明的允许派生类和外部世界使用它嵌套结构和枚举的作用也是相同的有一个失业的教练他不属于任何球队可以在类的外面创建对象是这种关系的类型类对象只能显示地访问节点类对象的公有成员因为类的所有成员都被声明为公有的模板中的嵌套类定义转换为模板是一种容器类可以连续输入次被定义成用于存储的值异常是运行阶段类型识别的简称旨在为程序在运行阶段确定对象的类型提供一种标准方式的用途有一个类层次结构其中的类都是从同一个基类派生而来的则可以让基类指针指向其中任何一个类的对象的工作原理只适用于包含虚函数的类是用于基类指针与派生类的转换运算符使一个基类指针指向一个派生类的指针如果失败将空指针赋给指针使得进行向上转换的关系这样可以在的基础上使用成员类并没有这个函数有这个函数运算符和类类型转换运算符在语言中都是允许的可以将结构里的成员类型发生转换转换为字符串将地址转换为字符将结构里的成员类型发生转换转换为整型运算符将改变值为或类型的其他方面不能被修改运算符是进行向下转换的运算符将进行重新解释将一种类型转换为另一种类型第章类和标准模板库编程是一种泛型编程标准模板库是用于处理各种容器对象的模板类头文件和支持对风格字符串进行操纵不支持类构造字符串类的构造函数初始化为运算符被多次重载可以使用风格字符串或值从中取出从第个到第个字符取前字母取到取到不可不是指针地址新增的构造函数移动构造函数列表初始化类输入风格字符串的输入对象可以自动调整对象的大小可以这两种使用两个版本都有一个可选参数用于指定使用哪个字符来确定输入的边界对象输入的限制对象的最大允许长度由常量指定通常最大值为如果你将整个文件的内容读取到单个对象中这是一个限制使用字符串成员来自类而是为提供的可以计算数组的大小成员函数方法从开始查找字符找到返回索引从开始查找字符串从开始查找字符串删除字符串的内容返回当前分配给字符串的内存块的大小能够请求内存块的最小长度分配个字符的内存智能指针模板类智能指针定义了类似于指针的类对象可以帮助管理动态内存分配的智能指针模板将获得的地址赋给这种对象是一个常规指针不是一个类对象使用智能指针必须包含头文件模板是返回的指针可以使用的成员函数每一个智能指针都放在代码块中当离开作用域时指针自动释放放弃对象的所有权变成空指针放弃对象所有权共享对象所有权放弃的所有权放弃的所有权变为空指针是不被允许的这样做会直接编译出错和指向同一个对象和共享对象的所有权使用分配内存时才能使用和使用时使用优于函数返回的临时会被销毁编译出错不能被赋值正确不会编译出错选择智能指针选择的情况有一个指针数组并使用一些辅助指针来标识特定的元素两个对象包含都指向第三个对象的指针容器包含指针算法都支持赋值和复制操作可用于只要不调用将一个复制和赋值给另一个的方法或算法但不能用于调用没有问题因为它返回一个临时被赋给中的一个为右值时可将其赋给包含一个显示构造函数可将右值转换为标准模板库迭代器能够用来遍历容器的对象与能够遍历数组的指针类似是广义指针容器数组队列链表是选择一种能存储多种数据类型的数据类型成为容器操作搜索排列和随机排列适用于所有容器类的非成员函数省去了大量重复的工作不是面向对象编程而是一种不同的编程模式泛型编程数学矢量与计算矢量不一样能够分配容器的对象大小的容器都使用了动态内存分配模板类分配器管理内存分配和释放的类各种容器模板都接受一个可选的模板参数该参数指定使用哪个分配器对象来管理内存这个类使用和来分配和释放内存为分配器可执行的操作所有的容器都提供了一些基本方法交换对象的内容返回一个指向容器中第一个元素超过容器尾的迭代器迭代器解除引用和递增返回指向当前元素的指针递增迭代器每个容器类都定义了一个合适的迭代器该迭代器是一个名为的模板类作用域为整个类自动类型推断声明了一个迭代器一般带有指针的名字都会有指针的性质只不过在取地址这里有点不一样迭代器遍历容器内容类的才有的在矢量末尾添加元素它将负责内存管理增加矢量的长度方法删除矢量中给定区间的元素提供了随机访问功能因此可以有操作方法将元素插入到矢量中的指定位置该区间是另一个容器对象的一部分交换两个对象的内容个容器类需要支持中操作都有自己的成员函数则要定义个成员函数但采用方式时只需要个非成员函数即可即使有执行相同任务的非成员函数有时也会定义一个成员函数因为类特定算法的效率比通用算法高成员函数效率比非成员函数高但非成员函数让你能够交换两个不同容器的内容函数和必须包含替换为最后一个参数是指向函数的指针函数对象该函数不可以修改容器元素的值随机排列该区间中的元素要求容器类允许随机访问注意是使用的是布尔类型的返回值现在函数总是用布尔类型的返回值和循环是否结束第一个版本使用为存储在容器中的类型元素定义的运算符如果容器元素类型是用户定义的则要使用必须定义能够该类型对象的函数为提供了成员或非成员函数第二种版本的基于范围的循环基于范围的循环是为用于而设计的循环将依次将中的每个对象传递给不同于基于范围的循环可以修改容器中的元素但要指定一个引用参数两个地方必须要有引用泛型编程是一种泛型编程面向对象编程关注的是编程的数据方面使任何数据类型能存在容器中而泛型编程关注的是算法使任何容器能运用于算法共同特定是抽象和创建可重用代码模板使得算法独立于存储的数据类型而迭代器使算法独立于使用的容器类型定义一种链表类型的迭代器类是返回的是类对象与几乎相同区别在于结束的条件不同这就需要不同的容器了函数的实现方法每个容器类定义了相应的迭代器类型可能是指针可能是对象每个容器类都有和方法都使用让迭代器递增新增的自动类型推断最好避免直接使用迭代器而尽量使用和基于范围的循环有了迭代器算法才能通用基于算法的要求设计基本迭代器的特征和容器的特征迭代器类型不同的算法对迭代器的要求也不同排序算法需要能够随机访问可以通过定义运算符来实现迭代器也是一个类含有构造函数如果两个迭代器相同则解除引用操作得到的值将相同输出迭代器只能修改容器值而不能读取程序的输出就是容器的输入输入和输出迭代器都是单通行不能保证第二次遍历容器时顺序不变也不能保证其先前值仍然可以被解除引用正向迭代器可以对前面的迭代器值解除引用可以读取和修改数据也可以只读取数据双向迭代器中函数可以交换第一个元素和最后一个元素将指向第一个元素的指针加指向第一个元素的指针减函数需要随机访问迭代器所以只能用于支持这种迭代器的容器随机访问迭代器实现为一个常规指针正向迭代器实现为一个类一种迭代器的类型是不一样的两种类型的迭代器每个容器类都定义了一个类级名称如果所设计的容器类需要迭代器可考虑它包含用于标准种类的迭代器模板概念改进和模型将指针用作迭代器使得算法用于常规数组将一个数组复制到一个矢量中函数不能自动根据发送值调整目标容器的长度前两个参数必须是输入迭代器最后一个必须是输出迭代器输出流迭代器为这种迭代器提供了模板是输出迭代器的一个模型也是一个适配器类或函数可以将一些其他接口转换为使用的接口使得可以在算法中使用迭代器就是的接口要包含头文件构造函数的第一个参数指出了要使用的输出流第二个参数指出了要使用的分隔符才是迭代器意味着将和有空格组成的字符串发送到输出流中并为下一个输出做准备函数的另一种用法将的内容复制到输出流中即显示容器的内容其他有用的迭代器这样不必声明反向迭代器和返回的值相同但类型不同反向指针先通过递减再解除引用来解决的超尾的问题指向位置则将是位置的值三种插入迭代器只能于允许在尾部快速插入的容器快速插入指的是一个小时固定的算法满足将容器类型作为模板参数将实际的容器标识符作为构造函数参数构造函数将假设传递给它的类型有一个方法满足不满足完成任务很快没有这些限制还需要一个指示插入位置的构造函数参数二维数组也是同样的运用没有迭代器可以用将复制数据的算法转换为插入数据的算法这些预定义迭代器增加了函数的功能比如函数容器的种类具有容器概念和容器类型容器类型是可用于创建具体容器对象的模板有双端队列可以从中端和末端插入和删除元素是可以随机访问的链表是一个双向链表可以随时在任何位置插入或删除元素队列是一种先进先出的数据结构只能在末端添加元素在前端删除元素优先队列是一种特殊的队列每个元素都有一个优先级优先级最高的元素最先出队栈是一种后进先出的数据结构只能在顶端添加或删除元素向量是动态数组可以动态地增加和减少元素在尾部添加和删除元素的时间是固定的但在头部或中间插入和删除元素为线性时间还是一种反转容器映射是一种关联数组它存储的是键值对多重映射类似于映射但允许存在多个相同的键集合是一种不包含重复元素的无序集合多重集合类似于集合但允许存在重复的元素位集是一种特殊的数组它存储的是位或新增的容器类基于哈希表的关联容器用于存储键值对查找插入和删除操作的平均时间复杂度为基于哈希表的集合容器用于存储唯一的键查找插入和删除操作的平均时间复杂度为单向链表容器只支持正序遍历插入和删除操作在链表头部和尾部速度很快一些基本的容器特征线性时间固定时间固定时间复杂度从快到慢编译时间在编译时执行指向时间为固定时间在运行时执行指向时间为独立于对象中的元素数目线性时间时间与元素数目成正比指向时间为序列是基本的容器概念的改进包括要求是正向迭代器保证了元素将按特定顺序排序即除了第一和最后每个元素前后都分别有一个元素为定义了而没有为定义是因为在矢量前插入一个元素需要移动大量的元素而和的允许将元素添加到前端而不移动其他元素以固定时间来完成所以没有必要定义和都对元素进行随机访问和在中部执行线性时间的插入和删除但容器执行的更快因为的内存是连续的而的内存不是连续的所以的访问速度更快更复杂双向链表可以双向遍历链表可以从后面往前面遍历也是反转容器成员函数将两个链表合并两个链表必须是已经排序合并后为空为线性时间删除所有值为的元素线性时间将连续的相同即相邻的相同值的元素压缩为单个元素可以结合来使用线性时间使用运算给发将元素排序线性时间为将中的元素插入到之前将为空为固定时间非成员函数需要随机访问迭代器不能用于链表所以只能使用类中的成员函数版本工具箱方法组成了一个方便的工具箱例如有两个邮件列表要整理则可以对每个列表进行排序合并它们然后使用来删除重复的元素新增的实现单链表无反向迭代器因为每个节点都只链接到下一个节点而没有链接到前一个节点模板类是一个适配器类让底层类展示典型的队列接口既不允许随机访问也不允许遍历队列只允许队列的基本操作使用这个值与栈一样在队列的末尾添加一个元素从队列的开头移除一个元素并返回该元素返回队列的第一个元素但不移除该元素返回队列的最后一个元素但不移除该元素检查队列是否为空如果为空则返回否则返回返回队列中的元素个数是另一个适配器类与操作相同主要是最大的元素被移到队首底层类是可以修改用于确定哪个元素放到队首的比较方式这用到了构造函数模板类与相同也是适配器类底层类是给底层类提供了典型的栈接口既不允许随机访问也不允许遍历栈只允许栈的基本操作将压入推到栈顶从栈顶弹出元素查看栈顶的值检查元素数目和测试栈是否为空判断栈是否为空如果为空则返回否则返回返回栈的元素个数返回栈顶元素并弹出该元素将元素压入栈中弹出栈顶元素如果要使用栈值必须首先使用来检索这个值然后使用将它从栈中删除模板类并非容器因为其长度是固定的没有定义调整容器大小的操作如和可将标准算法用于对象如和关联容器关联容器将值与键冠梁在一起并使用键来查找值优点在于它提供了对元素的快速访问允许插入元素新元素但不能指定元素的插入位置原因是关联容器通常有用于确定数据放置位置的算法而不是使用迭代器以便能够快速找到元素关联容器通常是使用某种树实现的种关联容器前两种是在头文件中定义后两种是在中定义的其值类型与键相同键是唯一的不会有多个相同的键可能有多个值的键相同中值与键的类型不同键是唯一的每个键只对应一个值可能有一个键可以与多个值关联模板类可反转可排序且键是唯一的所以不能存储多个相同的值第二个模板参数可用于指示用来对键进行的比较函数对象有一个将迭代器区间作为参数的构造函数键是唯一的所以在数组两次出现但在集合中只出现一次且集合被排序数学为集合定义了一些标准操作如并集交集这些操作的算法是通用函数不是类方法显示集合和的并集并进行了排序的模板参数指定键的类型和存储的值的类型为将信息结合在一起实际的值的类型将键类型与数据类型结合为一对使用模板类将两种值存储到一个对象中对象的值类型为用区号作为键来存储城市名这恰好与值类型一致因为数据项是按键排序的所以不需要指出插入位置无序关联容器无序关联容器也将值与键关联起来并使用键来查找值是基于哈希表旨在提高添加和删除元素的速度以及查找算法的效率函数对象很多算法使用了函数对象包括函数名指向函数的指针和重载了运算符的类对象即定义了函数的类函数符概念生成器是不用参数就可以调用的函数符一元函数是用一个参数就可以调用的函数符例如是一元函数因为它每次用于一个容器元素返回值的一元函数是谓词删除链表中所有大于的元素可以将两个参数的模板函数转换为单个参数的函数对象直接使用类对象的值来自链表中设计一个类来控制大于多少的元素将被删除函数对象是一种适配器使函数或类成员函数能够满足不同的接口接口就是函数或类成员函数预定义的函数符定义了多个基本函数符它们执行诸如将两个值相加比较两个值是否相等操作有两个版本计算每个元素的平方根计算所有元素和的第一个元素的平均值可有可无函数对象不会带参数的头文件定义了多个模板类函数对象其中包括类对于所有内置的算术运算符关系运算符和逻辑运算符都提供了函数对象例如和是两个函数对象自适应函数符和函数适配器表列出的预定义函数符都是自适应的函数符自适应性的意义在于函数适配器对象可以使用函数对象使函数能匹配不同的接口函数适配器将接受两个参数的函数符转换为接受个参数的函数符前面的示例提供了一种方法但使用和类自动完成这个过程是一个自适应二元函数对象将与的第一个参数相关联函数与类的作用相同只是将常数赋给第二个参数将二元函数转换为将参数乘以的一元函数算法的非成员函数有些函数接受一个函数对象统一的容器设计使得不同类型的容器之间具有明显的关系例如可以使用将对象中的值复制到对象中用来比较不同类型的容器如和之所以能这样做是容器都使用迭代器来提供访问容器中的数据算法组通用数字运算的算法在头文件中定义最有可能使用这些操作的容器算法的通用特征的结果被存放在原始数据的位置上将结果发送到另一个位置可以以这两种方式完成工作的原型这包含了两种迭代器有些算法有两个版本就地版本和复制版本复制版本的名称将以结尾将接受一个多的输出迭代器参数第章泛型编程注意的事项函数的返回值为或添加在后面判断是否输入了在连续输入时要考虑的存在对象初始化两个不同表示数组大小的方式中的类对象和通常函数都要处理空间名称").trim().substring(0, num)

      const queryParams = `key=${options.key}&content=${truncateDescription}`;
      const requestOptions = {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Referer: options.Referer
        },
      };
      try {
        let animationInterval = null
        if (animationInterval) clearInterval(animationInterval);
        animationInterval = setInterval(() => {
          const animationText = "生成中" + ".".repeat(j);
          explanation.innerHTML = animationText;
          j = (j % 3) + 1; // 在 1、2、3 之间循环
        }, 500);
        const response = await fetch(`https://summary.tianli0.top/?${queryParams}`, requestOptions);
        const result = await response.json();
        const summary = result.summary.trim();
        setTimeout(() => {
          aiTitleRefreshIcon.style.opacity = "1";
        }, 300)
        startAI(summary);
        clearInterval(animationInterval)

      } catch (error) {
        console.error(error);
        explanation.innerHTML = "发生异常" + error;
      }
    } else {
      const strArr = "true".split(",").map(item => item.trim()); // 将字符串转换为数组，去除每个字符串前后的空格
      if (strArr.length !== 1) {
        let randomIndex = Math.floor(Math.random() * strArr.length); // 随机生成一个索引
        while (randomIndex === lastAiRandomIndex) { // 如果随机到了上次的索引
          randomIndex = Math.floor(Math.random() * strArr.length); // 再次随机
        }
        lastAiRandomIndex = randomIndex; // 更新上次随机到的索引
        startAI(strArr[randomIndex]);
      } else {
        startAI(strArr[0])
      }
      setTimeout(() => {
        aiTitleRefreshIcon.style.opacity = "1";
      }, 600)
    }
  }

  function aiRecommend() {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    explanation.innerHTML = "生成中. . .";
    ai_str = "";
    ai_str_length = "";
    observer.disconnect(); // 暂停上一次监听
    sto[2] = setTimeout(() => {
      explanation.innerHTML = recommendList();
    }, 600);
  }
  function aiGoHome() {
    startAI("正在前往博客主页...", false);
    sto[2] = setTimeout(() => {
      pjax.loadUrl("/");
    }, 1000);
  }
  const ai_btn_item = document.querySelectorAll(".ai-btn-item");
  function Introduce() {
    if (mode == "tianli") {
      startAI("我是文章辅助AI: TianliGPT，点击下方的按钮，让我生成本文简介、推荐相关文章等。")
    } else {
      startAI("我是文章辅助AI: AnZhiYu GPT，点击下方的按钮，让我生成本文简介、推荐相关文章等。")
    }
  }
  function aiTitleRefreshIconClick() {
    aiTitleRefreshIcon.click()
  }
  const aiFunctions = [Introduce, aiTitleRefreshIconClick, aiRecommend, aiGoHome];
  ai_btn_item.forEach((item, index) => {
    item.addEventListener("click", () => {
      aiFunctions[index]();
    });
  });

  function recommendList() {
    let thumbnail = document.querySelectorAll('.relatedPosts-list a');
    if (!thumbnail.length) {
      const cardRecentPost = document.querySelector('.card-widget.card-recent-post'); 
      if (!cardRecentPost) return '';

      thumbnail = cardRecentPost.querySelectorAll('.aside-list-item a');

      let list = '';
      for (let i = 0; i < thumbnail.length; i++) {
        const item = thumbnail[i];
        list += `<div class="ai-recommend-item"><span class="index">${i + 1}：</span><a href="javascript:;" onclick="pjax.loadUrl('${item.href}')" title="${item.title}" data-pjax-state="">${item.title}</a></div>`;
      }
      
      return `很抱歉，无法找到类似的文章，你也可以看看本站最新发布的文章：<br /><div class="ai-recommend">${list}</div>`;
    }

    let list = '';
    for (let i = 0; i < thumbnail.length; i++) {
      const item = thumbnail[i];
      list += `<div class="ai-recommend-item"><span>推荐${i + 1}：</span><a href="javascript:;" onclick="pjax.loadUrl('${item.href}')" title="${item.title}" data-pjax-state="">${item.title}</a></div>`;
    }

    return `推荐文章：<br /><div class="ai-recommend">${list}</div>`;
  }


  function changeShowMode() {
    if (mode === "tianli") {
      mode = "local";
      document.getElementById("ai-tag").innerHTML = "AnZhiYu GPT";
      aiAbstract(1000);
    } else {
      mode = "tianli";
      document.getElementById("ai-tag").innerHTML = "Tianli GPT";

      const truncateDescription = ("" + "第2章 开始学习C++, 2.1 进入C++, 2.1.6 使用cout进行C++输出, 第6章 分支语句和逻辑运算符, 6.8 简单文件输入输出, 第11章 使用类, 11.6类的自动转换和强制类型转换, 11.6.1转换函数, 11.6.2转换函数和友元函数, 第12章 类和动态内存分配, 12.1动态内存和类, 12.1.1开发一个动态内存类, 12.1.2 特殊成员函数, 12.1.3 回到Stringbad 复制构造函数的哪里出了问题, 12.1.4 StringBad的其他问题：赋值运算符, 改进后的新Stirng类, 12.2.2比较成员函数, 12.2.3使用中括号表示法访问字符, 12.2.4 静态类成员函数, 12.2.5 进一步重载赋值运算符, 12.3 在构造函数中使用new时应注意的事项, 12.3.1 包含类成员的类的逐成员复制, 12.4 有关返回对象的说明, 12.4.1 返回指向const对象的引用, 12.4.2 返回指向非const对象引用, 12.4.3 返回对象, 12.5 使用指向对象的指针, 12.5.1 再谈定位new运算符, 第13章 类继承, 13.1 一个简单的基类, 13.1.1, 13.1.2 构造函数：访问权限的考虑, 13.1.4 派生类和基类之间的特殊关系, 13.2 继承：is-a关系, 13.3 多态公有继承, 13.3.1 开发Brass类和BrassPlus类, 13.4 静态联编和动态联编, 13.4.1 指针和引用类型的兼容性, 13.5 访问控制：protected, 13.6 抽象基类(ABC), 13.6.1 应用ABC概念, 13.7 继承和动态内存分配, 13.7.1 第一种情况：派生类不使用new, 13.7.2 第二种情况：派生类使用new, 13.7.3 友元的继承, 第14章 c++中的代码重用, 14.1 包含对象成员的类, 14.1.1 valarray类简介, 14.1.2 Student类的设计, 14.2 私有继承, 14.2.1 初始化基类组件, 14.2.2 访问基类的方法, 14.2.3 访问基类对象, 14.2.3 访问基类的友元函数, 14.2.4 使用修改后的Student类, 14.2.5 保护继承, 14.2.6 使用using重新定义访问权限, 14.3 多重继承, 14.4 类模板, 14.4.1 定义模板类, 14.4.2 使用类模板, 14.4.3 指针栈x2F指针模板, 14.4.4 数组模板示例和非类型参数, 14.4.4 模板的多功能性, 14.4.6 模板的具体化, 14.4.7 成员模板, 14.4.8 将模板用作参数, 14.4.8 模板类和友元, 14.4.8 模板别名, 第15章 友元、异常和其他, 15.1 友元, 15.1.1 友元类, 15.1.2 友元成员函数, 15.1.3 其他友元关系, 15.1.4 共同的友元, 15.2 嵌套类, 15.2.1 嵌套类和访问权限, 15.2.2 模板中的嵌套, 15.3异常, 15.4 RTTI, 15.4.1 RTTI的用途, 15.4.2 RTTI的工作原理, 15.5 类型转换运算符, 第16章 string类和标准模板库, 16.1 string类, 16.1.1 构造字符串, 16.1.2 string类输入, 16.1.3  使用字符串, 16.2 智能指针模板类, 16.2.1 使用智能指针, 16.2.3 unique_ptr优于auto_ptr, 16.2.4 选择智能指针, 16.3 标准模板库, 16.3.1 模板类vector, 16.3.2 可执行的操作, 16.3.4 基于范围的for循环, 16.4 泛型编程, 16.4.2 迭代器类型, 16.4.4 概念改进和模型, 16.4.5 容器的种类, 16.4.6 关联容器, 16.4.7 无序关联容器, 16.5 函数对象, 16.5.1 函数符概念, 16.5.2 预定义的函数符, 16.5.3 自适应函数符和函数适配器, 16.6 算法, 16.6.1 算法组, 16.6.2 算法的通用特征, 第17章 泛型编程注意的事项第章开始学习进入使用进行输出第章分支语句和逻辑运算符简单文件输入输出第章使用类类的自动转换和强制类型转换数据类型的转换都是正确的将进行自动类型转换不会进行自动转换是不兼容的类型可进行强制类型转换下面的构造函数用于将类型的值转换为类类型介绍的是转换构造函数只能是接受一个参数的构造函数才能这样可以先创建一个临时的的对象并将作为初始值然后将临时对象的内容复制到中为类的隐式转换是自动进行的是关闭隐式转换但仍然允许显式强制类型转换转换还存在二义性还可以用于将值传递给接受参数的函数如果提供了构造函数并且是成员函数的加法函数则可以这样做但只有友元函数才允许这样做转换函数转换函数的概念是将类类型转换为某种类型是用户定义的强制类型转换转换函数必须是类方法不能指定返回类型不能有参数转换为类型的函数返回一个数注意虽然没有声明返回类型但也将返回所需的值是四舍五入的方式而不是去掉小数部分类类型转换为某种类型也会存在二义性不能用于转换函数但可以使用非转换函数替换只能进行强制转换是非法的可以警告应谨慎地使用隐式转换函数通常使用显式的强制类型转换转换函数和友元函数实现加法时的选择要将量和量相加可以有两种方法第章类和动态内存分配动态内存和类开发一个动态内存类使用动态内存分配来开发类使用指针而不是数组这意味着类声明没有为字符串分配存储空间静态类成员特点无论创建了多少对象所有对象共享同一个静态成员例如成员可以记录所创建的对象数目不能在类声明中初始化静态成员变量只能在文件中初始化类外也不可以初始化但如果静态成员是整数类型或枚举类型见第十章则可以在类声明中初始化创建构造函数不会包括末尾的空字符记录对象的数量字符串并不保存在对象中而是保存在堆内存中对象仅保存了指出到哪里去查找字符串的信息不能这样做这只保存了地址而没有创建字符串副本析构函数的使用对象声明放在一个内部代码块中因为析构函数将在定义对象的代码块执行完毕时调用对象的删除的顺序与创建顺序相反在进行输出类时是运用了重载运算符注意查看重载运算符函数中输出的是什么内容编译器会自动生成成员函数和自动使用你不使用函数构造函数析构函数为复制构造函数会创建对象的一个副本调用了一个函数特殊成员函数特殊成员函数是自动定义的有默认构造函数如果没有定义默认析构函数如果没有定义复制构造函数如果没有定义赋值运算符如果没有定义地址运算符如果没有定义返回调用对象的地址即指针的值新增移动构造函数移动运算符默认构造函数如果定义了构造函数将不会定义默认构造函数如果希望在创建对象时不显示地对它进行初始话则必须显示地定义默认构造函数它还可以来设定特定的值在创建对象时不显示地对它进行初始话带参数的构造函数也可以是默认构造函数只要所有参数都有默认值但只有一个默认构造函数不然会造成二义性复制构造函数它用于初始化过程而不是常规的赋值过程每当程序生成了对象副本时编译器都将使用复制构造函数使用初始化一个匿名对象并将新对象的地址赋给指针当按值传递和返回对象时以及编译器生成临时对象例如将个对象相加时编译器可能生成临时的对象来保存中间结果都将调用复制构造函数复制构造函数初始化函数的形参由于按值传递对象将调用复制构造函数在用类为函数的参数时应该按引用传递对象如果成员本身就是类对象则将使用这个类的复制函数来复制成员对象静态成员不受影响因为它们属于整个类显示复制构造函数如果类中包含这样的静态数据成员即其值将在对象被创建时发生变化则应该提供一个显示复制构造函数来处理计数问题回到复制构造函数的哪里出了问题这里复制的并不是字符串而是一个指向字符串的指针得到两个指向同一个字符串的指针相当于由于私有成员是无法访问的因此这些代码是不能通过编译的指向的内容已经被的析构函数释放定义一个显式复制构造函数以解决问题深度复制该复制构造函数应当复制字符串并将副本的地址赋给成员如果类中包含了使用初始化的指针成员应当定义一个深度复制函数的其他问题赋值运算符赋值运算符的功能以及何时使用它将已有的对象赋给另一个对象时将使用重载的赋值运算符使用函数表示法时与复制构造函数相似赋值运算符也对成员进行逐个复制如果成员本身就是类对象则程序将使用为这个类定义的赋值运算符来复制该成员但静态数据成员不受影响赋值的问题与复制的问题的一样的解决赋值的问题函数返回一个指向调用对象的引用即指针代码首先检查自我复制这是通过查看赋值运算符右边的地址是否与接收对象的地址相同来完成的赋值操作并不创建新的对象因此不需要调整静态数据成员的值改进后的新类标准字符串函数库的功能空指针用于表示空指针重载运算符为对象数组输入内容为对象数组输出到屏幕上找到对象数组中最短的对象比较成员函数将比较函数作为友元有助于对象与常规的字符串进行比较将被转换为然后编译器将使用某个构造函数将代码转换为使用中括号表示法访问字符一般是在类这种数组中不是指它包含有四个对象而是第四个字符将赋给指向的引用访问的是私有数据但由于是类的一个方法因此能够修改数组的内容后三者是等同的是常量只能使用常量函数如果只有定义则下面的代码将出错因此提供常量版本静态类成员函数不能通过对象调用静态成员函数甚至不能使用指针它不属于对象属于类调用它的方式可以使用类名和作用域解析运算符调用它可以访问静态成员但不能访问两种的差别进一步重载赋值运算符将常规字符串复制到对象中一般来说必须释放指向的内存在构造函数中使用时应注意的事项如果有多个构造函数则必须以相同的方式使用要么带中括号要么不带中括号因为只有一个析构函数然而将指针初始化为空两种都兼容包含类成员的类的逐成员复制和都使用动态内存分配但不需要为类编写复制构造函数和赋值运算符会将使用成员类定义的复制构造函数和赋值运算符有关返回对象的说明返回指向对象的引用第一个与返回有关返回的是或和都被声明为引用所有才使用返回指向非对象引用的返回类型必须是而不能仅仅是如果使用返回类型将调用类的复制构造函数而类没有公有的复制构造函数返回对象如果被返回的对象是被调用函数中的局部变量则不应按引用方式返回它只能是返回对象使用指向对象的指针使用结构体的方式来使用成员使用初始化对象将调用复制构造函数这里指针指向创建的未被命名对象但复制构造函数会给它创建内容再谈定位运算符内存缓冲区实则指的是数组要这样做的原因在于不能与定位运算符配合使用将用于将自动调用为指向的的对象调用析构函数用于时不会为使用定位运算符创建的对象调用析构函数而是需要显示的调用析构函数一般情况下将自动调用析构函数这是需要显示调用析构函数的少数几种情况之一对地址输出的不同输出地址的方式不同定位运算符创建的对象的删除顺序与创建的顺序相反原因在于晚创建的对象可能依赖于早创建的对象另外当所有对象都被消除后才能释放缓冲区第章类继承面向对象编程的主要目的之一是提供可重用的代码通过继承完成的一些工作可以在已有的基础上添加功能例如对于数组类可以添加数学运算可以给类添加数据例如对于字符串类可以添加显示颜色的数据成员可以修改类方法的行为例如提供给飞机乘客的服务的类可以提供更高级别服务的类初始化列表语法可以减少一个步骤它直接使用的复制构造函数将初始化为一个简单的基类构造函数必须给新成员和继承的成员提供数据第二个构造函数使用一个类为参数包含继承类的构造函数的写法构造函数访问权限的考虑派生类不能直接访问基类的私有成员而必须通过基类方法进行访问列如构造函数不能直接设置继承的成员派生类构造函数必须使用基类构造函数创建派生类对象时程序首先创建基类对象使用成员初始化列表来完成调用了的构造函数省略了成员初始化列表程序将调用默认的基类构造函数等效有第二个构造函数的代码上述方法声明是在类外声明的与在类内声明的形式有很大的不一样释放对象的顺序与创建对象的顺序相反先执行派生类的析构函数派生类和基类之间的特殊关系基类指针或引用可以指向和引用派生类对象基类指针或引用只能用于调用基类方法不能使用基类指针或引用来调用派生类的方法对于形参为指向基类的指针或引用的函数也可以使用派生类作为实参按值传递将派生类对象的基类部分传递给函数引用兼容性属性让你能够将基类对象初始化为派生类对象要初始化基类要调用构造函数的原型基类定义中没有这样的构造函数但存在隐式复制构造函数同样也可以将派生类对象赋给基类对象将使用隐式重载赋值运算符继承关系公有继承是最常用的方式它建立一种关系新类将继承原始类的所有数据成员公有继承不建立关系关系午餐有水果将水果的对象作为午餐类的数据成员公有继承不建立关系即律师就像鲨鱼不应从鲨鱼类派生出律师类继承可以在基类的基础上添加基础但不能删除基类的属性公有继承不建立关系即作为来实现使用数组来实现栈不可以因为栈不是数组所以坚持使用的关系当满足的关系就可以使用公有继承多态公有继承概念同一个方法在派生类和基类中的行为是不同的即称为多态具有多种形态两种实现方法在派生类中重新定义基类的方法使用虚方法开发类和类虚方法的定义会在派生类中重新定义基类的方法但函数名一样的关键字只用于类声明的方法原型中引用类型或指针类型选择方法在继承类中的使用方法没有使用将根据引用类型或指针类型选择方法本应该这样定义的引用变量的类型为所以都为方法使用将根据引用类型或指针类型选择方法本应该这样定义的第二个是可以在派生类方法中调用基类的方法如果该方法是虚方法是使用作用域解析运算符来调用基类方法而不是派生类对象来调用方法如果不是虚方法则不必使用作用域解析运算符使用格式化方法和将浮点值的输出模式设置为定点创建指向的指针数组可以使用一个数组来表示多种类型的对象这也是多态指针既可以指向对象也可以指向对象与一般的数组定义是完全不一样的是的指针数组所以可以进行分配内存类对象的输入与一般的数据输入是不一样的多态是由下述代码提供的指的是指针不是值为何需要虚构函数静态联编和动态联编在编译过程就知道使用哪一个函数是静态联编因为虚函数的存在编译器不知道用户将选择哪种类型的对象只能在程序运行的时候确定正确的虚函数方法叫动态联编总之编译器对虚方法使用动态联编根据对象类型将关联到或指针和引用类型的兼容性不允许将一种类型地址或引用赋给另一种类型的指针或引用但基类和派生类可以而不必进行类型转换虚函数的工作原理给每个对象添加一个隐藏成员隐藏成员是一个指向函数地址数组的指针被称为虚函数表虚析构函数析构函数应当是虚函数即使它不执行任何操作除非类不用做基类析构函数不应进行操作如果没有虚析构函数语句将调用析构函数将释放派生类对象中的基类部分指向的内存但不会释放新的类成员指向的内存如果有虚析构函数则先调用析构函数在调用析构函数虚函数的参数要相同但返回值可以不同重新定义将隐藏方法两个都将被隐藏重新定义继承的方法并不是重载将隐藏所有的同名基类的方法访问控制与相似在类外只能用公有类成员来访问部分中的类成员区别在于继承方面派生类的成员可以直接访问基类的保护成员但不能直接访问基类的私有成员在派生类中与公有成员相识例如可以编写只有在派生类中可以这样使用保护数据成员可以简化代码的编写工作但又使保护数据成员成为公有变量被轻易修改抽象基类前面已经接受了简单继承和多态继承另一种建立继承的方法类和类有共点可以建立拥有他们共同点的类这个类还包含类和类不的同的方法应被声明为虚函数但至少应有一个纯虚函数抽象函数通过使用纯虚函数来提供未实现的函数当类声明中包含纯虚函数时则不能创建该类的对象只能用做基类因此可以从类派生出类和类类和类被称为具体类具有相同的基类可以用指针数组同时管理这两种对象类的纯虚函数也应该定于应用概念是一种必须实施的接口这种模式在基于组件的编程模式中很常见每个或者派生类是组件继承和动态内存分配第一种情况派生类不使用基类使用动态内存分配包含特殊方法析构函数复制构造函数重载赋值运算符而派生类不需要第二种情况派生类使用必须为派生类定义特殊方法派生类的析构函数派生类的复制构造函数是基类的引用可以指向派生类型派生类的重载赋值运算符显示调用基类赋值运算符对指针的返回返回类型也是引用不可用代替不然编译器会从而形成递归调用友元的继承类的友元访问和的方法使用强制类型转换第章中的代码重用可以定义一个通用的栈模板然后创建表示或值栈的类包含对象成员的类对于考试分数可以使用一个定长数组这限制了数组的长度可以使用动态内存分配的指针并提供大量的支持代码也可以使用动态内存分配的类表示该数组还可以在标准库中查找一个表示这种数据的类自己开发这样的类一点问题也没有类简介它支持将数组中所有元素的值相加以及在数组中找出最大和最小的值的操作提供的算术支持比和的多几个使用其构造函数的例子指定长度的空数组初始化列表先有长度再有数值长度放后面这个类的方法返回数组的长度返回字符串的长度类的设计可以从和这两个类派生出类这是多重公有继承一种关系但这里并不合适学生类与这些类不是的关系模板类一般使用自定义的形式也在放在私有部分意味着可以在类的实现中使用它当在类外面不能使用在类中可以直接使用和这两个类的方法初始化被包含的对象时构造函数将使用成员名因为初始化的是成员对象而不是继承的对象在构造函数有一个参数时考虑隐式转换函数没有使用可以写如下将创建一个个元素的对象但着一般是不允许的如果使用了将会发生错误初始化顺序它们被声明的顺序而不是它们在初始化列表中的顺序先初始化成员而不是成员在一个成员的值作为另一个成员的初始化表达式的一部分使初始化的顺序就非常重要是一个对象所以调用函数可以使用类的方法同样该函数也可以实现的输出但没有重载运算符因此类定义了一个私有辅助方法引用返回的更快在包含函数的文件中一般还自定义函数私有继承另一种实现关系的途径私有继承基类的公有成员和保护成员都将成为派生类的私有成员可以在派生类的成员函数中使用它们即只能在派生类的方法中使用基类的方法是使用接口与包含的特性一致也是将另外两个类的对象做为的成员是使用实现访问限定符的默认类型是私有类应从两个类派生而来使用多个基类的继承被称为多重继承包含与私有继承的区别包含提供了两个对象成员而私有继承提供了两个无名的子对象成员初始化基类组件有隐式地继承组件和显式地包含组件私有继承类的构造函数将使用类名来初始化访问基类的方法在没有确定对象时可以使用类名和作用域解析运算符来调用基类的方法但函数的作用域与方法的作用域不一致时就使用解析运算符访问基类对象使用强制类型转换将对象转换为对象表示对象为避免调用构造函数创建新的对象可使用强制类型转换来创建一个引用访问基类的友元函数用类名显式地限定函数名不合适于友元函数可以使用显示地转换为基类来调用正确的函数不修改的强制类型转换调用时并不是输出类的全部成员而只是要进入函数里面去看过程使用修改后的类两个版本的类的公有接口方法完全相同因此可以使用同一个程序测试它们使用包含比私有继承好如果某个类需要个对象可以使用包含声明个独立的成员如果新类需要访问原有类的保护成员或需要重新定义虚函数则应使用私有继承保护继承第三代类体现出保护继承和私有继承的区别使用重新定义访问权限在派生类类外调用基类对象的方法使用一个声明来指出派生类可以使用特定的基类成员即使采用的是私有派生可以这样使用声明只使用成员名没有圆括号函数特征标和返回类型多重继承类模板不如编写一个泛型栈然后将具体的类型作为参数传递给这个类这样就可以使用不同类型的栈例如栈和栈定义模板类为函数名尖括号中的内容相当于函数的参数列表看作是变量的类型名看作变量的名称可以使用模板成员函数替换原有类的类方法每个函数头都将以相同模板声明打头应改为作用域解析符与类名也要改如果在类声明中定义了方法内联定义则可以省略模板前缀和类限定符不能将模板成员函数放在独立的实现文件中由于模板不是函数它们不能单独编译使用类模板使用的算法必须与类型一致一般与是可以用在同一个模板类中的栈与指针栈有相同的功能但不能用在同一个模板类中指针栈指针模板使用一个指针数组其中每个指针都指向不同的字符串用使用动态数组返回类型为类时也要使用这是缩写只能在类中使用数组模板示例和非类型参数模板常用作容器类主要是为容器类提供可重用代码数组模板的成员是数组为类型参数为非类型或表达式参数编译器将使用替换使用替换表达式参数可以是整型枚举引用或指针因此是不合法的但是合法的模板代码不能修改参数的值也不能使用参数的地址如和用作参数的值必须是常量表达式介绍一个允许指定数组大小的简单数组模板第一种使用动态数组和构造函数参数来提供元素数目第二种使用模板参数来提供常规数组的大小就是这样做的表达式参数方法的缺点每种数组大小都将生成自己的模板将生成两个独立的类声明使用动态数组和构造函数参数的方法的优点更通用数组大小是作为类成员存储在定义中的可以将一种大小的数组赋给另一种大小的数组模板的多功能性模板类可用作基类也可用作组件类还可用作其他模板的类型参数递归使用模板对于前面的数组模板定义这使得是一个包含个元素的数组其中每个元素都是一个包含个元素的数组与之等价的常规数组声明即使没有这样的函数也可以这样使用控制输出宽度的方法使用多个类型参数模板类的类名是而不是默认类型模板参数为型为型模板的具体化隐式实例化显式实例化之后将生成一个类显式具体化假设模板使用运算符来对值进行比较对于数字这管用如果是将不管用这将要求类定义使用而不是来对值进行比较这种情况下可以提供一个显式模板具体化即为一种具体类型定义的模板而不是泛型定义的模板部分具体化第二个声明使用通用模板时将转换为类型如果是部分具体化将转换为模板该考虑的类型常规类型成员模板模板可用作结构类或模板类的成员在模板外定义类和方法模板是嵌套的还必须指出和是类的成员而不能使用将模板用作参数是可以将类进行更改模板类和友元模板别名第章友元异常和其他友元友元类的所有方法都可以访问原始类的私有成员和保护成员友元类编写一个模拟电视机和遥控器的简单程序遥控器可以改变电视机的状态而不是的关系因此将类作为类的一个友元必须先定义放在公有位置满足的是一种先有电视再有遥控器的关系友元成员函数让特定是类成员成为另一个类的友元而不必让整个类成为友元让成为类的友元的方法是在类声明中将其声明为友元使用的是类的成员所以必须是友元必须使用前向声明声明中只包含方法声明并将实际的定义放在类之后其他友元关系共同的友元嵌套类对类进行嵌套与包含并不同包含意味着将类对象作为另一个类成员而对类进行嵌套不创建类成员而是定义了一种类型程序的其他部分在方法文件中定义构造函数则定义必须指出类是在类中定义的嵌套类和访问权限类的默认访问权限是私有的队列类是嵌套类嵌套类是在另一个类的私有部分声明的只有类成员可以使用对象和指向嵌套类对象的指针派生类和外部世界不知道它的存在如果是保护部分声明的派生类可见并且可以创建这种类型的对象但对于外部是不可见的如果是公有部分声明的允许派生类和外部世界使用它嵌套结构和枚举的作用也是相同的有一个失业的教练他不属于任何球队可以在类的外面创建对象是这种关系的类型类对象只能显示地访问节点类对象的公有成员因为类的所有成员都被声明为公有的模板中的嵌套类定义转换为模板是一种容器类可以连续输入次被定义成用于存储的值异常是运行阶段类型识别的简称旨在为程序在运行阶段确定对象的类型提供一种标准方式的用途有一个类层次结构其中的类都是从同一个基类派生而来的则可以让基类指针指向其中任何一个类的对象的工作原理只适用于包含虚函数的类是用于基类指针与派生类的转换运算符使一个基类指针指向一个派生类的指针如果失败将空指针赋给指针使得进行向上转换的关系这样可以在的基础上使用成员类并没有这个函数有这个函数运算符和类类型转换运算符在语言中都是允许的可以将结构里的成员类型发生转换转换为字符串将地址转换为字符将结构里的成员类型发生转换转换为整型运算符将改变值为或类型的其他方面不能被修改运算符是进行向下转换的运算符将进行重新解释将一种类型转换为另一种类型第章类和标准模板库编程是一种泛型编程标准模板库是用于处理各种容器对象的模板类头文件和支持对风格字符串进行操纵不支持类构造字符串类的构造函数初始化为运算符被多次重载可以使用风格字符串或值从中取出从第个到第个字符取前字母取到取到不可不是指针地址新增的构造函数移动构造函数列表初始化类输入风格字符串的输入对象可以自动调整对象的大小可以这两种使用两个版本都有一个可选参数用于指定使用哪个字符来确定输入的边界对象输入的限制对象的最大允许长度由常量指定通常最大值为如果你将整个文件的内容读取到单个对象中这是一个限制使用字符串成员来自类而是为提供的可以计算数组的大小成员函数方法从开始查找字符找到返回索引从开始查找字符串从开始查找字符串删除字符串的内容返回当前分配给字符串的内存块的大小能够请求内存块的最小长度分配个字符的内存智能指针模板类智能指针定义了类似于指针的类对象可以帮助管理动态内存分配的智能指针模板将获得的地址赋给这种对象是一个常规指针不是一个类对象使用智能指针必须包含头文件模板是返回的指针可以使用的成员函数每一个智能指针都放在代码块中当离开作用域时指针自动释放放弃对象的所有权变成空指针放弃对象所有权共享对象所有权放弃的所有权放弃的所有权变为空指针是不被允许的这样做会直接编译出错和指向同一个对象和共享对象的所有权使用分配内存时才能使用和使用时使用优于函数返回的临时会被销毁编译出错不能被赋值正确不会编译出错选择智能指针选择的情况有一个指针数组并使用一些辅助指针来标识特定的元素两个对象包含都指向第三个对象的指针容器包含指针算法都支持赋值和复制操作可用于只要不调用将一个复制和赋值给另一个的方法或算法但不能用于调用没有问题因为它返回一个临时被赋给中的一个为右值时可将其赋给包含一个显示构造函数可将右值转换为标准模板库迭代器能够用来遍历容器的对象与能够遍历数组的指针类似是广义指针容器数组队列链表是选择一种能存储多种数据类型的数据类型成为容器操作搜索排列和随机排列适用于所有容器类的非成员函数省去了大量重复的工作不是面向对象编程而是一种不同的编程模式泛型编程数学矢量与计算矢量不一样能够分配容器的对象大小的容器都使用了动态内存分配模板类分配器管理内存分配和释放的类各种容器模板都接受一个可选的模板参数该参数指定使用哪个分配器对象来管理内存这个类使用和来分配和释放内存为分配器可执行的操作所有的容器都提供了一些基本方法交换对象的内容返回一个指向容器中第一个元素超过容器尾的迭代器迭代器解除引用和递增返回指向当前元素的指针递增迭代器每个容器类都定义了一个合适的迭代器该迭代器是一个名为的模板类作用域为整个类自动类型推断声明了一个迭代器一般带有指针的名字都会有指针的性质只不过在取地址这里有点不一样迭代器遍历容器内容类的才有的在矢量末尾添加元素它将负责内存管理增加矢量的长度方法删除矢量中给定区间的元素提供了随机访问功能因此可以有操作方法将元素插入到矢量中的指定位置该区间是另一个容器对象的一部分交换两个对象的内容个容器类需要支持中操作都有自己的成员函数则要定义个成员函数但采用方式时只需要个非成员函数即可即使有执行相同任务的非成员函数有时也会定义一个成员函数因为类特定算法的效率比通用算法高成员函数效率比非成员函数高但非成员函数让你能够交换两个不同容器的内容函数和必须包含替换为最后一个参数是指向函数的指针函数对象该函数不可以修改容器元素的值随机排列该区间中的元素要求容器类允许随机访问注意是使用的是布尔类型的返回值现在函数总是用布尔类型的返回值和循环是否结束第一个版本使用为存储在容器中的类型元素定义的运算符如果容器元素类型是用户定义的则要使用必须定义能够该类型对象的函数为提供了成员或非成员函数第二种版本的基于范围的循环基于范围的循环是为用于而设计的循环将依次将中的每个对象传递给不同于基于范围的循环可以修改容器中的元素但要指定一个引用参数两个地方必须要有引用泛型编程是一种泛型编程面向对象编程关注的是编程的数据方面使任何数据类型能存在容器中而泛型编程关注的是算法使任何容器能运用于算法共同特定是抽象和创建可重用代码模板使得算法独立于存储的数据类型而迭代器使算法独立于使用的容器类型定义一种链表类型的迭代器类是返回的是类对象与几乎相同区别在于结束的条件不同这就需要不同的容器了函数的实现方法每个容器类定义了相应的迭代器类型可能是指针可能是对象每个容器类都有和方法都使用让迭代器递增新增的自动类型推断最好避免直接使用迭代器而尽量使用和基于范围的循环有了迭代器算法才能通用基于算法的要求设计基本迭代器的特征和容器的特征迭代器类型不同的算法对迭代器的要求也不同排序算法需要能够随机访问可以通过定义运算符来实现迭代器也是一个类含有构造函数如果两个迭代器相同则解除引用操作得到的值将相同输出迭代器只能修改容器值而不能读取程序的输出就是容器的输入输入和输出迭代器都是单通行不能保证第二次遍历容器时顺序不变也不能保证其先前值仍然可以被解除引用正向迭代器可以对前面的迭代器值解除引用可以读取和修改数据也可以只读取数据双向迭代器中函数可以交换第一个元素和最后一个元素将指向第一个元素的指针加指向第一个元素的指针减函数需要随机访问迭代器所以只能用于支持这种迭代器的容器随机访问迭代器实现为一个常规指针正向迭代器实现为一个类一种迭代器的类型是不一样的两种类型的迭代器每个容器类都定义了一个类级名称如果所设计的容器类需要迭代器可考虑它包含用于标准种类的迭代器模板概念改进和模型将指针用作迭代器使得算法用于常规数组将一个数组复制到一个矢量中函数不能自动根据发送值调整目标容器的长度前两个参数必须是输入迭代器最后一个必须是输出迭代器输出流迭代器为这种迭代器提供了模板是输出迭代器的一个模型也是一个适配器类或函数可以将一些其他接口转换为使用的接口使得可以在算法中使用迭代器就是的接口要包含头文件构造函数的第一个参数指出了要使用的输出流第二个参数指出了要使用的分隔符才是迭代器意味着将和有空格组成的字符串发送到输出流中并为下一个输出做准备函数的另一种用法将的内容复制到输出流中即显示容器的内容其他有用的迭代器这样不必声明反向迭代器和返回的值相同但类型不同反向指针先通过递减再解除引用来解决的超尾的问题指向位置则将是位置的值三种插入迭代器只能于允许在尾部快速插入的容器快速插入指的是一个小时固定的算法满足将容器类型作为模板参数将实际的容器标识符作为构造函数参数构造函数将假设传递给它的类型有一个方法满足不满足完成任务很快没有这些限制还需要一个指示插入位置的构造函数参数二维数组也是同样的运用没有迭代器可以用将复制数据的算法转换为插入数据的算法这些预定义迭代器增加了函数的功能比如函数容器的种类具有容器概念和容器类型容器类型是可用于创建具体容器对象的模板有双端队列可以从中端和末端插入和删除元素是可以随机访问的链表是一个双向链表可以随时在任何位置插入或删除元素队列是一种先进先出的数据结构只能在末端添加元素在前端删除元素优先队列是一种特殊的队列每个元素都有一个优先级优先级最高的元素最先出队栈是一种后进先出的数据结构只能在顶端添加或删除元素向量是动态数组可以动态地增加和减少元素在尾部添加和删除元素的时间是固定的但在头部或中间插入和删除元素为线性时间还是一种反转容器映射是一种关联数组它存储的是键值对多重映射类似于映射但允许存在多个相同的键集合是一种不包含重复元素的无序集合多重集合类似于集合但允许存在重复的元素位集是一种特殊的数组它存储的是位或新增的容器类基于哈希表的关联容器用于存储键值对查找插入和删除操作的平均时间复杂度为基于哈希表的集合容器用于存储唯一的键查找插入和删除操作的平均时间复杂度为单向链表容器只支持正序遍历插入和删除操作在链表头部和尾部速度很快一些基本的容器特征线性时间固定时间固定时间复杂度从快到慢编译时间在编译时执行指向时间为固定时间在运行时执行指向时间为独立于对象中的元素数目线性时间时间与元素数目成正比指向时间为序列是基本的容器概念的改进包括要求是正向迭代器保证了元素将按特定顺序排序即除了第一和最后每个元素前后都分别有一个元素为定义了而没有为定义是因为在矢量前插入一个元素需要移动大量的元素而和的允许将元素添加到前端而不移动其他元素以固定时间来完成所以没有必要定义和都对元素进行随机访问和在中部执行线性时间的插入和删除但容器执行的更快因为的内存是连续的而的内存不是连续的所以的访问速度更快更复杂双向链表可以双向遍历链表可以从后面往前面遍历也是反转容器成员函数将两个链表合并两个链表必须是已经排序合并后为空为线性时间删除所有值为的元素线性时间将连续的相同即相邻的相同值的元素压缩为单个元素可以结合来使用线性时间使用运算给发将元素排序线性时间为将中的元素插入到之前将为空为固定时间非成员函数需要随机访问迭代器不能用于链表所以只能使用类中的成员函数版本工具箱方法组成了一个方便的工具箱例如有两个邮件列表要整理则可以对每个列表进行排序合并它们然后使用来删除重复的元素新增的实现单链表无反向迭代器因为每个节点都只链接到下一个节点而没有链接到前一个节点模板类是一个适配器类让底层类展示典型的队列接口既不允许随机访问也不允许遍历队列只允许队列的基本操作使用这个值与栈一样在队列的末尾添加一个元素从队列的开头移除一个元素并返回该元素返回队列的第一个元素但不移除该元素返回队列的最后一个元素但不移除该元素检查队列是否为空如果为空则返回否则返回返回队列中的元素个数是另一个适配器类与操作相同主要是最大的元素被移到队首底层类是可以修改用于确定哪个元素放到队首的比较方式这用到了构造函数模板类与相同也是适配器类底层类是给底层类提供了典型的栈接口既不允许随机访问也不允许遍历栈只允许栈的基本操作将压入推到栈顶从栈顶弹出元素查看栈顶的值检查元素数目和测试栈是否为空判断栈是否为空如果为空则返回否则返回返回栈的元素个数返回栈顶元素并弹出该元素将元素压入栈中弹出栈顶元素如果要使用栈值必须首先使用来检索这个值然后使用将它从栈中删除模板类并非容器因为其长度是固定的没有定义调整容器大小的操作如和可将标准算法用于对象如和关联容器关联容器将值与键冠梁在一起并使用键来查找值优点在于它提供了对元素的快速访问允许插入元素新元素但不能指定元素的插入位置原因是关联容器通常有用于确定数据放置位置的算法而不是使用迭代器以便能够快速找到元素关联容器通常是使用某种树实现的种关联容器前两种是在头文件中定义后两种是在中定义的其值类型与键相同键是唯一的不会有多个相同的键可能有多个值的键相同中值与键的类型不同键是唯一的每个键只对应一个值可能有一个键可以与多个值关联模板类可反转可排序且键是唯一的所以不能存储多个相同的值第二个模板参数可用于指示用来对键进行的比较函数对象有一个将迭代器区间作为参数的构造函数键是唯一的所以在数组两次出现但在集合中只出现一次且集合被排序数学为集合定义了一些标准操作如并集交集这些操作的算法是通用函数不是类方法显示集合和的并集并进行了排序的模板参数指定键的类型和存储的值的类型为将信息结合在一起实际的值的类型将键类型与数据类型结合为一对使用模板类将两种值存储到一个对象中对象的值类型为用区号作为键来存储城市名这恰好与值类型一致因为数据项是按键排序的所以不需要指出插入位置无序关联容器无序关联容器也将值与键关联起来并使用键来查找值是基于哈希表旨在提高添加和删除元素的速度以及查找算法的效率函数对象很多算法使用了函数对象包括函数名指向函数的指针和重载了运算符的类对象即定义了函数的类函数符概念生成器是不用参数就可以调用的函数符一元函数是用一个参数就可以调用的函数符例如是一元函数因为它每次用于一个容器元素返回值的一元函数是谓词删除链表中所有大于的元素可以将两个参数的模板函数转换为单个参数的函数对象直接使用类对象的值来自链表中设计一个类来控制大于多少的元素将被删除函数对象是一种适配器使函数或类成员函数能够满足不同的接口接口就是函数或类成员函数预定义的函数符定义了多个基本函数符它们执行诸如将两个值相加比较两个值是否相等操作有两个版本计算每个元素的平方根计算所有元素和的第一个元素的平均值可有可无函数对象不会带参数的头文件定义了多个模板类函数对象其中包括类对于所有内置的算术运算符关系运算符和逻辑运算符都提供了函数对象例如和是两个函数对象自适应函数符和函数适配器表列出的预定义函数符都是自适应的函数符自适应性的意义在于函数适配器对象可以使用函数对象使函数能匹配不同的接口函数适配器将接受两个参数的函数符转换为接受个参数的函数符前面的示例提供了一种方法但使用和类自动完成这个过程是一个自适应二元函数对象将与的第一个参数相关联函数与类的作用相同只是将常数赋给第二个参数将二元函数转换为将参数乘以的一元函数算法的非成员函数有些函数接受一个函数对象统一的容器设计使得不同类型的容器之间具有明显的关系例如可以使用将对象中的值复制到对象中用来比较不同类型的容器如和之所以能这样做是容器都使用迭代器来提供访问容器中的数据算法组通用数字运算的算法在头文件中定义最有可能使用这些操作的容器算法的通用特征的结果被存放在原始数据的位置上将结果发送到另一个位置可以以这两种方式完成工作的原型这包含了两种迭代器有些算法有两个版本就地版本和复制版本复制版本的名称将以结尾将接受一个多的输出迭代器参数第章泛型编程注意的事项函数的返回值为或添加在后面判断是否输入了在连续输入时要考虑的存在对象初始化两个不同表示数组大小的方式中的类对象和通常函数都要处理空间名称").trim().substring(0, 1000);
      let value = Math.floor(Math.random() * 3) + 1000;
      while (value === prevParam || truncateDescription.length - value === prevParam) {
        value = Math.floor(Math.random() * 3) + 1000;
      }
      aiTitleRefreshIcon.style.opacity = "0.2";
      aiTitleRefreshIcon.style.transitionDuration = "0.3s";
      aiTitleRefreshIcon.style.transform = "rotate(" + 360 * refreshNum + "deg)";
      if (truncateDescription.length <= 1000) {
        let param = truncateDescription.length - Math.floor(Math.random() * 3);
        while (param === prevParam) {
          param = truncateDescription.length - Math.floor(Math.random() * 3);
        }
        aiAbstract(param);
        prevParam = param;
      } else {
        aiAbstract(value);
        prevParam = value;
      }
      refreshNum++;
    }
  }

  //- 监听tag点击事件
  document.getElementById("ai-tag").addEventListener("click", () => {
    if (mode === "tianli") {
      document.querySelectorAll(".ai-btn-item").forEach(item => item.style.display = "none");
      document.getElementById("go-tianli-blog").style.display = "block";
      startAI("你好，我是Tianli开发的摘要生成助理TianliGPT，是一个基于GPT-4的生成式AI。我在这里只负责摘要的预生成和显示，你无法与我直接沟通，如果你也需要一个这样的AI摘要接口，可以在下方购买。（暂未开放购买，敬请期待）")
    } else {
      document.getElementById("go-tianli-blog").style.display = "none";
      startAI("你好，我是本站摘要生成助理AnZhiYu GPT，是一个基于GPT-4的生成式AI。我在这里只负责摘要的预生成和显示，你无法与我直接沟通。")
    }

  });

  aiTitleRefreshIcon.addEventListener("click", () => {
    const truncateDescription = ("" + "第2章 开始学习C++, 2.1 进入C++, 2.1.6 使用cout进行C++输出, 第6章 分支语句和逻辑运算符, 6.8 简单文件输入输出, 第11章 使用类, 11.6类的自动转换和强制类型转换, 11.6.1转换函数, 11.6.2转换函数和友元函数, 第12章 类和动态内存分配, 12.1动态内存和类, 12.1.1开发一个动态内存类, 12.1.2 特殊成员函数, 12.1.3 回到Stringbad 复制构造函数的哪里出了问题, 12.1.4 StringBad的其他问题：赋值运算符, 改进后的新Stirng类, 12.2.2比较成员函数, 12.2.3使用中括号表示法访问字符, 12.2.4 静态类成员函数, 12.2.5 进一步重载赋值运算符, 12.3 在构造函数中使用new时应注意的事项, 12.3.1 包含类成员的类的逐成员复制, 12.4 有关返回对象的说明, 12.4.1 返回指向const对象的引用, 12.4.2 返回指向非const对象引用, 12.4.3 返回对象, 12.5 使用指向对象的指针, 12.5.1 再谈定位new运算符, 第13章 类继承, 13.1 一个简单的基类, 13.1.1, 13.1.2 构造函数：访问权限的考虑, 13.1.4 派生类和基类之间的特殊关系, 13.2 继承：is-a关系, 13.3 多态公有继承, 13.3.1 开发Brass类和BrassPlus类, 13.4 静态联编和动态联编, 13.4.1 指针和引用类型的兼容性, 13.5 访问控制：protected, 13.6 抽象基类(ABC), 13.6.1 应用ABC概念, 13.7 继承和动态内存分配, 13.7.1 第一种情况：派生类不使用new, 13.7.2 第二种情况：派生类使用new, 13.7.3 友元的继承, 第14章 c++中的代码重用, 14.1 包含对象成员的类, 14.1.1 valarray类简介, 14.1.2 Student类的设计, 14.2 私有继承, 14.2.1 初始化基类组件, 14.2.2 访问基类的方法, 14.2.3 访问基类对象, 14.2.3 访问基类的友元函数, 14.2.4 使用修改后的Student类, 14.2.5 保护继承, 14.2.6 使用using重新定义访问权限, 14.3 多重继承, 14.4 类模板, 14.4.1 定义模板类, 14.4.2 使用类模板, 14.4.3 指针栈x2F指针模板, 14.4.4 数组模板示例和非类型参数, 14.4.4 模板的多功能性, 14.4.6 模板的具体化, 14.4.7 成员模板, 14.4.8 将模板用作参数, 14.4.8 模板类和友元, 14.4.8 模板别名, 第15章 友元、异常和其他, 15.1 友元, 15.1.1 友元类, 15.1.2 友元成员函数, 15.1.3 其他友元关系, 15.1.4 共同的友元, 15.2 嵌套类, 15.2.1 嵌套类和访问权限, 15.2.2 模板中的嵌套, 15.3异常, 15.4 RTTI, 15.4.1 RTTI的用途, 15.4.2 RTTI的工作原理, 15.5 类型转换运算符, 第16章 string类和标准模板库, 16.1 string类, 16.1.1 构造字符串, 16.1.2 string类输入, 16.1.3  使用字符串, 16.2 智能指针模板类, 16.2.1 使用智能指针, 16.2.3 unique_ptr优于auto_ptr, 16.2.4 选择智能指针, 16.3 标准模板库, 16.3.1 模板类vector, 16.3.2 可执行的操作, 16.3.4 基于范围的for循环, 16.4 泛型编程, 16.4.2 迭代器类型, 16.4.4 概念改进和模型, 16.4.5 容器的种类, 16.4.6 关联容器, 16.4.7 无序关联容器, 16.5 函数对象, 16.5.1 函数符概念, 16.5.2 预定义的函数符, 16.5.3 自适应函数符和函数适配器, 16.6 算法, 16.6.1 算法组, 16.6.2 算法的通用特征, 第17章 泛型编程注意的事项第章开始学习进入使用进行输出第章分支语句和逻辑运算符简单文件输入输出第章使用类类的自动转换和强制类型转换数据类型的转换都是正确的将进行自动类型转换不会进行自动转换是不兼容的类型可进行强制类型转换下面的构造函数用于将类型的值转换为类类型介绍的是转换构造函数只能是接受一个参数的构造函数才能这样可以先创建一个临时的的对象并将作为初始值然后将临时对象的内容复制到中为类的隐式转换是自动进行的是关闭隐式转换但仍然允许显式强制类型转换转换还存在二义性还可以用于将值传递给接受参数的函数如果提供了构造函数并且是成员函数的加法函数则可以这样做但只有友元函数才允许这样做转换函数转换函数的概念是将类类型转换为某种类型是用户定义的强制类型转换转换函数必须是类方法不能指定返回类型不能有参数转换为类型的函数返回一个数注意虽然没有声明返回类型但也将返回所需的值是四舍五入的方式而不是去掉小数部分类类型转换为某种类型也会存在二义性不能用于转换函数但可以使用非转换函数替换只能进行强制转换是非法的可以警告应谨慎地使用隐式转换函数通常使用显式的强制类型转换转换函数和友元函数实现加法时的选择要将量和量相加可以有两种方法第章类和动态内存分配动态内存和类开发一个动态内存类使用动态内存分配来开发类使用指针而不是数组这意味着类声明没有为字符串分配存储空间静态类成员特点无论创建了多少对象所有对象共享同一个静态成员例如成员可以记录所创建的对象数目不能在类声明中初始化静态成员变量只能在文件中初始化类外也不可以初始化但如果静态成员是整数类型或枚举类型见第十章则可以在类声明中初始化创建构造函数不会包括末尾的空字符记录对象的数量字符串并不保存在对象中而是保存在堆内存中对象仅保存了指出到哪里去查找字符串的信息不能这样做这只保存了地址而没有创建字符串副本析构函数的使用对象声明放在一个内部代码块中因为析构函数将在定义对象的代码块执行完毕时调用对象的删除的顺序与创建顺序相反在进行输出类时是运用了重载运算符注意查看重载运算符函数中输出的是什么内容编译器会自动生成成员函数和自动使用你不使用函数构造函数析构函数为复制构造函数会创建对象的一个副本调用了一个函数特殊成员函数特殊成员函数是自动定义的有默认构造函数如果没有定义默认析构函数如果没有定义复制构造函数如果没有定义赋值运算符如果没有定义地址运算符如果没有定义返回调用对象的地址即指针的值新增移动构造函数移动运算符默认构造函数如果定义了构造函数将不会定义默认构造函数如果希望在创建对象时不显示地对它进行初始话则必须显示地定义默认构造函数它还可以来设定特定的值在创建对象时不显示地对它进行初始话带参数的构造函数也可以是默认构造函数只要所有参数都有默认值但只有一个默认构造函数不然会造成二义性复制构造函数它用于初始化过程而不是常规的赋值过程每当程序生成了对象副本时编译器都将使用复制构造函数使用初始化一个匿名对象并将新对象的地址赋给指针当按值传递和返回对象时以及编译器生成临时对象例如将个对象相加时编译器可能生成临时的对象来保存中间结果都将调用复制构造函数复制构造函数初始化函数的形参由于按值传递对象将调用复制构造函数在用类为函数的参数时应该按引用传递对象如果成员本身就是类对象则将使用这个类的复制函数来复制成员对象静态成员不受影响因为它们属于整个类显示复制构造函数如果类中包含这样的静态数据成员即其值将在对象被创建时发生变化则应该提供一个显示复制构造函数来处理计数问题回到复制构造函数的哪里出了问题这里复制的并不是字符串而是一个指向字符串的指针得到两个指向同一个字符串的指针相当于由于私有成员是无法访问的因此这些代码是不能通过编译的指向的内容已经被的析构函数释放定义一个显式复制构造函数以解决问题深度复制该复制构造函数应当复制字符串并将副本的地址赋给成员如果类中包含了使用初始化的指针成员应当定义一个深度复制函数的其他问题赋值运算符赋值运算符的功能以及何时使用它将已有的对象赋给另一个对象时将使用重载的赋值运算符使用函数表示法时与复制构造函数相似赋值运算符也对成员进行逐个复制如果成员本身就是类对象则程序将使用为这个类定义的赋值运算符来复制该成员但静态数据成员不受影响赋值的问题与复制的问题的一样的解决赋值的问题函数返回一个指向调用对象的引用即指针代码首先检查自我复制这是通过查看赋值运算符右边的地址是否与接收对象的地址相同来完成的赋值操作并不创建新的对象因此不需要调整静态数据成员的值改进后的新类标准字符串函数库的功能空指针用于表示空指针重载运算符为对象数组输入内容为对象数组输出到屏幕上找到对象数组中最短的对象比较成员函数将比较函数作为友元有助于对象与常规的字符串进行比较将被转换为然后编译器将使用某个构造函数将代码转换为使用中括号表示法访问字符一般是在类这种数组中不是指它包含有四个对象而是第四个字符将赋给指向的引用访问的是私有数据但由于是类的一个方法因此能够修改数组的内容后三者是等同的是常量只能使用常量函数如果只有定义则下面的代码将出错因此提供常量版本静态类成员函数不能通过对象调用静态成员函数甚至不能使用指针它不属于对象属于类调用它的方式可以使用类名和作用域解析运算符调用它可以访问静态成员但不能访问两种的差别进一步重载赋值运算符将常规字符串复制到对象中一般来说必须释放指向的内存在构造函数中使用时应注意的事项如果有多个构造函数则必须以相同的方式使用要么带中括号要么不带中括号因为只有一个析构函数然而将指针初始化为空两种都兼容包含类成员的类的逐成员复制和都使用动态内存分配但不需要为类编写复制构造函数和赋值运算符会将使用成员类定义的复制构造函数和赋值运算符有关返回对象的说明返回指向对象的引用第一个与返回有关返回的是或和都被声明为引用所有才使用返回指向非对象引用的返回类型必须是而不能仅仅是如果使用返回类型将调用类的复制构造函数而类没有公有的复制构造函数返回对象如果被返回的对象是被调用函数中的局部变量则不应按引用方式返回它只能是返回对象使用指向对象的指针使用结构体的方式来使用成员使用初始化对象将调用复制构造函数这里指针指向创建的未被命名对象但复制构造函数会给它创建内容再谈定位运算符内存缓冲区实则指的是数组要这样做的原因在于不能与定位运算符配合使用将用于将自动调用为指向的的对象调用析构函数用于时不会为使用定位运算符创建的对象调用析构函数而是需要显示的调用析构函数一般情况下将自动调用析构函数这是需要显示调用析构函数的少数几种情况之一对地址输出的不同输出地址的方式不同定位运算符创建的对象的删除顺序与创建的顺序相反原因在于晚创建的对象可能依赖于早创建的对象另外当所有对象都被消除后才能释放缓冲区第章类继承面向对象编程的主要目的之一是提供可重用的代码通过继承完成的一些工作可以在已有的基础上添加功能例如对于数组类可以添加数学运算可以给类添加数据例如对于字符串类可以添加显示颜色的数据成员可以修改类方法的行为例如提供给飞机乘客的服务的类可以提供更高级别服务的类初始化列表语法可以减少一个步骤它直接使用的复制构造函数将初始化为一个简单的基类构造函数必须给新成员和继承的成员提供数据第二个构造函数使用一个类为参数包含继承类的构造函数的写法构造函数访问权限的考虑派生类不能直接访问基类的私有成员而必须通过基类方法进行访问列如构造函数不能直接设置继承的成员派生类构造函数必须使用基类构造函数创建派生类对象时程序首先创建基类对象使用成员初始化列表来完成调用了的构造函数省略了成员初始化列表程序将调用默认的基类构造函数等效有第二个构造函数的代码上述方法声明是在类外声明的与在类内声明的形式有很大的不一样释放对象的顺序与创建对象的顺序相反先执行派生类的析构函数派生类和基类之间的特殊关系基类指针或引用可以指向和引用派生类对象基类指针或引用只能用于调用基类方法不能使用基类指针或引用来调用派生类的方法对于形参为指向基类的指针或引用的函数也可以使用派生类作为实参按值传递将派生类对象的基类部分传递给函数引用兼容性属性让你能够将基类对象初始化为派生类对象要初始化基类要调用构造函数的原型基类定义中没有这样的构造函数但存在隐式复制构造函数同样也可以将派生类对象赋给基类对象将使用隐式重载赋值运算符继承关系公有继承是最常用的方式它建立一种关系新类将继承原始类的所有数据成员公有继承不建立关系关系午餐有水果将水果的对象作为午餐类的数据成员公有继承不建立关系即律师就像鲨鱼不应从鲨鱼类派生出律师类继承可以在基类的基础上添加基础但不能删除基类的属性公有继承不建立关系即作为来实现使用数组来实现栈不可以因为栈不是数组所以坚持使用的关系当满足的关系就可以使用公有继承多态公有继承概念同一个方法在派生类和基类中的行为是不同的即称为多态具有多种形态两种实现方法在派生类中重新定义基类的方法使用虚方法开发类和类虚方法的定义会在派生类中重新定义基类的方法但函数名一样的关键字只用于类声明的方法原型中引用类型或指针类型选择方法在继承类中的使用方法没有使用将根据引用类型或指针类型选择方法本应该这样定义的引用变量的类型为所以都为方法使用将根据引用类型或指针类型选择方法本应该这样定义的第二个是可以在派生类方法中调用基类的方法如果该方法是虚方法是使用作用域解析运算符来调用基类方法而不是派生类对象来调用方法如果不是虚方法则不必使用作用域解析运算符使用格式化方法和将浮点值的输出模式设置为定点创建指向的指针数组可以使用一个数组来表示多种类型的对象这也是多态指针既可以指向对象也可以指向对象与一般的数组定义是完全不一样的是的指针数组所以可以进行分配内存类对象的输入与一般的数据输入是不一样的多态是由下述代码提供的指的是指针不是值为何需要虚构函数静态联编和动态联编在编译过程就知道使用哪一个函数是静态联编因为虚函数的存在编译器不知道用户将选择哪种类型的对象只能在程序运行的时候确定正确的虚函数方法叫动态联编总之编译器对虚方法使用动态联编根据对象类型将关联到或指针和引用类型的兼容性不允许将一种类型地址或引用赋给另一种类型的指针或引用但基类和派生类可以而不必进行类型转换虚函数的工作原理给每个对象添加一个隐藏成员隐藏成员是一个指向函数地址数组的指针被称为虚函数表虚析构函数析构函数应当是虚函数即使它不执行任何操作除非类不用做基类析构函数不应进行操作如果没有虚析构函数语句将调用析构函数将释放派生类对象中的基类部分指向的内存但不会释放新的类成员指向的内存如果有虚析构函数则先调用析构函数在调用析构函数虚函数的参数要相同但返回值可以不同重新定义将隐藏方法两个都将被隐藏重新定义继承的方法并不是重载将隐藏所有的同名基类的方法访问控制与相似在类外只能用公有类成员来访问部分中的类成员区别在于继承方面派生类的成员可以直接访问基类的保护成员但不能直接访问基类的私有成员在派生类中与公有成员相识例如可以编写只有在派生类中可以这样使用保护数据成员可以简化代码的编写工作但又使保护数据成员成为公有变量被轻易修改抽象基类前面已经接受了简单继承和多态继承另一种建立继承的方法类和类有共点可以建立拥有他们共同点的类这个类还包含类和类不的同的方法应被声明为虚函数但至少应有一个纯虚函数抽象函数通过使用纯虚函数来提供未实现的函数当类声明中包含纯虚函数时则不能创建该类的对象只能用做基类因此可以从类派生出类和类类和类被称为具体类具有相同的基类可以用指针数组同时管理这两种对象类的纯虚函数也应该定于应用概念是一种必须实施的接口这种模式在基于组件的编程模式中很常见每个或者派生类是组件继承和动态内存分配第一种情况派生类不使用基类使用动态内存分配包含特殊方法析构函数复制构造函数重载赋值运算符而派生类不需要第二种情况派生类使用必须为派生类定义特殊方法派生类的析构函数派生类的复制构造函数是基类的引用可以指向派生类型派生类的重载赋值运算符显示调用基类赋值运算符对指针的返回返回类型也是引用不可用代替不然编译器会从而形成递归调用友元的继承类的友元访问和的方法使用强制类型转换第章中的代码重用可以定义一个通用的栈模板然后创建表示或值栈的类包含对象成员的类对于考试分数可以使用一个定长数组这限制了数组的长度可以使用动态内存分配的指针并提供大量的支持代码也可以使用动态内存分配的类表示该数组还可以在标准库中查找一个表示这种数据的类自己开发这样的类一点问题也没有类简介它支持将数组中所有元素的值相加以及在数组中找出最大和最小的值的操作提供的算术支持比和的多几个使用其构造函数的例子指定长度的空数组初始化列表先有长度再有数值长度放后面这个类的方法返回数组的长度返回字符串的长度类的设计可以从和这两个类派生出类这是多重公有继承一种关系但这里并不合适学生类与这些类不是的关系模板类一般使用自定义的形式也在放在私有部分意味着可以在类的实现中使用它当在类外面不能使用在类中可以直接使用和这两个类的方法初始化被包含的对象时构造函数将使用成员名因为初始化的是成员对象而不是继承的对象在构造函数有一个参数时考虑隐式转换函数没有使用可以写如下将创建一个个元素的对象但着一般是不允许的如果使用了将会发生错误初始化顺序它们被声明的顺序而不是它们在初始化列表中的顺序先初始化成员而不是成员在一个成员的值作为另一个成员的初始化表达式的一部分使初始化的顺序就非常重要是一个对象所以调用函数可以使用类的方法同样该函数也可以实现的输出但没有重载运算符因此类定义了一个私有辅助方法引用返回的更快在包含函数的文件中一般还自定义函数私有继承另一种实现关系的途径私有继承基类的公有成员和保护成员都将成为派生类的私有成员可以在派生类的成员函数中使用它们即只能在派生类的方法中使用基类的方法是使用接口与包含的特性一致也是将另外两个类的对象做为的成员是使用实现访问限定符的默认类型是私有类应从两个类派生而来使用多个基类的继承被称为多重继承包含与私有继承的区别包含提供了两个对象成员而私有继承提供了两个无名的子对象成员初始化基类组件有隐式地继承组件和显式地包含组件私有继承类的构造函数将使用类名来初始化访问基类的方法在没有确定对象时可以使用类名和作用域解析运算符来调用基类的方法但函数的作用域与方法的作用域不一致时就使用解析运算符访问基类对象使用强制类型转换将对象转换为对象表示对象为避免调用构造函数创建新的对象可使用强制类型转换来创建一个引用访问基类的友元函数用类名显式地限定函数名不合适于友元函数可以使用显示地转换为基类来调用正确的函数不修改的强制类型转换调用时并不是输出类的全部成员而只是要进入函数里面去看过程使用修改后的类两个版本的类的公有接口方法完全相同因此可以使用同一个程序测试它们使用包含比私有继承好如果某个类需要个对象可以使用包含声明个独立的成员如果新类需要访问原有类的保护成员或需要重新定义虚函数则应使用私有继承保护继承第三代类体现出保护继承和私有继承的区别使用重新定义访问权限在派生类类外调用基类对象的方法使用一个声明来指出派生类可以使用特定的基类成员即使采用的是私有派生可以这样使用声明只使用成员名没有圆括号函数特征标和返回类型多重继承类模板不如编写一个泛型栈然后将具体的类型作为参数传递给这个类这样就可以使用不同类型的栈例如栈和栈定义模板类为函数名尖括号中的内容相当于函数的参数列表看作是变量的类型名看作变量的名称可以使用模板成员函数替换原有类的类方法每个函数头都将以相同模板声明打头应改为作用域解析符与类名也要改如果在类声明中定义了方法内联定义则可以省略模板前缀和类限定符不能将模板成员函数放在独立的实现文件中由于模板不是函数它们不能单独编译使用类模板使用的算法必须与类型一致一般与是可以用在同一个模板类中的栈与指针栈有相同的功能但不能用在同一个模板类中指针栈指针模板使用一个指针数组其中每个指针都指向不同的字符串用使用动态数组返回类型为类时也要使用这是缩写只能在类中使用数组模板示例和非类型参数模板常用作容器类主要是为容器类提供可重用代码数组模板的成员是数组为类型参数为非类型或表达式参数编译器将使用替换使用替换表达式参数可以是整型枚举引用或指针因此是不合法的但是合法的模板代码不能修改参数的值也不能使用参数的地址如和用作参数的值必须是常量表达式介绍一个允许指定数组大小的简单数组模板第一种使用动态数组和构造函数参数来提供元素数目第二种使用模板参数来提供常规数组的大小就是这样做的表达式参数方法的缺点每种数组大小都将生成自己的模板将生成两个独立的类声明使用动态数组和构造函数参数的方法的优点更通用数组大小是作为类成员存储在定义中的可以将一种大小的数组赋给另一种大小的数组模板的多功能性模板类可用作基类也可用作组件类还可用作其他模板的类型参数递归使用模板对于前面的数组模板定义这使得是一个包含个元素的数组其中每个元素都是一个包含个元素的数组与之等价的常规数组声明即使没有这样的函数也可以这样使用控制输出宽度的方法使用多个类型参数模板类的类名是而不是默认类型模板参数为型为型模板的具体化隐式实例化显式实例化之后将生成一个类显式具体化假设模板使用运算符来对值进行比较对于数字这管用如果是将不管用这将要求类定义使用而不是来对值进行比较这种情况下可以提供一个显式模板具体化即为一种具体类型定义的模板而不是泛型定义的模板部分具体化第二个声明使用通用模板时将转换为类型如果是部分具体化将转换为模板该考虑的类型常规类型成员模板模板可用作结构类或模板类的成员在模板外定义类和方法模板是嵌套的还必须指出和是类的成员而不能使用将模板用作参数是可以将类进行更改模板类和友元模板别名第章友元异常和其他友元友元类的所有方法都可以访问原始类的私有成员和保护成员友元类编写一个模拟电视机和遥控器的简单程序遥控器可以改变电视机的状态而不是的关系因此将类作为类的一个友元必须先定义放在公有位置满足的是一种先有电视再有遥控器的关系友元成员函数让特定是类成员成为另一个类的友元而不必让整个类成为友元让成为类的友元的方法是在类声明中将其声明为友元使用的是类的成员所以必须是友元必须使用前向声明声明中只包含方法声明并将实际的定义放在类之后其他友元关系共同的友元嵌套类对类进行嵌套与包含并不同包含意味着将类对象作为另一个类成员而对类进行嵌套不创建类成员而是定义了一种类型程序的其他部分在方法文件中定义构造函数则定义必须指出类是在类中定义的嵌套类和访问权限类的默认访问权限是私有的队列类是嵌套类嵌套类是在另一个类的私有部分声明的只有类成员可以使用对象和指向嵌套类对象的指针派生类和外部世界不知道它的存在如果是保护部分声明的派生类可见并且可以创建这种类型的对象但对于外部是不可见的如果是公有部分声明的允许派生类和外部世界使用它嵌套结构和枚举的作用也是相同的有一个失业的教练他不属于任何球队可以在类的外面创建对象是这种关系的类型类对象只能显示地访问节点类对象的公有成员因为类的所有成员都被声明为公有的模板中的嵌套类定义转换为模板是一种容器类可以连续输入次被定义成用于存储的值异常是运行阶段类型识别的简称旨在为程序在运行阶段确定对象的类型提供一种标准方式的用途有一个类层次结构其中的类都是从同一个基类派生而来的则可以让基类指针指向其中任何一个类的对象的工作原理只适用于包含虚函数的类是用于基类指针与派生类的转换运算符使一个基类指针指向一个派生类的指针如果失败将空指针赋给指针使得进行向上转换的关系这样可以在的基础上使用成员类并没有这个函数有这个函数运算符和类类型转换运算符在语言中都是允许的可以将结构里的成员类型发生转换转换为字符串将地址转换为字符将结构里的成员类型发生转换转换为整型运算符将改变值为或类型的其他方面不能被修改运算符是进行向下转换的运算符将进行重新解释将一种类型转换为另一种类型第章类和标准模板库编程是一种泛型编程标准模板库是用于处理各种容器对象的模板类头文件和支持对风格字符串进行操纵不支持类构造字符串类的构造函数初始化为运算符被多次重载可以使用风格字符串或值从中取出从第个到第个字符取前字母取到取到不可不是指针地址新增的构造函数移动构造函数列表初始化类输入风格字符串的输入对象可以自动调整对象的大小可以这两种使用两个版本都有一个可选参数用于指定使用哪个字符来确定输入的边界对象输入的限制对象的最大允许长度由常量指定通常最大值为如果你将整个文件的内容读取到单个对象中这是一个限制使用字符串成员来自类而是为提供的可以计算数组的大小成员函数方法从开始查找字符找到返回索引从开始查找字符串从开始查找字符串删除字符串的内容返回当前分配给字符串的内存块的大小能够请求内存块的最小长度分配个字符的内存智能指针模板类智能指针定义了类似于指针的类对象可以帮助管理动态内存分配的智能指针模板将获得的地址赋给这种对象是一个常规指针不是一个类对象使用智能指针必须包含头文件模板是返回的指针可以使用的成员函数每一个智能指针都放在代码块中当离开作用域时指针自动释放放弃对象的所有权变成空指针放弃对象所有权共享对象所有权放弃的所有权放弃的所有权变为空指针是不被允许的这样做会直接编译出错和指向同一个对象和共享对象的所有权使用分配内存时才能使用和使用时使用优于函数返回的临时会被销毁编译出错不能被赋值正确不会编译出错选择智能指针选择的情况有一个指针数组并使用一些辅助指针来标识特定的元素两个对象包含都指向第三个对象的指针容器包含指针算法都支持赋值和复制操作可用于只要不调用将一个复制和赋值给另一个的方法或算法但不能用于调用没有问题因为它返回一个临时被赋给中的一个为右值时可将其赋给包含一个显示构造函数可将右值转换为标准模板库迭代器能够用来遍历容器的对象与能够遍历数组的指针类似是广义指针容器数组队列链表是选择一种能存储多种数据类型的数据类型成为容器操作搜索排列和随机排列适用于所有容器类的非成员函数省去了大量重复的工作不是面向对象编程而是一种不同的编程模式泛型编程数学矢量与计算矢量不一样能够分配容器的对象大小的容器都使用了动态内存分配模板类分配器管理内存分配和释放的类各种容器模板都接受一个可选的模板参数该参数指定使用哪个分配器对象来管理内存这个类使用和来分配和释放内存为分配器可执行的操作所有的容器都提供了一些基本方法交换对象的内容返回一个指向容器中第一个元素超过容器尾的迭代器迭代器解除引用和递增返回指向当前元素的指针递增迭代器每个容器类都定义了一个合适的迭代器该迭代器是一个名为的模板类作用域为整个类自动类型推断声明了一个迭代器一般带有指针的名字都会有指针的性质只不过在取地址这里有点不一样迭代器遍历容器内容类的才有的在矢量末尾添加元素它将负责内存管理增加矢量的长度方法删除矢量中给定区间的元素提供了随机访问功能因此可以有操作方法将元素插入到矢量中的指定位置该区间是另一个容器对象的一部分交换两个对象的内容个容器类需要支持中操作都有自己的成员函数则要定义个成员函数但采用方式时只需要个非成员函数即可即使有执行相同任务的非成员函数有时也会定义一个成员函数因为类特定算法的效率比通用算法高成员函数效率比非成员函数高但非成员函数让你能够交换两个不同容器的内容函数和必须包含替换为最后一个参数是指向函数的指针函数对象该函数不可以修改容器元素的值随机排列该区间中的元素要求容器类允许随机访问注意是使用的是布尔类型的返回值现在函数总是用布尔类型的返回值和循环是否结束第一个版本使用为存储在容器中的类型元素定义的运算符如果容器元素类型是用户定义的则要使用必须定义能够该类型对象的函数为提供了成员或非成员函数第二种版本的基于范围的循环基于范围的循环是为用于而设计的循环将依次将中的每个对象传递给不同于基于范围的循环可以修改容器中的元素但要指定一个引用参数两个地方必须要有引用泛型编程是一种泛型编程面向对象编程关注的是编程的数据方面使任何数据类型能存在容器中而泛型编程关注的是算法使任何容器能运用于算法共同特定是抽象和创建可重用代码模板使得算法独立于存储的数据类型而迭代器使算法独立于使用的容器类型定义一种链表类型的迭代器类是返回的是类对象与几乎相同区别在于结束的条件不同这就需要不同的容器了函数的实现方法每个容器类定义了相应的迭代器类型可能是指针可能是对象每个容器类都有和方法都使用让迭代器递增新增的自动类型推断最好避免直接使用迭代器而尽量使用和基于范围的循环有了迭代器算法才能通用基于算法的要求设计基本迭代器的特征和容器的特征迭代器类型不同的算法对迭代器的要求也不同排序算法需要能够随机访问可以通过定义运算符来实现迭代器也是一个类含有构造函数如果两个迭代器相同则解除引用操作得到的值将相同输出迭代器只能修改容器值而不能读取程序的输出就是容器的输入输入和输出迭代器都是单通行不能保证第二次遍历容器时顺序不变也不能保证其先前值仍然可以被解除引用正向迭代器可以对前面的迭代器值解除引用可以读取和修改数据也可以只读取数据双向迭代器中函数可以交换第一个元素和最后一个元素将指向第一个元素的指针加指向第一个元素的指针减函数需要随机访问迭代器所以只能用于支持这种迭代器的容器随机访问迭代器实现为一个常规指针正向迭代器实现为一个类一种迭代器的类型是不一样的两种类型的迭代器每个容器类都定义了一个类级名称如果所设计的容器类需要迭代器可考虑它包含用于标准种类的迭代器模板概念改进和模型将指针用作迭代器使得算法用于常规数组将一个数组复制到一个矢量中函数不能自动根据发送值调整目标容器的长度前两个参数必须是输入迭代器最后一个必须是输出迭代器输出流迭代器为这种迭代器提供了模板是输出迭代器的一个模型也是一个适配器类或函数可以将一些其他接口转换为使用的接口使得可以在算法中使用迭代器就是的接口要包含头文件构造函数的第一个参数指出了要使用的输出流第二个参数指出了要使用的分隔符才是迭代器意味着将和有空格组成的字符串发送到输出流中并为下一个输出做准备函数的另一种用法将的内容复制到输出流中即显示容器的内容其他有用的迭代器这样不必声明反向迭代器和返回的值相同但类型不同反向指针先通过递减再解除引用来解决的超尾的问题指向位置则将是位置的值三种插入迭代器只能于允许在尾部快速插入的容器快速插入指的是一个小时固定的算法满足将容器类型作为模板参数将实际的容器标识符作为构造函数参数构造函数将假设传递给它的类型有一个方法满足不满足完成任务很快没有这些限制还需要一个指示插入位置的构造函数参数二维数组也是同样的运用没有迭代器可以用将复制数据的算法转换为插入数据的算法这些预定义迭代器增加了函数的功能比如函数容器的种类具有容器概念和容器类型容器类型是可用于创建具体容器对象的模板有双端队列可以从中端和末端插入和删除元素是可以随机访问的链表是一个双向链表可以随时在任何位置插入或删除元素队列是一种先进先出的数据结构只能在末端添加元素在前端删除元素优先队列是一种特殊的队列每个元素都有一个优先级优先级最高的元素最先出队栈是一种后进先出的数据结构只能在顶端添加或删除元素向量是动态数组可以动态地增加和减少元素在尾部添加和删除元素的时间是固定的但在头部或中间插入和删除元素为线性时间还是一种反转容器映射是一种关联数组它存储的是键值对多重映射类似于映射但允许存在多个相同的键集合是一种不包含重复元素的无序集合多重集合类似于集合但允许存在重复的元素位集是一种特殊的数组它存储的是位或新增的容器类基于哈希表的关联容器用于存储键值对查找插入和删除操作的平均时间复杂度为基于哈希表的集合容器用于存储唯一的键查找插入和删除操作的平均时间复杂度为单向链表容器只支持正序遍历插入和删除操作在链表头部和尾部速度很快一些基本的容器特征线性时间固定时间固定时间复杂度从快到慢编译时间在编译时执行指向时间为固定时间在运行时执行指向时间为独立于对象中的元素数目线性时间时间与元素数目成正比指向时间为序列是基本的容器概念的改进包括要求是正向迭代器保证了元素将按特定顺序排序即除了第一和最后每个元素前后都分别有一个元素为定义了而没有为定义是因为在矢量前插入一个元素需要移动大量的元素而和的允许将元素添加到前端而不移动其他元素以固定时间来完成所以没有必要定义和都对元素进行随机访问和在中部执行线性时间的插入和删除但容器执行的更快因为的内存是连续的而的内存不是连续的所以的访问速度更快更复杂双向链表可以双向遍历链表可以从后面往前面遍历也是反转容器成员函数将两个链表合并两个链表必须是已经排序合并后为空为线性时间删除所有值为的元素线性时间将连续的相同即相邻的相同值的元素压缩为单个元素可以结合来使用线性时间使用运算给发将元素排序线性时间为将中的元素插入到之前将为空为固定时间非成员函数需要随机访问迭代器不能用于链表所以只能使用类中的成员函数版本工具箱方法组成了一个方便的工具箱例如有两个邮件列表要整理则可以对每个列表进行排序合并它们然后使用来删除重复的元素新增的实现单链表无反向迭代器因为每个节点都只链接到下一个节点而没有链接到前一个节点模板类是一个适配器类让底层类展示典型的队列接口既不允许随机访问也不允许遍历队列只允许队列的基本操作使用这个值与栈一样在队列的末尾添加一个元素从队列的开头移除一个元素并返回该元素返回队列的第一个元素但不移除该元素返回队列的最后一个元素但不移除该元素检查队列是否为空如果为空则返回否则返回返回队列中的元素个数是另一个适配器类与操作相同主要是最大的元素被移到队首底层类是可以修改用于确定哪个元素放到队首的比较方式这用到了构造函数模板类与相同也是适配器类底层类是给底层类提供了典型的栈接口既不允许随机访问也不允许遍历栈只允许栈的基本操作将压入推到栈顶从栈顶弹出元素查看栈顶的值检查元素数目和测试栈是否为空判断栈是否为空如果为空则返回否则返回返回栈的元素个数返回栈顶元素并弹出该元素将元素压入栈中弹出栈顶元素如果要使用栈值必须首先使用来检索这个值然后使用将它从栈中删除模板类并非容器因为其长度是固定的没有定义调整容器大小的操作如和可将标准算法用于对象如和关联容器关联容器将值与键冠梁在一起并使用键来查找值优点在于它提供了对元素的快速访问允许插入元素新元素但不能指定元素的插入位置原因是关联容器通常有用于确定数据放置位置的算法而不是使用迭代器以便能够快速找到元素关联容器通常是使用某种树实现的种关联容器前两种是在头文件中定义后两种是在中定义的其值类型与键相同键是唯一的不会有多个相同的键可能有多个值的键相同中值与键的类型不同键是唯一的每个键只对应一个值可能有一个键可以与多个值关联模板类可反转可排序且键是唯一的所以不能存储多个相同的值第二个模板参数可用于指示用来对键进行的比较函数对象有一个将迭代器区间作为参数的构造函数键是唯一的所以在数组两次出现但在集合中只出现一次且集合被排序数学为集合定义了一些标准操作如并集交集这些操作的算法是通用函数不是类方法显示集合和的并集并进行了排序的模板参数指定键的类型和存储的值的类型为将信息结合在一起实际的值的类型将键类型与数据类型结合为一对使用模板类将两种值存储到一个对象中对象的值类型为用区号作为键来存储城市名这恰好与值类型一致因为数据项是按键排序的所以不需要指出插入位置无序关联容器无序关联容器也将值与键关联起来并使用键来查找值是基于哈希表旨在提高添加和删除元素的速度以及查找算法的效率函数对象很多算法使用了函数对象包括函数名指向函数的指针和重载了运算符的类对象即定义了函数的类函数符概念生成器是不用参数就可以调用的函数符一元函数是用一个参数就可以调用的函数符例如是一元函数因为它每次用于一个容器元素返回值的一元函数是谓词删除链表中所有大于的元素可以将两个参数的模板函数转换为单个参数的函数对象直接使用类对象的值来自链表中设计一个类来控制大于多少的元素将被删除函数对象是一种适配器使函数或类成员函数能够满足不同的接口接口就是函数或类成员函数预定义的函数符定义了多个基本函数符它们执行诸如将两个值相加比较两个值是否相等操作有两个版本计算每个元素的平方根计算所有元素和的第一个元素的平均值可有可无函数对象不会带参数的头文件定义了多个模板类函数对象其中包括类对于所有内置的算术运算符关系运算符和逻辑运算符都提供了函数对象例如和是两个函数对象自适应函数符和函数适配器表列出的预定义函数符都是自适应的函数符自适应性的意义在于函数适配器对象可以使用函数对象使函数能匹配不同的接口函数适配器将接受两个参数的函数符转换为接受个参数的函数符前面的示例提供了一种方法但使用和类自动完成这个过程是一个自适应二元函数对象将与的第一个参数相关联函数与类的作用相同只是将常数赋给第二个参数将二元函数转换为将参数乘以的一元函数算法的非成员函数有些函数接受一个函数对象统一的容器设计使得不同类型的容器之间具有明显的关系例如可以使用将对象中的值复制到对象中用来比较不同类型的容器如和之所以能这样做是容器都使用迭代器来提供访问容器中的数据算法组通用数字运算的算法在头文件中定义最有可能使用这些操作的容器算法的通用特征的结果被存放在原始数据的位置上将结果发送到另一个位置可以以这两种方式完成工作的原型这包含了两种迭代器有些算法有两个版本就地版本和复制版本复制版本的名称将以结尾将接受一个多的输出迭代器参数第章泛型编程注意的事项函数的返回值为或添加在后面判断是否输入了在连续输入时要考虑的存在对象初始化两个不同表示数组大小的方式中的类对象和通常函数都要处理空间名称").trim().substring(0, 1000);
    let value = Math.floor(Math.random() * 3) + 1000;
    while (value === prevParam || truncateDescription.length - value === prevParam) {
      value = Math.floor(Math.random() * 3) + 1000;
    }
    aiTitleRefreshIcon.style.opacity = "0.2";
    aiTitleRefreshIcon.style.transitionDuration = "0.3s";
    aiTitleRefreshIcon.style.transform = "rotate(" + 360 * refreshNum + "deg)";
    if (truncateDescription.length <= 1000) {
      let param = truncateDescription.length - Math.floor(Math.random() * 3);
      while (param === prevParam) {
        param = truncateDescription.length - Math.floor(Math.random() * 3);
      }
      aiAbstract(param);
      prevParam = param;
    } else {
      aiAbstract(value);
      prevParam = value;
    }
    showAiBtn();
    refreshNum++;
  });

  document.getElementById("go-tianli-blog").addEventListener("click", () => {
    window.open("https://afdian.net/item/886a79d4db6711eda42a52540025c377", "_blank");
  });
  
  if (false) {
    document.getElementById("ai-Toggle").addEventListener("click", () => {
      changeShowMode()
    });
  }

  function showAiBtn() {
    document.querySelectorAll(".ai-btn-item").forEach(item => {
      if (item.id !== "go-tianli-blog") {
        item.style.display = "block";
      }
      if (item.id === "go-tianli-blog") {
        item.style.display = "none";
      }
    });
  }


  aiAbstract();
  showAiBtn()
})()</script></div><article class="post-content" id="article-container"><h1 id="第2章-开始学习C"><a href="#第2章-开始学习C" class="headerlink" title="第2章 开始学习C++"></a>第2章 开始学习C++</h1><h2 id="2-1-进入C"><a href="#2-1-进入C" class="headerlink" title="2.1 进入C++"></a>2.1 进入C++</h2><h3 id="2-1-6-使用cout进行C-输出"><a href="#2-1-6-使用cout进行C-输出" class="headerlink" title="2.1.6 使用cout进行C++输出"></a>2.1.6 使用cout进行C++输出</h3><h1 id="第6章-分支语句和逻辑运算符"><a href="#第6章-分支语句和逻辑运算符" class="headerlink" title="第6章 分支语句和逻辑运算符"></a>第6章 分支语句和逻辑运算符</h1><h2 id="6-8-简单文件输入输出"><a href="#6-8-简单文件输入输出" class="headerlink" title="6.8 简单文件输入输出"></a>6.8 简单文件输入输出</h2><h1 id="第11章-使用类"><a href="#第11章-使用类" class="headerlink" title="第11章 使用类"></a>第11章 使用类</h1><h2 id="11-6类的自动转换和强制类型转换"><a href="#11-6类的自动转换和强制类型转换" class="headerlink" title="11.6类的自动转换和强制类型转换"></a>11.6类的自动转换和强制类型转换</h2><ol>
<li><p>数据类型的转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> tine = <span class="number">11</span>;  </span><br><span class="line"><span class="type">int</span> side = <span class="number">3.33</span>;  都是正确的，将进行自动类型转换</span><br><span class="line"><span class="type">int</span> *p = <span class="number">10</span>;    不会进行自动转换，是不兼容的类型，可进行强制类型转换</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的构造函数用于将double类型的值转换为Stonewt类类型，介绍的是转换构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs)   只能是接受一个参数的构造函数才能这样   Stonewt::<span class="built_in">Stonewt</span>(<span class="type">int</span> stn,<span class="type">double</span> lbs=<span class="number">0</span>)可以</span><br><span class="line">&#123;</span><br><span class="line">	stone = <span class="built_in">int</span>(lbs)/<span class="number">14</span>;</span><br><span class="line">	pounds = lbs; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt myCat;</span><br><span class="line">myCat = <span class="number">19.6</span>;</span><br><span class="line">先创建一个临时的Stonewt的对象，并将<span class="number">19.2</span>作为初始值，然后将临时对象的内容复制到myCat中,为类的隐式转换，是自动进行的</span><br></pre></td></tr></table></figure>
</li>
<li><p>explicit是关闭隐式转换，但仍然允许显式强制类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Stonewt</span><span class="params">(<span class="type">double</span> lbs)</span></span>;</span><br><span class="line">Stonewt myCat;</span><br><span class="line">myCat = <span class="number">19.6</span>;  NO</span><br><span class="line"></span><br><span class="line">myCat = <span class="built_in">Stonewt</span>(<span class="number">19.6</span>);   Yes</span><br><span class="line">myCat = (Stonewt)<span class="number">19.6</span>;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换还存在二义性，还可以用于将double值传递给接受Stonewt参数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> Stonewt &amp; st,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Wow&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">display</span>(<span class="number">422</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果提供了Stonewt(double)构造函数,并且是成员函数的加法函数则可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt <span class="title">jennySt</span><span class="params">(<span class="number">9</span>,<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> kennyD = <span class="number">176.0</span>;</span><br><span class="line">Stonewt total;</span><br><span class="line">total = jennySt+kennyD;</span><br></pre></td></tr></table></figure>
<p>但只有友元函数才允许这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt <span class="title">jennySt</span><span class="params">(<span class="number">9</span>,<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> kennyD = <span class="number">176.0</span>;</span><br><span class="line">Stonewt total;</span><br><span class="line">total = kennyD+jennySt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="11-6-1转换函数"><a href="#11-6-1转换函数" class="headerlink" title="11.6.1转换函数"></a>11.6.1转换函数</h3><ol>
<li><p>转换函数的概念：是将类类型转换为某种类型，是用户定义的强制类型转换</p>
</li>
<li><p>转换函数必须是类方法，不能指定返回类型，不能有参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;    转换为<span class="type">double</span>类型的函数</span><br><span class="line"><span class="function">Stonewt::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pounds;   返回一个<span class="type">double</span>数</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Stonewt <span class="title">wolfe</span><span class="params">(<span class="number">285.7</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> honst = <span class="built_in">double</span>(wolfe);</span><br><span class="line"><span class="type">double</span> honst = (<span class="type">double</span>)wolfe;</span><br><span class="line"><span class="type">double</span> honst = wolfe;</span><br></pre></td></tr></table></figure>
<p>注意虽然没有声明返回类型，但也将返回所需的值，是四舍五入的方式而不是去掉小数部分</p>
</li>
<li><p>类类型转换为某种类型也会存在二义性</p>
</li>
<li><p>explicit 不能用于转换函数，但可以使用非转换函数替换，只能进行强制转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stonewt::Stone_to_Int</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">int</span> (pounds+<span class="number">0.5</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> plb = poppins;    是非法的</span><br><span class="line"><span class="type">int</span> plb = poppins.<span class="built_in">Stone_to_Int</span>();   可以</span><br></pre></td></tr></table></figure>
</li>
<li><p>警告：应谨慎地使用隐式转换函数。通常使用显式的强制类型转换</p>
</li>
</ol>
<h3 id="11-6-2转换函数和友元函数"><a href="#11-6-2转换函数和友元函数" class="headerlink" title="11.6.2转换函数和友元函数"></a>11.6.2转换函数和友元函数</h3><ol>
<li>实现加法时的选择，要将double量和Stonewt量相加可以有两种方法</li>
</ol>
<h1 id="第12章-类和动态内存分配"><a href="#第12章-类和动态内存分配" class="headerlink" title="第12章 类和动态内存分配"></a>第12章 类和动态内存分配</h1><h2 id="12-1动态内存和类"><a href="#12-1动态内存和类" class="headerlink" title="12.1动态内存和类"></a>12.1动态内存和类</h2><h3 id="12-1-1开发一个动态内存类"><a href="#12-1-1开发一个动态内存类" class="headerlink" title="12.1.1开发一个动态内存类"></a>12.1.1开发一个动态内存类</h3><ol>
<li><p>使用动态内存分配来开发类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str;   </span><br></pre></td></tr></table></figure>
<p>使用char指针，而不是char数组，这意味着类声明没有为字符串分配存储空间</p>
</li>
<li><p>静态类成员特点：<br>无论创建了多少对象，所有对象共享同一个静态成员，例如，num_strings成员可以记录所创建的对象数目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> num_strings;</span><br><span class="line"><span class="type">int</span> StringBad::num_strings = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>不能在类声明中初始化静态成员变量，只能在.c文件中初始化，类外也不可以初始化，但如果静态成员是const整数类型或枚举类型(见第十章)，则可以在类声明中初始化<br>创建构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">	len = <span class="built_in">strlen</span>(s);   不会包括末尾的空字符<span class="string">&#x27;\0&#x27;</span></span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[len+<span class="number">1</span>];  </span><br><span class="line">	<span class="built_in">strcpy</span>(str,s);</span><br><span class="line">	num_strings++;  记录对象的数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串并不保存在对象中，而是保存在堆内存中，对象仅保存了指出到哪里去查找字符串的信息。不能这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = s;</span><br></pre></td></tr></table></figure>
<p>这只保存了地址，而没有创建字符串副本</p>
</li>
<li><p>析构函数的使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		StringBad knot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象声明放在一个内部代码块中，因为析构函数将在定义对象的代码块执行完毕时调用，对象的删除的顺序与创建顺序相反</p>
</li>
<li><p>在进行输出类时，是运用了重载运算符&lt;&lt;，注意查看重载运算符&lt;&lt;函数中输出的是什么内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBad knot;</span><br><span class="line">cout &lt;&lt; knot &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器会自动生成成员函数和自动使用你不使用函数：构造函数，析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp;);   为复制构造函数，会创建对象的一个副本</span><br><span class="line">StringBad sailor=sports《《 StringBad sailor=<span class="built_in">StringBad</span>(sports);  调用了一个函数</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-1-2-特殊成员函数"><a href="#12-1-2-特殊成员函数" class="headerlink" title="12.1.2 特殊成员函数"></a>12.1.2 特殊成员函数</h3><ol>
<li><p>特殊成员函数是自动定义的，有：<br>默认构造函数，如果没有定义<br>默认析构函数，如果没有定义<br>复制构造函数，如果没有定义<br>赋值运算符，如果没有定义<br>地址运算符，如果没有定义，返回调用对象的地址(即this指针的值)<br>c++11新增：<br>移动构造函数<br>移动运算符</p>
</li>
<li><p>默认构造函数<br>如果定义了构造函数，c++将不会定义默认构造函数。如果希望在创建对象时不显示地对它进行初始话，则必须显示地定义默认构造函数，它还可以来设定特定的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Klunk::<span class="built_in">Klunk</span>()</span><br><span class="line">&#123;</span><br><span class="line">	klunk_ct = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Klunk lunk;     在创建对象时不显示地对它进行初始话</span><br></pre></td></tr></table></figure>
<p>带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值，但只有一个默认构造函数，不然会造成二义性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Klunk</span>(<span class="type">int</span> n=<span class="number">0</span>)&#123;klunk_ct = n&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制构造函数<br>1.它用于初始化过程，而不是常规的赋值过程，每当程序生成了对象副本时，编译器都将使用复制构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StirngBad * pStringBad = <span class="keyword">new</span> <span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp;);</span><br></pre></td></tr></table></figure>
<p>使用motto初始化一个匿名对象，并将新对象的地址赋给pstring指针<br>2.当按值传递和返回对象时以及编译器生成临时对象，例如将3个Vectir对象相加时，编译器可能生成临时的Vector对象来保存中间结果，都将调用复制构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme1</span><span class="params">(StringBad n)</span></span>;    复制构造函数初始化<span class="built_in">callme2</span>()函数的StringBad形参</span><br><span class="line"><span class="built_in">callme2</span>(headline2);</span><br></pre></td></tr></table></figure>
<p>3.由于按值传递对象将调用复制构造函数，在用类为函数的参数时应该按引用传递对象<br>4.如果成员本身就是类对象，则将使用这个类的复制函数来复制成员对象。静态成员不受影响，因为它们属于整个类</p>
</li>
<li><p>显示复制构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	num_string++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类中包含这样的静态数据成员，即其值将在对象被创建时发生变化，则应该提供一个显示复制构造函数来处理计数问题</p>
</li>
</ol>
<h3 id="12-1-3-回到Stringbad-复制构造函数的哪里出了问题"><a href="#12-1-3-回到Stringbad-复制构造函数的哪里出了问题" class="headerlink" title="12.1.3 回到Stringbad: 复制构造函数的哪里出了问题"></a>12.1.3 回到Stringbad: 复制构造函数的哪里出了问题</h3><ol>
<li><p>这里复制的并不是字符串，而是一个指向字符串的指针，得到两个指向同一个字符串的指针，相当于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sailor.str = sport.str;(由于私有成员是无法访问的，因此这些代码是不能通过编译的)</span><br></pre></td></tr></table></figure>
</li>
<li><p>sports.str指向的内容已经被sailor的析构函数释放</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] sailor.str;</span><br><span class="line"><span class="keyword">delete</span> [] sports.str;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个显式复制构造函数以解决问题(深度复制)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">	num_string++;</span><br><span class="line">	len = st.len;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span> [len+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str,st.str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该复制构造函数应当复制字符串并将副本的地址赋给str成员,如果类中包含了使用new初始化的指针成员，应当定义一个深度复制函数</p>
</li>
</ol>
<h3 id="12-1-4-StringBad的其他问题：赋值运算符"><a href="#12-1-4-StringBad的其他问题：赋值运算符" class="headerlink" title="12.1.4 StringBad的其他问题：赋值运算符"></a>12.1.4 StringBad的其他问题：赋值运算符</h3><ol>
<li><p>赋值运算符的功能以及何时使用它<br>将已有的对象赋给另一个对象时，将使用重载的赋值运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBad &amp; StringBad::<span class="keyword">operator</span>=(<span class="type">const</span> StringBad &amp;);</span><br><span class="line">so = s1;</span><br><span class="line">使用函数表示法时：</span><br><span class="line">so.<span class="built_in">operator</span>(s1);</span><br></pre></td></tr></table></figure>
<p>与复制构造函数相似，赋值运算符也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响</p>
</li>
<li><p>赋值的问题与复制的问题的一样的</p>
</li>
<li><p>解决赋值的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringBad &amp; StringBad::<span class="keyword">operator</span>=(<span class="type">const</span> StringBad &amp;st)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>==&amp;st)     </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">delete</span> [] str;</span><br><span class="line">	len = st.len;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span> [len+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str,st.str);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.函数返回一个指向调用对象的引用(即this指针)<br>2.代码首先检查自我复制，这是通过查看赋值运算符右边的地址(&amp; s)是否与接收对象的地址(this)相同来完成的<br>3.赋值操作并不创建新的对象，因此不需要调整静态数据成员num_strings的值</p>
</li>
</ol>
<h2 id="改进后的新Stirng类"><a href="#改进后的新Stirng类" class="headerlink" title="改进后的新Stirng类"></a>改进后的新Stirng类</h2><ol>
<li><p>标准字符串函数库cstring的功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span>  </span>&#123;<span class="keyword">return</span> len&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="built_in">operator</span>&lt;(<span class="type">const</span> String &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> String &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> String &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;&gt;(istream &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="type">const</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="type">const</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">HowMany</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>c++11空指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>nullptr用于表示空指针</p>
</li>
<li><p>重载&gt;&gt;运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is,String &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> temp[<span class="number">80</span>];</span><br><span class="line">	is.<span class="built_in">get</span>(temp,<span class="number">80</span>)</span><br><span class="line">	<span class="keyword">if</span>(is)</span><br><span class="line">		str = temp;</span><br><span class="line">	<span class="keyword">while</span>(is&amp;&amp;is.<span class="built_in">get</span>()!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为对象数组输入内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String saying[n];</span><br><span class="line"><span class="type">char</span> temp[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	cin.<span class="built_in">get</span>(temp,<span class="number">80</span>);</span><br><span class="line">	<span class="keyword">while</span>(cin&amp;&amp;cin.<span class="built_in">get</span>()!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cin)</span><br><span class="line">		saying[i] = temp;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为对象数组输出到屏幕上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;saying[i][<span class="number">0</span>]&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;saying[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到对象数组中最短的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> shortest = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(saying[i].<span class="built_in">length</span>()&lt;saying[shortest].length)</span><br><span class="line">		shortest = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-2-2比较成员函数"><a href="#12-2-2比较成员函数" class="headerlink" title="12.2.2比较成员函数"></a>12.2.2比较成员函数</h3><ol>
<li>将比较函数作为友元，有助于String对象与常规的c字符串进行比较<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;love&quot;</span>==answer)</span><br><span class="line">将被转换为：</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="string">&quot;love&quot;</span>,answer))</span><br><span class="line">然后，编译器将使用某个构造函数将代码转换为：</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="built_in">String</span>(<span class="string">&quot;love&quot;</span>),answer))</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> String &amp; st1,<span class="type">const</span> String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(st1.str,st2.str)&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> String &amp; st1,<span class="type">const</span> String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(st1.str,st2.str)&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> String &amp; st1,<span class="type">const</span> String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(st1.str,st2.str)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-2-3使用中括号表示法访问字符"><a href="#12-2-3使用中括号表示法访问字符" class="headerlink" title="12.2.3使用中括号表示法访问字符"></a>12.2.3使用中括号表示法访问字符</h3><ol>
<li><p>一般是在String类这种数组中，opera[4]不是指它包含有四个对象，而是第四个字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">opera</span><span class="params">(<span class="string">&quot;The Magic Flute&quot;</span>)</span></span>;</span><br><span class="line">opera[<span class="number">4</span>];</span><br><span class="line"><span class="type">char</span> &amp; String::opera[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将r赋给指向means.str[0]的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">means</span><span class="params">(<span class="string">&quot;might&quot;</span>)</span></span>;</span><br><span class="line">means[<span class="number">0</span>]=<span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">means.<span class="keyword">operator</span>[](<span class="number">0</span>)=<span class="string">&#x27;r</span></span><br><span class="line"><span class="string">means.str[0]=&#x27;</span>r<span class="number">&#x27;</span>   访问的是私有数据，但由于<span class="keyword">operator</span>[]()是类的一个方法，因此能够修改数组的内容</span><br></pre></td></tr></table></figure>
<p>后三者是等同的</p>
</li>
<li><p>answer是常量，只能使用常量函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> String <span class="title">answer</span><span class="params">(<span class="string">&quot;futile&quot;</span>)</span></span>;     </span><br><span class="line">如果只有<span class="keyword">operator</span>[]()定义，则下面的代码将出错：</span><br><span class="line">cout&lt;&lt;answer[<span class="number">1</span>];</span><br><span class="line">因此提供常量版本：</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp; String::opera[](<span class="type">int</span> i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-2-4-静态类成员函数"><a href="#12-2-4-静态类成员函数" class="headerlink" title="12.2.4 静态类成员函数"></a>12.2.4 静态类成员函数</h3><ol>
<li><p>不能通过对象调用静态成员函数，甚至不能使用this指针，它不属于对象，属于类，调用它的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = String::<span class="built_in">HowMany</span>();</span><br></pre></td></tr></table></figure>
<p>可以使用类名和作用域解析运算符调用它，可以访问静态成员num_string，但不能访问str</p>
</li>
<li><p>两种的差别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> num_strings;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> CLNLIM = <span class="number">80</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-2-5-进一步重载赋值运算符"><a href="#12-2-5-进一步重载赋值运算符" class="headerlink" title="12.2.5 进一步重载赋值运算符"></a>12.2.5 进一步重载赋值运算符</h3><ol>
<li>将常规字符串复制到String对象中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[] str;</span><br><span class="line">	len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span> [len+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str,s);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一般来说，必须释放str指向的内存</li>
</ol>
<h2 id="12-3-在构造函数中使用new时应注意的事项"><a href="#12-3-在构造函数中使用new时应注意的事项" class="headerlink" title="12.3 在构造函数中使用new时应注意的事项"></a>12.3 在构造函数中使用new时应注意的事项</h2><ol>
<li>如果有多个构造函数，则必须以相同的方式使用new，要么带中括号，要么不带中括号。因为只有一个析构函数，然而将指针初始化为空，两种都兼容</li>
</ol>
<h3 id="12-3-1-包含类成员的类的逐成员复制"><a href="#12-3-1-包含类成员的类的逐成员复制" class="headerlink" title="12.3.1 包含类成员的类的逐成员复制"></a>12.3.1 包含类成员的类的逐成员复制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magazine</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		String title;</span><br><span class="line">		string publisher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String和string都使用动态内存分配，但不需要为Magazine类编写复制构造函数和赋值运算符，会将使用成员类定义的复制构造函数和赋值运算符</p>
<h2 id="12-4-有关返回对象的说明"><a href="#12-4-有关返回对象的说明" class="headerlink" title="12.4 有关返回对象的说明"></a>12.4 有关返回对象的说明</h2><h3 id="12-4-1-返回指向const对象的引用"><a href="#12-4-1-返回指向const对象的引用" class="headerlink" title="12.4.1 返回指向const对象的引用"></a>12.4.1 返回指向const对象的引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Vector &amp; <span class="title">Max</span><span class="params">(<span class="type">const</span> Vector &amp; v1;<span class="type">const</span> Vector &amp; v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v1.<span class="built_in">magval</span>()&gt;v2.<span class="built_in">magval</span>())</span><br><span class="line">		<span class="keyword">return</span> v1;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个const与返回有关，返回的是v1或v2，v1和v2都被声明为const引用，所有才使用const</p>
<h3 id="12-4-2-返回指向非const对象引用"><a href="#12-4-2-返回指向非const对象引用" class="headerlink" title="12.4.2 返回指向非const对象引用"></a>12.4.2 返回指向非const对象引用</h3><p>operator&lt;&lt;()的返回类型必须是ostream &amp;，而不能仅仅是ostream。如果使用返回类型ostream，将调用ostream类的复制构造函数，而ostream类没有公有的复制构造函数</p>
<h3 id="12-4-3-返回对象"><a href="#12-4-3-返回对象" class="headerlink" title="12.4.3 返回对象"></a>12.4.3 返回对象</h3><p>如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，只能是返回对象</p>
<h2 id="12-5-使用指向对象的指针"><a href="#12-5-使用指向对象的指针" class="headerlink" title="12.5 使用指向对象的指针"></a>12.5 使用指向对象的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String * shortest = &amp;sayings[<span class="number">0</span>];</span><br><span class="line">shortest-&gt;<span class="built_in">length</span>()</span><br></pre></td></tr></table></figure>
<p>使用结构体的方式来使用成员</p>
<ol>
<li>使用new初始化对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String *favorite = <span class="keyword">new</span> <span class="built_in">String</span>(saying[choice]);</span><br><span class="line">将调用复制构造函数：</span><br><span class="line"><span class="built_in">String</span>()</span><br></pre></td></tr></table></figure>
这里指针favorite指向new创建的未被命名对象，但复制构造函数会给它创建内容</li>
</ol>
<h3 id="12-5-1-再谈定位new运算符"><a href="#12-5-1-再谈定位new运算符" class="headerlink" title="12.5.1 再谈定位new运算符"></a>12.5.1 再谈定位new运算符</h3><p>内存缓冲区实则指的是数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JustTesting</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string words;</span><br><span class="line">	<span class="type">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *buffer = <span class="keyword">new</span> <span class="type">char</span> [BUF];</span><br><span class="line">JustTesting *pc1,*pc2;，*pc3</span><br><span class="line">pcl = <span class="built_in">new</span> (buffer) JustTesting</span><br><span class="line">pc2 = <span class="keyword">new</span> <span class="built_in">JustTesting</span>(<span class="string">&quot;Heap&quot;</span>,<span class="number">10</span>);</span><br><span class="line">pc3 = <span class="built_in">new</span> (buffer+<span class="built_in">sizeof</span>(JustTesting)) <span class="built_in">JustTesting</span>()</span><br><span class="line"><span class="keyword">delete</span> [] buffer;   要这样做的原因在于：<span class="keyword">delete</span>不能与定位<span class="keyword">new</span>运算符配合使用</span><br><span class="line"><span class="keyword">delete</span> pc2;</span><br></pre></td></tr></table></figure>
<p>将delete用于pc2，将自动调用为pc2指向的的对象调用析构函数，用于buffer时，不会为使用定位new运算符创建的对象调用析构函数，而是需要显示的调用析构函数<br>，一般情况下将自动调用析构函数，这是需要显示调用析构函数的少数几种情况之一</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1-&gt;~<span class="built_in">JustTesting</span>();</span><br></pre></td></tr></table></figure>

<ol>
<li><p>cout对地址输出的不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;(<span class="type">void</span> *)buffer&lt;&lt;pc1&lt;&lt;pc2&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>buffer输出地址的方式不同</p>
</li>
<li><p>定位new运算符创建的对象的删除顺序与创建的顺序相反。原因在于晚创建的对象可能依赖于早创建的对象，另外当所有对象都被消除后，才能释放缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p3-&gt;~<span class="built_in">JustTesting</span>();</span><br><span class="line">p1-&gt;~<span class="built_in">JustTesting</span>();</span><br><span class="line"><span class="keyword">delete</span> [] buffer; </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第13章-类继承"><a href="#第13章-类继承" class="headerlink" title="第13章 类继承"></a>第13章 类继承</h1><p>面向对象编程的主要目的之一是提供可重用的代码</p>
<ol>
<li>通过继承完成的一些工作：<br>可以在已有的基础上添加功能。例如，对于数组类，可以添加数学运算。<br>可以给类添加数据。例如，对于字符串类，可以添加显示颜色的数据成员。<br>可以修改类方法的行为。例如，提供给飞机乘客的服务的类，可以提供更高级别服务的类。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Table::<span class="built_in">Table</span>(<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht):<span class="built_in">firstname</span>(fn),<span class="built_in">lastname</span>(ln),<span class="built_in">hasTable</span>(ht)&#123;&#125;</span><br><span class="line">Table::<span class="built_in">Table</span>(<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht)</span><br><span class="line">&#123;</span><br><span class="line">	firstname = fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
初始化列表语法可以减少一个步骤，它直接使用string的复制构造函数将firstname初始化为fny</li>
</ol>
<h2 id="13-1-一个简单的基类"><a href="#13-1-一个简单的基类" class="headerlink" title="13.1 一个简单的基类"></a>13.1 一个简单的基类</h2><h3 id="13-1-1"><a href="#13-1-1" class="headerlink" title="13.1.1"></a>13.1.1</h3><p>构造函数必须给新成员和继承的成员提供数据。第二个构造函数使用一个类为参数，包含firstname，lastname，hasTable</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RatePlayer</span>(<span class="type">int</span> r=<span class="number">0</span>,<span class="type">const</span> string &amp; fn=<span class="string">&quot;none&quot;</span>);</span><br><span class="line"><span class="built_in">RatePlayer</span>(<span class="type">int</span> r=<span class="number">0</span>,<span class="type">const</span> TableTennishPlayer &amp; tp);</span><br></pre></td></tr></table></figure>
<p>继承类的构造函数的写法</p>
<h3 id="13-1-2-构造函数：访问权限的考虑"><a href="#13-1-2-构造函数：访问权限的考虑" class="headerlink" title="13.1.2 构造函数：访问权限的考虑"></a>13.1.2 构造函数：访问权限的考虑</h3><ol>
<li><p>派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。列如，RatePlayer构造函数不能直接设置继承的成员，派生类构造函数必须使用基类构造函数</p>
</li>
<li><p>创建派生类对象时，程序首先创建基类对象。使用成员初始化列表来完成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r,<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht):<span class="built_in">TableTennisPalyer</span>(fn,ln,ht)</span><br><span class="line">&#123;</span><br><span class="line">	rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了TableTennisPalyer的构造函数</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r,<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht)</span><br><span class="line">&#123;</span><br><span class="line">	rating = r;</span><br><span class="line">&#125;</span><br><span class="line">省略了成员初始化列表，程序将调用默认的基类构造函数，等效有：</span><br><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r,<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht)：<span class="built_in">TableTennisPalyer</span>()</span><br><span class="line">&#123;</span><br><span class="line">	rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.第二个构造函数的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r=<span class="number">0</span>,<span class="type">const</span> TableTennishPlayer &amp; tp):<span class="built_in">TableTennishPlayer</span>(tp),<span class="built_in">rating</span>(r) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>上述方法声明是在类外声明的，与在类内声明的形式有很大的不一样</p>
</li>
<li><p>释放对象的顺序与创建对象的顺序相反，先执行派生类的析构函数</p>
</li>
</ol>
<h3 id="13-1-4-派生类和基类之间的特殊关系"><a href="#13-1-4-派生类和基类之间的特殊关系" class="headerlink" title="13.1.4 派生类和基类之间的特殊关系"></a>13.1.4 派生类和基类之间的特殊关系</h3><ol>
<li><p>基类指针或引用可以指向和引用派生类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">TableTennisPlayer &amp; rt = rplayer;</span><br><span class="line">TableTennisPlayer * pt = &amp;rplayer;</span><br><span class="line">rt.<span class="built_in">Name</span>();</span><br><span class="line">pt-&gt;<span class="built_in">Name</span>();</span><br></pre></td></tr></table></figure>
<p>基类指针或引用只能用于调用基类方法，不能使用基类指针或引用来调用派生类的方法</p>
</li>
<li><p>对于形参为指向基类的指针或引用的函数，也可以使用派生类作为实参，按值传递将派生类对象的基类部分传递给函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">const</span> TableTennisPlayher &amp; rt)</span></span></span><br><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="built_in">Show</span>(rplayer1);</span><br><span class="line"><span class="built_in">Show</span>(player1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用兼容性属性让你能够将基类对象初始化为派生类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(rplayer1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>要初始化player1,基类要调用构造函数的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TableTennisPlayer</span>(<span class="type">const</span> RatedPlayer &amp; );</span><br></pre></td></tr></table></figure>
<p>基类定义中没有这样的构造函数，但存在隐式复制构造函数</p>
</li>
<li><p>同样，也可以将派生类对象赋给基类对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">TableTennisPlayer player1;</span><br><span class="line">player1 = rplayer1;</span><br></pre></td></tr></table></figure>
<p>将使用隐式重载赋值运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TableTennisPlayher &amp; <span class="keyword">operator</span>=(<span class="type">const</span> TableTennisPlayher &amp; )<span class="type">const</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="13-2-继承：is-a关系"><a href="#13-2-继承：is-a关系" class="headerlink" title="13.2 继承：is-a关系"></a>13.2 继承：is-a关系</h2><ol>
<li><p>公有继承是最常用的方式，它建立一种is-a关系，新类将继承原始类的所有数据成员</p>
</li>
<li><p>公有继承不建立has-a关系，has-a关系：午餐有水果，将水果的对象作为午餐类的数据成员</p>
</li>
<li><p>公有继承不建立is-like-a关系,即律师就像鲨鱼，不应从鲨鱼类派生出律师类，继承可以在基类的基础上添加基础，但不能删除基类的属性</p>
</li>
<li><p>公有继承不建立is-implemented-as-a关系,即作为···来实现，使用数组来实现栈，不可以因为栈不是数组</p>
</li>
<li><p>所以坚持使用is-a的关系，当满足is-a的关系，就可以使用公有继承</p>
</li>
</ol>
<h2 id="13-3-多态公有继承"><a href="#13-3-多态公有继承" class="headerlink" title="13.3 多态公有继承"></a>13.3 多态公有继承</h2><ol>
<li><p>概念：同一个方法在派生类和基类中的行为是不同的即称为多态–具有多种形态</p>
</li>
<li><p>两种实现方法：<br>在派生类中重新定义基类的方法<br>使用虚方法</p>
</li>
</ol>
<h3 id="13-3-1-开发Brass类和BrassPlus类"><a href="#13-3-1-开发Brass类和BrassPlus类" class="headerlink" title="13.3.1 开发Brass类和BrassPlus类"></a>13.3.1 开发Brass类和BrassPlus类</h3><ol>
<li><p>虚方法的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrassPlus</span>:<span class="keyword">public</span> Brass </span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会在派生类中重新定义基类的方法,但函数名一样的，关键字virtual只用于类声明的方法原型中</p>
</li>
<li><p>引用类型或指针类型选择方法在继承类中的使用<br>方法没有使用virtual将根据引用类型或指针类型选择方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">dom</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">dot</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">Brass &amp; bl_ref = dom;   本应该这样定义的</span><br><span class="line">Brass &amp; b2_ref = dot;</span><br><span class="line">bl_ref.<span class="built_in">ViewAcct</span>();</span><br><span class="line">b2_ref.<span class="built_in">ViewAcct</span>();</span><br></pre></td></tr></table></figure>
<p>引用变量的类型为Brass,所以都为Brass::ViewAcct()</p>
</li>
</ol>
<p>方法使用virtual将根据引用类型或指针类型选择方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">dom</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">dot</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">Brass &amp; bl_ref = dom;   本应该这样定义的</span><br><span class="line">Brass &amp; b2_ref = dot;</span><br></pre></td></tr></table></figure>
<p>第二个是BrassPlus::ViewAcct()</p>
<ol start="3">
<li><p>可以在派生类方法中调用基类的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::ViewAcct</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Brass::<span class="built_in">ViewAcct</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;df&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该方法是虚方法，是使用作用域解析运算符来调用基类方法，而不是派生类对象来调用方法；如果不是虚方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::ViewAcct</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ViewAcct</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;df&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则不必使用作用域解析运算符</p>
</li>
<li><p>使用格式化方法setf()和precision()将浮点值的输出模式设置为定点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建指向Brass的指针数组，可以使用一个数组来表示多种类型的对象，这也是多态，Brass指针既可以指向Brass对象，也可以指向BrassPlus对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Brass * p_clients[<span class="number">4</span>];       与一般的数组定义是完全不一样的</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p_clients[i]=<span class="keyword">new</span> <span class="built_in">Brass</span>(temp,tempnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是Brass的指针数组,所以可以进行new分配内存</p>
</li>
<li><p>类对象的输入与一般的数据输入是不一样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string temp;</span><br><span class="line"><span class="type">long</span> tempnum;</span><br><span class="line"><span class="built_in">getline</span>(cin,temp);</span><br><span class="line">cin&gt;&gt;tempnum;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多态是由下述代码提供的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p_clients[i]-&gt;ViewAcct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p_clients[i]指的是指针不是值</p>
</li>
<li><p>为何需要虚构函数</p>
</li>
</ol>
<h2 id="13-4-静态联编和动态联编"><a href="#13-4-静态联编和动态联编" class="headerlink" title="13.4 静态联编和动态联编"></a>13.4 静态联编和动态联编</h2><ol>
<li>在编译过程就知道使用哪一个函数，是静态联编。因为虚函数的存在编译器不知道用户将选择哪种类型的对象，只能在程序运行的时候确定正确的虚函数方法<br>叫动态联编，总之，编译器对虚方法使用动态联编，根据对象类型将ViewAcct()关联到Brass::ViewAcct()或BrassPlus::ViewAcct()</li>
</ol>
<h3 id="13-4-1-指针和引用类型的兼容性"><a href="#13-4-1-指针和引用类型的兼容性" class="headerlink" title="13.4.1 指针和引用类型的兼容性"></a>13.4.1 指针和引用类型的兼容性</h3><ol>
<li><p>c++不允许将一种类型地址或引用赋给另一种类型的指针或引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">2.5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x;</span><br><span class="line"><span class="type">long</span> &amp; rl = x;</span><br></pre></td></tr></table></figure>
<p>但基类和派生类可以，而不必进行类型转换</p>
</li>
<li><p>虚函数的工作原理：<br>给每个对象添加一个隐藏成员，隐藏成员是一个指向函数地址数组的指针，被称为虚函数表</p>
</li>
<li><p>虚析构函数<br>析构函数应当是虚函数，即使它不执行任何操作，除非类不用做基类，析构函数不应进行delete操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">BaseClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Employee *pe = <span class="keyword">new</span> Singer;</span><br><span class="line"><span class="keyword">delete</span> pe;</span><br></pre></td></tr></table></figure>
<p>如果没有虚析构函数，delete语句将调用<del>Employer()析构函数，将释放派生类对象中的基类部分指向的内存，但不会释放新的类成员指向的内存，如果有虚析构函<br>数则先调用</del>Singer析构函数，在调用~Employer()析构函数</p>
</li>
<li><p>虚函数的参数要相同，但返回值可以不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> Dwelling &amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span>:<span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> Hovel &amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新定义将隐藏方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">long</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">两个都将被隐藏</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span>:<span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span>  <span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新定义继承的方法并不是重载，将隐藏所有的同名基类的方法</p>
</li>
</ol>
<h2 id="13-5-访问控制：protected"><a href="#13-5-访问控制：protected" class="headerlink" title="13.5 访问控制：protected"></a>13.5 访问控制：protected</h2><ol>
<li>protected与private相似，在类外只能用公有类成员来访问protected部分中的类成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">brass</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		doubloe balance;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		doubloe balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
区别在于继承方面：派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员，在派生类中与公有成员相识。例如可以编写<br>BrassPlus::Withdraw()<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(amt&lt; balance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
只有在派生类中可以这样使用，保护数据成员可以简化代码的编写工作，但又使保护数据成员balance成为公有变量，被轻易修改</li>
</ol>
<h2 id="13-6-抽象基类-ABC"><a href="#13-6-抽象基类-ABC" class="headerlink" title="13.6 抽象基类(ABC)"></a>13.6 抽象基类(ABC)</h2><ol>
<li><p>前面已经接受了简单继承和多态继承</p>
</li>
<li><p>另一种建立继承的方法：Ellipse类和Circle类有共点，可以建立拥有他们共同点的类BaseEllipse，这个类还包含Ellipse类和Circle类不的同的方法，应<br>被声明为虚函数，但至少应有一个纯虚函数</p>
</li>
<li><p>抽象函数通过使用纯虚函数来提供未实现的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseEllipse</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当类声明中包含纯虚函数时，则不能创建该类的对象，只能用做基类，因此可以从BaseEllipse类派生出Ellipse类和Circle类</p>
</li>
<li><p>Ellipse类和Circle类被称为具体类，具有相同的基类，可以用BaseEllipse指针数组同时管理这两种对象</p>
</li>
<li><p>BaseEllipse类的纯虚函数也应该定于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BaseEllipse::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	balance -= amt; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	balance -= amt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-6-1-应用ABC概念"><a href="#13-6-1-应用ABC概念" class="headerlink" title="13.6.1 应用ABC概念"></a>13.6.1 应用ABC概念</h3><ol>
<li>ABC是一种必须实施的接口，这种模式在基于组件的编程模式中很常见，每个ABC或者派生类是组件</li>
</ol>
<h2 id="13-7-继承和动态内存分配"><a href="#13-7-继承和动态内存分配" class="headerlink" title="13.7 继承和动态内存分配"></a>13.7 继承和动态内存分配</h2><h2 id="13-7-1-第一种情况：派生类不使用new"><a href="#13-7-1-第一种情况：派生类不使用new" class="headerlink" title="13.7.1 第一种情况：派生类不使用new"></a>13.7.1 第一种情况：派生类不使用new</h2><ol>
<li>基类使用动态内存分配，包含特殊方法：析构函数，复制构造函数，重载赋值运算符，而派生类不需要</li>
</ol>
<h2 id="13-7-2-第二种情况：派生类使用new"><a href="#13-7-2-第二种情况：派生类使用new" class="headerlink" title="13.7.2 第二种情况：派生类使用new"></a>13.7.2 第二种情况：派生类使用new</h2><ol>
<li>必须为派生类定义特殊方法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">派生类的析构函数：</span><br><span class="line">baseDMA::~<span class="built_in">baseDMA</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::~<span class="built_in">hasDMA</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] style;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>派生类的复制构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hasDMA::<span class="built_in">hasDMA</span>(<span class="type">const</span> hasDMA &amp;hs)</span><br><span class="line">         ：<span class="built_in">baseDMA</span>(hs)     是基类的引用可以指向派生类型</span><br><span class="line">&#123;</span><br><span class="line">	style = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(style,hs.style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>派生类的重载赋值运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hasDMA &amp; hasDMA::<span class="keyword">operator</span>=(<span class="type">const</span> hasDMA &amp;hs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;hs)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	baseDMA::<span class="keyword">operator</span>=(hs);    显示调用基类赋值运算符</span><br><span class="line">	<span class="keyword">delete</span> [] style;</span><br><span class="line">	style = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(style,hs.style);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;    对<span class="keyword">this</span>指针的返回，返回类型也是引用</span><br><span class="line">&#125;</span><br><span class="line">baseDMA::<span class="keyword">operator</span>=(hs)不可用*<span class="keyword">this</span> = hs代替不然编译器会hasDMA::<span class="keyword">operator</span>=()，从而形成递归调用</span><br></pre></td></tr></table></figure>

<h3 id="13-7-3-友元的继承"><a href="#13-7-3-友元的继承" class="headerlink" title="13.7.3 友元的继承"></a>13.7.3 友元的继承</h3><ol>
<li>hasDMA类的友元访问label和rating的方法：使用强制类型转换<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">baseDMA</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">char</span> *label;</span><br><span class="line">		<span class="type">int</span> rating;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> baseDMA &amp; rs)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; rs.rating &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> hasDMA &amp; hs)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; (<span class="type">const</span> baseDMA &amp;)hs;</span><br><span class="line">	os &lt;&lt; hs.style &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第14章-c-中的代码重用"><a href="#第14章-c-中的代码重用" class="headerlink" title="第14章 c++中的代码重用"></a>第14章 c++中的代码重用</h1><ol>
<li>可以定义一个通用的栈模板，然后创建表示int或double值栈的类</li>
</ol>
<h2 id="14-1-包含对象成员的类"><a href="#14-1-包含对象成员的类" class="headerlink" title="14.1 包含对象成员的类"></a>14.1 包含对象成员的类</h2><ol>
<li>对于考试分数，可以使用一个定长数组，这限制了数组的长度；可以使用动态内存分配的指针，并提供大量的支持代码；也可以使用动态内存分配的类表示该数组；<br>还可以在标准c++库中查找一个表示这种数据的类，自己开发这样的类一点问题也没有</li>
</ol>
<h3 id="14-1-1-valarray类简介"><a href="#14-1-1-valarray类简介" class="headerlink" title="14.1.1 valarray类简介"></a>14.1.1 valarray类简介</h3><ol>
<li><p>它支持将数组中所有元素的值相加以及在数组中找出最大和最小的值的操作，提供的算术支持比vector和array的多</p>
</li>
<li><p>几个使用其构造函数的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="type">double</span> gpa[<span class="number">5</span>] = &#123;<span class="number">3.1</span>,<span class="number">3.5</span>,<span class="number">3.8</span>,<span class="number">2.9</span>,<span class="number">3.3</span>&#125;;</span><br><span class="line">valarray &lt;<span class="type">double</span>&gt; v1;</span><br><span class="line">valarray &lt;<span class="type">int</span>&gt; <span class="built_in">v2</span>(<span class="number">8</span>);  指定长度的空数组</span><br><span class="line">valarray &lt;<span class="type">int</span>&gt; <span class="built_in">v3</span>(<span class="number">10</span>,<span class="number">8</span>);</span><br><span class="line">valarray &lt;<span class="type">double</span>&gt; <span class="built_in">v4</span>(gpa,<span class="number">4</span>);</span><br><span class="line">valarray &lt;<span class="type">int</span>&gt; v5 = &#123;<span class="number">12</span>,<span class="number">32</span>,<span class="number">34</span>&#125;;    初始化列表</span><br></pre></td></tr></table></figure>
<p>先有长度再有数值，长度放后面</p>
</li>
<li><p>这个类的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()   返回数组的长度</span><br><span class="line"><span class="built_in">length</span>()     返回字符串的长度</span><br><span class="line"><span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">min</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-1-2-Student类的设计"><a href="#14-1-2-Student类的设计" class="headerlink" title="14.1.2 Student类的设计"></a>14.1.2 Student类的设计</h3><ol>
<li><p>可以从string和valarray这两个类，派生出Student类，这是多重公有继承(一种is-a关系),但这里并不合适，学生类与这些类不是is-a的关系</p>
</li>
<li><p>模板类一般使用自定义的形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	privatef:</span><br><span class="line">		<span class="keyword">typedef</span> std::valarray&lt;<span class="type">double</span>&gt; ArrayDb;     也在<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放在私有部分意味着可以在Student类的实现中使用它，当在Student类外面不能使用</p>
</li>
<li><p>在Student类中，可以直接使用string和valarray这两个类的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Student</span>():<span class="built_in">name</span>(<span class="string">&quot;Null Student&quot;</span>),<span class="built_in">scores</span>()&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">const</span> string &amp; s)</span>:name(s),scores()&#123;</span>&#125;</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">int</span> n)</span>:name(<span class="string">&quot;Nully&quot;</span>),scores(n)&#123;</span>&#125;</span><br><span class="line">		<span class="built_in">Studeent</span>(<span class="type">const</span> string &amp; s,<span class="type">int</span> n):<span class="built_in">name</span>(s),<span class="built_in">scores</span>(n)&#123;&#125;</span><br><span class="line">		<span class="built_in">Studeent</span>(<span class="type">const</span> string &amp; s,<span class="type">const</span> ArrayDb &amp; a):<span class="built_in">name</span>(s),<span class="built_in">scores</span>(a)&#123;&#125;</span><br><span class="line">		<span class="built_in">Studeent</span>(<span class="type">const</span> <span class="type">char</span> *str,<span class="type">const</span> <span class="type">double</span> *pd,<span class="type">int</span> n):<span class="built_in">name</span>(str),<span class="built_in">scores</span>(pd,n)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化被包含的对象时，构造函数将使用成员名，因为初始化的是成员对象，而不是继承的对象</p>
</li>
<li><p>在构造函数有一个参数时，考虑隐式转换函数，没有使用explicit可以写如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> n):<span class="built_in">name</span>(<span class="string">&quot;Nully&quot;</span>),<span class="built_in">scores</span>(n)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">doh</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>将创建一个Nully,5个元素的doh对象，但着一般是不允许的</p>
</li>
</ol>
<p>如果使用了explicit：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">int</span> n)</span>:name(<span class="string">&quot;Nully&quot;</span>),scores(n)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">doh</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>将会发生错误</p>
<ol start="5">
<li><p>初始化顺序：它们被声明的顺序，而不是它们在初始化列表中的顺序  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Studeent</span>(<span class="type">const</span> string &amp; s,<span class="type">int</span> n):<span class="built_in">scores</span>(n),<span class="built_in">name</span>(s)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>先初始化name成员而不是scores成员，在一个成员的值作为另一个成员的初始化表达式的一部分使，初始化的顺序就非常重要</p>
</li>
<li><p>stu.name是一个string对象，所以调用函数operator&lt;&lt;(ostream &amp;,const string &amp;)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="type">const</span> Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">	os&lt;&lt;stu.name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scores.<span class="built_in">sum</span>()</span><br><span class="line">scores.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>
<p>可以使用scores类的方法，同样该函数也可以实现valarray的输出，但scores没有&lt;&lt;重载运算符，因此，Student类定义了一个私有辅助方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp; <span class="title">Student::arr_out</span><span class="params">(ostram &amp; os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> lim = scores.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span>(lim&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lim;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			os&lt;&lt;scores[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">4</span>) os&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">5</span>!=<span class="number">0</span>)</span><br><span class="line">			os&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="type">const</span> Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">	os&lt;&lt;stu.name&lt;&lt;endl;</span><br><span class="line">	stu.<span class="built_in">arr_out</span>(os);</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> &amp; Student::<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> scores[i];    引用返回的更快</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在包含main()函数的文件中一般还自定义函数</p>
</li>
</ol>
<h2 id="14-2-私有继承"><a href="#14-2-私有继承" class="headerlink" title="14.2 私有继承"></a>14.2 私有继承</h2><ol>
<li><p>另一种实现has-a关系的途径–私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，可以在派生类的成员函数中使用它们，<br>即只能在派生类的方法中使用基类的方法,has-a是使用接口，与包含的特性一致,也是将另外两个类的对象做为Student的成员，is-a是使用实现</p>
</li>
<li><p>访问限定符的默认类型是私有private</p>
</li>
<li><p>Student类应从两个类派生而来,使用多个基类的继承被称为多重继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">private</span> string,<span class="keyword">private</span> valarray&lt;<span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>包含与私有继承的区别：包含提供了两个对象成员，而私有继承提供了两个无名的子对象成员</p>
</li>
</ol>
<h3 id="14-2-1-初始化基类组件"><a href="#14-2-1-初始化基类组件" class="headerlink" title="14.2.1 初始化基类组件"></a>14.2.1 初始化基类组件</h3><ol>
<li><p>有隐式地继承组件和显式地包含组件</p>
</li>
<li><p>私有继承类的构造函数将使用类名来初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">const</span> <span class="type">double</span> * pd,<span class="type">int</span> n) ：<span class="built_in">string</span>(str),<span class="built_in">ArrayDb</span>(pd,n) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-2-2-访问基类的方法"><a href="#14-2-2-访问基类的方法" class="headerlink" title="14.2.2 访问基类的方法"></a>14.2.2 访问基类的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Student::Average</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ArrayDb::<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ArrayDb::<span class="built_in">sum</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有确定对象时可以使用类名和作用域解析运算符来调用基类的方法，但函数的作用域与方法的作用域不一致时，就使用解析运算符</p>
<h3 id="14-2-3-访问基类对象"><a href="#14-2-3-访问基类对象" class="headerlink" title="14.2.3 访问基类对象"></a>14.2.3 访问基类对象</h3><ol>
<li>使用强制类型转换，将Student对象转换为string对象，*this表示Student对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp; <span class="title">Student::Name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">const</span> string &amp;) *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为避免调用构造函数创建新的对象，可使用强制类型转换来创建一个引用</li>
</ol>
<h3 id="14-2-3-访问基类的友元函数"><a href="#14-2-3-访问基类的友元函数" class="headerlink" title="14.2.3 访问基类的友元函数"></a>14.2.3 访问基类的友元函数</h3><p>用类名显式地限定函数名不合适于友元函数，可以使用显示地转换为基类来调用正确的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="type">const</span> Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">	os&lt;&lt;(<span class="type">const</span> string &amp;)stu;      不修改的强制类型转换</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">cout&lt;&lt;plato;    调用时并不是输出Student类的全部成员，而只是string要进入函数里面去看过程</span><br></pre></td></tr></table></figure>

<h3 id="14-2-4-使用修改后的Student类"><a href="#14-2-4-使用修改后的Student类" class="headerlink" title="14.2.4 使用修改后的Student类"></a>14.2.4 使用修改后的Student类</h3><ol>
<li><p>两个版本的Student类的公有接口(方法)完全相同，因此可以使用同一个程序测试它们</p>
</li>
<li><p>使用包含比私有继承好，如果某个类需要3个string对象，可以使用包含声明3个独立的string成员，如果新类需要访问原有类的保护成员，<br>或需要重新定义虚函数，则应使用私有继承</p>
</li>
</ol>
<h3 id="14-2-5-保护继承"><a href="#14-2-5-保护继承" class="headerlink" title="14.2.5 保护继承"></a>14.2.5 保护继承</h3><p>第三代类体现出保护继承和私有继承的区别</p>
<h3 id="14-2-6-使用using重新定义访问权限"><a href="#14-2-6-使用using重新定义访问权限" class="headerlink" title="14.2.6 使用using重新定义访问权限"></a>14.2.6 使用using重新定义访问权限</h3><p>1.在派生类类外调用基类对象的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Student::sum</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> valarray&lt;<span class="type">double</span>&gt;::<span class="built_in">sum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用一个using声明来指出派生类可以使用特定的基类成员，即使采用的是私有派生<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">private</span> string,<span class="keyword">private</span> valarray&lt;<span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">using</span> valarray&lt;<span class="type">double</span>&gt;::min;</span><br><span class="line">		<span class="keyword">using</span> valarray&lt;<span class="type">double</span>&gt;::max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stu.min;  可以这样使用</span><br></pre></td></tr></table></figure>
using声明只使用成员名——没有圆括号，函数特征标和返回类型</li>
</ol>
<h2 id="14-3-多重继承"><a href="#14-3-多重继承" class="headerlink" title="14.3 多重继承"></a>14.3 多重继承</h2><h2 id="14-4-类模板"><a href="#14-4-类模板" class="headerlink" title="14.4 类模板"></a>14.4 类模板</h2><ol>
<li>不如编写一个泛型栈，然后将具体的类型作为参数传递给这个类，这样就可以使用不同类型的栈，例如int栈和string栈</li>
</ol>
<h3 id="14-4-1-定义模板类"><a href="#14-4-1-定义模板类" class="headerlink" title="14.4.1 定义模板类"></a>14.4.1 定义模板类</h3><ol start="2">
<li>templat为函数名，尖括号中的内容相当于函数的参数列表，class&#x2F;typename看作是变量的类型名，Type看作变量的名称<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br></pre></td></tr></table></figure>
可以使用模板成员函数替换原有类的类方法。每个函数头都将以相同模板声明打头</li>
</ol>
<p>应改为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Item items[MAX];--&gt;Type items[MAX];</span><br><span class="line">Stack::--&gt;Stack&lt;type&gt;::       作用域解析符与类名也要改</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;Type&gt;::<span class="built_in">isEmpty</span>(<span class="type">const</span> Type &amp; item) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果在类声明中定义了方法(内联定义)，则可以省略模板前缀和类限定符</p>
<ol start="3">
<li>不能将模板成员函数放在独立的实现文件中，由于模板不是函数，它们不能单独编译</li>
</ol>
<h3 id="14-4-2-使用类模板"><a href="#14-4-2-使用类模板" class="headerlink" title="14.4.2 使用类模板"></a>14.4.2 使用类模板</h3><ol>
<li>使用的算法必须与类型一致，一般int与string是可以用在同一个模板类中的，string栈与指针栈有相同的功能，但不能用在同一个模板类中</li>
</ol>
<h3 id="14-4-3-指针栈-x2F-指针模板"><a href="#14-4-3-指针栈-x2F-指针模板" class="headerlink" title="14.4.3 指针栈&#x2F;指针模板"></a>14.4.3 指针栈&#x2F;指针模板</h3><ol>
<li><p>使用一个指针数组，其中每个指针都指向不同的字符串，用使用动态数组</p>
</li>
<li><p>返回类型为类时也要使用Stack<Type></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Stack &amp; st);   这是缩写，只能在类中使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> Stack &amp; st) &#123;&#125;   </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-4-4-数组模板示例和非类型参数"><a href="#14-4-4-数组模板示例和非类型参数" class="headerlink" title="14.4.4 数组模板示例和非类型参数"></a>14.4.4 数组模板示例和非类型参数</h3><ol>
<li><p>模板常用作容器类，主要是为容器类提供可重用代码</p>
</li>
<li><p>数组模板的成员是数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br></pre></td></tr></table></figure>
<p>为类型参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayTP</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T ar[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为非类型或表达式参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">double</span>,<span class="number">12</span>&gt;eqqweights;</span><br></pre></td></tr></table></figure>
<p>编译器将使用double替换T，使用12替换n</p>
</li>
<li><p>表达式参数可以是整型，枚举，引用或指针，因此，double m是不合法的，但double *rm是合法的<br>模板代码不能修改参数的值，也不能使用参数的地址，如n++和&amp;n<br>用作参数的值必须是常量表达式</p>
</li>
<li><p>介绍一个允许指定数组大小的简单数组模板：<br>第一种：使用动态数组和构造函数参数来提供元素数目<br>第二种：使用模板参数来提供常规数组的大小，array就是这样做的</p>
</li>
<li><p>表达式参数方法的缺点：每种数组大小都将生成自己的模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">double</span>,<span class="number">12</span>&gt; eqqweights;</span><br><span class="line">ArrayTP&lt;<span class="type">double</span>,<span class="number">13</span>&gt; donuts;</span><br></pre></td></tr></table></figure>
<p>将生成两个独立的类声明</p>
</li>
<li><p>使用动态数组和构造函数参数的方法的优点：更通用，数组大小是作为类成员存储在定义中的，可以将一种大小的数组赋给另一种大小的数组</p>
</li>
</ol>
<h3 id="14-4-4-模板的多功能性"><a href="#14-4-4-模板的多功能性" class="headerlink" title="14.4.4 模板的多功能性"></a>14.4.4 模板的多功能性</h3><ol>
<li><p>模板类可用作基类，也可用作组件类，还可用作其他模板的类型参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T entry;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrowArray</span> : <span class="keyword">public</span> Array&lt;Type&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">	Array&lt;Tp&gt; ar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array&lt; Stack&lt;<span class="type">int</span>&gt; &gt; asi;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归使用模板：对于前面的数组模板定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt; ArrayTP&lt;<span class="type">int</span>,<span class="number">5</span>&gt; <span class="number">10</span>&gt; twodee;</span><br></pre></td></tr></table></figure>
<p>这使得twodee是一个包含10个元素的数组，其中每个元素都是一个包含5个int元素的数组，与之等价的常规数组声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> towdee[<span class="number">10</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>即使没有这样的函数也可以这样使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		twodee[i][j]=<span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制输出宽度的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">width</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用多个类型参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Pair&lt;string,<span class="type">int</span>&gt;</span><br></pre></td></tr></table></figure>
<p>模板类的类名是Pair&lt;string,int&gt;，而不是Pair</p>
</li>
<li><p>默认类型模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Top&#123;...&#125;</span><br><span class="line">Top&lt;<span class="type">double</span>&gt; m1;    T2为<span class="type">int</span>型</span><br><span class="line">Top&lt;<span class="type">double</span> <span class="type">double</span>&gt; m2;  T2为<span class="type">double</span>型</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-4-6-模板的具体化"><a href="#14-4-6-模板的具体化" class="headerlink" title="14.4.6 模板的具体化"></a>14.4.6 模板的具体化</h3><ol>
<li><p>隐式实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">int</span>,<span class="number">100</span>&gt; stuff;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显式实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">ArrayTP</span>&lt;string,<span class="number">100</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>之后将生成一个类</p>
</li>
<li><p>显式具体化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortedArray</span> &#123;....&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设模板使用&gt;运算符来对值进行比较，对于数字，这管用;如果T是const char *，将不管用，这将要求类定义使用strcmp()，而不是&gt;来对值进行比较，这种情况下<br>可以提供一个显式模板具体化，即为一种具体类型定义的模板，而不是泛型定义的模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">class</span> <span class="title class_">SortedArray</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;</span><br><span class="line"></span><br><span class="line">SortedArray&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line">SortedArray&lt;<span class="type">const</span> <span class="type">char</span> *&gt;dates;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>4.部分具体化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Feed</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>*&gt; <span class="keyword">class</span> <span class="title class_">Feed</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">Feed&lt;<span class="type">char</span>&gt; fb1;</span><br><span class="line">Feed&lt;<span class="type">char</span> *&gt; fb2;</span><br></pre></td></tr></table></figure>
<p>第二个声明使用通用模板时，将T转换为char *类型，如果是部分具体化，T将转换为char</p>
<ol start="5">
<li>模板该考虑的类型：常规类型，char，char *a， string，ArrayTP，ArrayTP&lt;int,5&gt;</li>
</ol>
<h3 id="14-4-7-成员模板"><a href="#14-4-7-成员模板" class="headerlink" title="14.4.7 成员模板"></a>14.4.7 成员模板</h3><p>模板可用作结构，类或模板类的成员</p>
<ol>
<li>在beta模板外定义hold类和blah方法，模板是嵌套的，还必须指出hold和blab是beta<T>类的成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V&gt;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">beta</span>&lt;T&gt;::hold &#123;...&#125;</span><br></pre></td></tr></table></figure>
而不能使用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> V&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-4-8-将模板用作参数"><a href="#14-4-8-将模板用作参数" class="headerlink" title="14.4.8 将模板用作参数"></a>14.4.8 将模板用作参数</h3><p>是可以将类进行更改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Thing</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crab</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Thing&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Crab&lt;Stack&gt; nebula;</span><br></pre></td></tr></table></figure>

<h3 id="14-4-8-模板类和友元"><a href="#14-4-8-模板类和友元" class="headerlink" title="14.4.8 模板类和友元"></a>14.4.8 模板类和友元</h3><h3 id="14-4-8-模板别名"><a href="#14-4-8-模板别名" class="headerlink" title="14.4.8 模板别名"></a>14.4.8 模板别名</h3><h1 id="第15章-友元、异常和其他"><a href="#第15章-友元、异常和其他" class="headerlink" title="第15章 友元、异常和其他"></a>第15章 友元、异常和其他</h1><h2 id="15-1-友元"><a href="#15-1-友元" class="headerlink" title="15.1 友元"></a>15.1 友元</h2><p>友元类的所有方法都可以访问原始类的私有成员和保护成员</p>
<h3 id="15-1-1-友元类"><a href="#15-1-1-友元类" class="headerlink" title="15.1.1 友元类"></a>15.1.1 友元类</h3><ol>
<li>编写一个模拟电视机和遥控器的简单程序，遥控器可以改变电视机的状态，而不是is-a,has-a的关系，因此将Romote类作为Tv类的一个友元，必须先定义Tv<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Remote</span>;</span><br><span class="line">		...    </span><br><span class="line">&#125;;   放在公有位置</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">volup</span><span class="params">(Tv &amp; t)</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">volup</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
满足的是一种先有电视再有遥控器的关系</li>
</ol>
<h3 id="15-1-2-友元成员函数"><a href="#15-1-2-友元成员函数" class="headerlink" title="15.1.2 友元成员函数"></a>15.1.2 友元成员函数</h3><ol>
<li><p>让特定是类成员成为另一个类的友元，而不必让整个类成为友元</p>
</li>
<li><p>让Remote::set_chan()成为Tv类的友元的方法是，在Tv类声明中将其声明为友元,set_chan()使用的是Tv类的成员，所以必须是友元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span></span>;</span><br><span class="line">		...    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>必须使用前向声明(forward declaration)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Remote声明中只包含方法声明，并将实际的定义放在Tv类之后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_mode</span><span class="params">(Tv &amp;t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span> </span>&#123;t.channel = c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Remote::set_mode</span><span class="params">(Tv &amp;t)</span> </span>&#123;t.<span class="built_in">set_mode</span>();&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="15-1-3-其他友元关系"><a href="#15-1-3-其他友元关系" class="headerlink" title="15.1.3 其他友元关系"></a>15.1.3 其他友元关系</h3><h3 id="15-1-4-共同的友元"><a href="#15-1-4-共同的友元" class="headerlink" title="15.1.4 共同的友元"></a>15.1.4 共同的友元</h3><h2 id="15-2-嵌套类"><a href="#15-2-嵌套类" class="headerlink" title="15.2 嵌套类"></a>15.2 嵌套类</h2><ol>
<li><p>对类进行嵌套与包含并不同，包含意味着将类对象作为另一个类成员，而对类进行嵌套不创建类成员，而是定义了一种类型程序的其他部分</p>
</li>
<li><p>在方法文件中定义构造函数，则定义必须指出Node类是在Queue类中定义的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue::Node::<span class="built_in">Node</span>(<span class="type">const</span> Item &amp;i) : <span class="built_in">item</span>(i),<span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="15-2-1-嵌套类和访问权限"><a href="#15-2-1-嵌套类和访问权限" class="headerlink" title="15.2.1 嵌套类和访问权限"></a>15.2.1 嵌套类和访问权限</h2><ol>
<li><p>类的默认访问权限是私有的，Queue队列类是嵌套类</p>
</li>
<li><p>嵌套类是在另一个类的私有部分声明的，只有类成员可以使用对象和指向嵌套类对象的指针，派生类和外部世界不知道它的存在<br>如果是保护部分声明的，派生类可见并且可以创建这种类型的对象，但对于外部是不可见的<br>如果是公有部分声明的，允许派生类和外部世界使用它<br>嵌套结构和枚举的作用也是相同的</p>
</li>
<li><p>有一个失业的教练，他不属于任何球队，可以在Team类的外面创建Coach对象,是这种关系的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Team</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Coach</span> &#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Team::Coach forhire;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Queue类对象只能显示地访问Node节点类对象的公有成员，因为Node类的所有成员都被声明为公有的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Item item;</span><br><span class="line">		Node *next:</span><br><span class="line">		<span class="built_in">Node</span>(<span class="type">const</span> Item &amp;i) : <span class="built_in">item</span>(i),<span class="built_in">next</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	Node *front;</span><br><span class="line">	Node *rear;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="15-2-2-模板中的嵌套"><a href="#15-2-2-模板中的嵌套" class="headerlink" title="15.2.2 模板中的嵌套"></a>15.2.2 模板中的嵌套</h2><p>Queue类定义转换为模板，是一种容器类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueueTp&lt;<span class="type">double</span>&gt; dq;</span><br><span class="line"></span><br><span class="line"><span class="function">QueueTp&lt;string&gt; <span class="title">cs</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">//可以连续输入5次</span></span><br><span class="line">string temp;</span><br><span class="line"><span class="keyword">while</span>(!cs.<span class="built_in">isfull</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">getline</span>(cin,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Node被定义成用于存储double的值</p>
<h2 id="15-3异常"><a href="#15-3异常" class="headerlink" title="15.3异常"></a>15.3异常</h2><h2 id="15-4-RTTI"><a href="#15-4-RTTI" class="headerlink" title="15.4 RTTI"></a>15.4 RTTI</h2><ol>
<li>RTTI是运行阶段类型识别的简称，旨在为程序在运行阶段确定对象的类型提供一种标准方式</li>
</ol>
<h2 id="15-4-1-RTTI的用途"><a href="#15-4-1-RTTI的用途" class="headerlink" title="15.4.1 RTTI的用途"></a>15.4.1 RTTI的用途</h2><p>有一个类层次结构，其中的类都是从同一个基类派生而来的，则可以让基类指针指向其中任何一个类的对象</p>
<h2 id="15-4-2-RTTI的工作原理"><a href="#15-4-2-RTTI的工作原理" class="headerlink" title="15.4.2 RTTI的工作原理"></a>15.4.2 RTTI的工作原理</h2><ol>
<li><p>RTTI只适用于包含虚函数的类，是用于基类指针与派生类的转换</p>
</li>
<li><p>dynamic_cast运算符，使一个基类指针指向一个派生类的指针，如果失败将空指针赋给指针，使得进行向上转换(is-a的关系)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grand</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Supeerd</span> : <span class="keyword">public</span> Grand;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Magnificent</span> : <span class="keyword">public</span> Supeerd;</span><br><span class="line"></span><br><span class="line">Grand *pg = <span class="keyword">new</span> Grand;</span><br><span class="line">Superd *ps = <span class="keyword">new</span> Supeerd;</span><br><span class="line"></span><br><span class="line">pg = <span class="built_in">GetOne</span>();</span><br><span class="line">ps = <span class="built_in">dynamic_cast</span>&lt;Superd *&gt;(pg);</span><br><span class="line">ps-&gt;<span class="built_in">Say</span>();</span><br></pre></td></tr></table></figure>
<p>这样ps可以在pg的基础上使用Say()成员(Grand类并没有这个函数，Superd有这个函数)</p>
</li>
<li><p>typeid运算符和type_info类</p>
</li>
</ol>
<h2 id="15-5-类型转换运算符"><a href="#15-5-类型转换运算符" class="headerlink" title="15.5 类型转换运算符"></a>15.5 类型转换运算符</h2><ol>
<li><p>在c语言中都是允许的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> data[<span class="number">200</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Junk</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> junk[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Data d = &#123;<span class="number">2.5e33</span>,<span class="number">3.5e-19</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *pch = (<span class="type">char</span> *) (&amp;d);  <span class="comment">//可以将结构里的成员类型发生转换，转换为字符串</span></span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">char</span> (&amp;d);       <span class="comment">//将地址转换为字符</span></span><br><span class="line">Junk *pj = (Junk *) (&amp;d);  <span class="comment">//将结构里的成员类型发生转换，转换为整型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>const_cast运算符将改变值为const或volatile，类型的其他方面不能被修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">High bar;</span><br><span class="line"><span class="type">const</span> High *pbar = &amp;bar;</span><br><span class="line">High *pb = <span class="built_in">const_cast</span>&lt;High *&gt;(pbar);</span><br></pre></td></tr></table></figure>
</li>
<li><p>static_cast运算符是进行向下转换的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">High bar;</span><br><span class="line">Low blow;</span><br><span class="line"></span><br><span class="line">Low *pl = <span class="built_in">static_cast</span>&lt;Low *&gt;(&amp;bar);</span><br></pre></td></tr></table></figure>
</li>
<li><p>reinterpret_cast运算符将进行重新解释，将一种类型转换为另一种类型</p>
</li>
</ol>
<h1 id="第16章-string类和标准模板库"><a href="#第16章-string类和标准模板库" class="headerlink" title="第16章 string类和标准模板库"></a>第16章 string类和标准模板库</h1><ol>
<li>STL编程是一种泛型编程，STL(标准模板库)是用于处理各种容器对象的模板</li>
</ol>
<h2 id="16-1-string类"><a href="#16-1-string类" class="headerlink" title="16.1 string类"></a>16.1 string类</h2><ol>
<li>头文件string.h和cstring支持对c风格字符串进行操纵，不支持string类</li>
</ol>
<h3 id="16-1-1-构造字符串"><a href="#16-1-1-构造字符串" class="headerlink" title="16.1.1 构造字符串"></a>16.1.1 构造字符串</h3><ol>
<li>string类的构造函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">one</span><span class="params">(<span class="string">&quot;Lottery&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">two</span><span class="params">(<span class="number">20</span>,<span class="string">&#x27;s&#x27;</span>)</span></span>;   <span class="comment">//初始化为ssssssssssssssssss</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">three</span><span class="params">(one)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> alsfs[<span class="number">20</span>] = <span class="string">&quot;Alsfsaell&quot;</span>;</span><br><span class="line">one += <span class="string">&quot;oops&quot;</span>;    <span class="comment">//+=运算符被多次重载，可以使用C-风格字符串或char值</span></span><br><span class="line">one += alsfs;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">four</span><span class="params">(one,<span class="number">3</span>,<span class="number">6</span>)</span></span>;   <span class="comment">//从one中取出从第3个到第6个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> alls[<span class="number">20</span>] = <span class="string">&quot;Allwell&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">five</span><span class="params">(alls,<span class="number">20</span>)</span></span>;   <span class="comment">//取前20字母</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">six</span><span class="params">(alls+<span class="number">2</span>,alls+<span class="number">4</span>)</span></span>;  <span class="comment">//取alls[2]到alls[4]</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">seven</span><span class="params">(&amp;five[<span class="number">2</span>],&amp;five[<span class="number">4</span>])</span></span>;  <span class="comment">//取five[2]到five[4]</span></span><br><span class="line">不可<span class="function">string <span class="title">seven</span><span class="params">(five+<span class="number">2</span>,five+<span class="number">4</span>)</span></span>;  <span class="comment">//five不是指针地址</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure></li>
<li>C++11 新增的构造函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> (string &amp;&amp; str);  <span class="comment">//移动构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> (initializer_list&lt;<span class="type">char</span>&gt; il);  <span class="comment">//列表初始化</span></span><br><span class="line">string piano_man = &#123;<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="16-1-2-string类输入"><a href="#16-1-2-string类输入" class="headerlink" title="16.1.2 string类输入"></a>16.1.2 string类输入</h3><ol>
<li><p>C-风格字符串的输入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> info[<span class="number">100</span>];</span><br><span class="line">cin &gt;&gt; info;</span><br><span class="line">cin.<span class="built_in">getline</span>(info,<span class="number">100</span>);</span><br><span class="line">cin.<span class="built_in">get</span>(info,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>string对象,可以自动调整对象的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string stuff;</span><br><span class="line">cin &gt;&gt; stuff;</span><br><span class="line"><span class="built_in">getline</span>(cin,stuff);</span><br><span class="line"><span class="built_in">getline</span>(cin,stuff[<span class="number">2</span>]);  <span class="comment">//可以这两种使用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>两个版本都有一个可选参数，用于指定使用哪个字符来确定输入的边界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(info,<span class="number">100</span>,<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"><span class="built_in">getline</span>(stuff,<span class="string">&#x27;:&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>string对象输入的限制<br>1.string对象的最大允许长度，由常量string::npos指定，通常最大值为unsigned int,如果你将整个文件的内容读取到单个string对象中，这是一个限制</p>
</li>
</ol>
<h3 id="16-1-3-使用字符串"><a href="#16-1-3-使用字符串" class="headerlink" title="16.1.3  使用字符串"></a>16.1.3  使用字符串</h3><ol>
<li><p>length()成员来自string类，而size()是为STL提供的，可以计算数组的大小</p>
</li>
<li><p>成员函数find()方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">find</span><span class="params">(<span class="type">char</span> c,size_type pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//从pos开始查找字符c，找到返回索引</span></span><br><span class="line"><span class="function">size_type <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s,size_type pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//从pos开始查找字符串s</span></span><br><span class="line"><span class="function">size_type <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str,size_type pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//从pos开始查找字符串str</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字符串的内容</p>
</li>
<li><p>capacity()返回当前分配给字符串的内存块的大小，resize()能够请求内存块的最小长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string stuff;</span><br><span class="line">stuff.<span class="built_in">resize</span>(<span class="number">10</span>);  <span class="comment">//分配10个字符的内存</span></span><br><span class="line"><span class="type">int</span> n = stuff.<span class="built_in">capacity</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="16-2-智能指针模板类"><a href="#16-2-智能指针模板类" class="headerlink" title="16.2 智能指针模板类"></a>16.2 智能指针模板类</h2><ol>
<li><p>智能指针定义了类似于指针的类对象，可以帮助管理动态内存分配的智能指针模板，将new获得的地址赋给这种对象</p>
</li>
<li><p>ps是一个常规指针，不是一个类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string* ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="16-2-1-使用智能指针"><a href="#16-2-1-使用智能指针" class="headerlink" title="16.2.1 使用智能指针"></a>16.2.1 使用智能指针</h3><ol>
<li><p>必须包含头文件<memory></p>
</li>
<li><p>模板auto_ptr，unique_ptr，shared_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="built_in">auto_ptr</span>(auto_ptr&amp; rhs);</span><br><span class="line">	auto_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&amp; rhs);</span><br><span class="line">	~<span class="built_in">auto_ptr</span>();</span><br><span class="line">	X&amp; <span class="keyword">operator</span>*() <span class="type">const</span>;</span><br><span class="line">	X* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	X* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(s))</span></span>;</span><br><span class="line">str = *p1;</span><br><span class="line"></span><br><span class="line">p1-&gt;<span class="built_in">find</span>();</span><br></pre></td></tr></table></figure>
<p>new string是new返回的指针，p1可以使用string的成员函数</p>
</li>
<li><p>每一个智能指针都放在代码块中，当离开作用域时，指针自动释放</p>
</li>
<li><p>auto_ptr放弃对象的所有权，变成空指针，unique_ptr放弃对象所有权，shared_ptr共享对象所有权</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(s))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;  <span class="comment">//放弃p1的所有权</span></span><br><span class="line">p2 = p1;  <span class="comment">//放弃p2的所有权，p1变为空指针，是不被允许的,unique_ptr这样做会直接编译出错</span></span><br><span class="line"></span><br><span class="line">shared_ptr&lt;string&gt; p3;</span><br><span class="line">p3 = p1;  <span class="comment">//p1和p3指向同一个对象，p1和p3共享对象的所有权</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用new分配内存时，才能使用auto_ptr和shared_ptr，使用new[]时，使用unique_ptr</p>
</li>
</ol>
<h3 id="16-2-3-unique-ptr优于auto-ptr"><a href="#16-2-3-unique-ptr优于auto-ptr" class="headerlink" title="16.2.3 unique_ptr优于auto_ptr"></a>16.2.3 unique_ptr优于auto_ptr</h3><ol>
<li>函数返回的临时unique_ptr会被销毁<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">demo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;string&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> string(s))</span></span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;string&gt; p1;</span><br><span class="line">p1 = <span class="built_in">demo</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//编译出错，unique_ptr不能被赋值</span></span><br><span class="line"></span><br><span class="line">unique_ptr&lt;string&gt; p3；</span><br><span class="line">p3 =  <span class="built_in">unique_ter</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>));  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
不会编译出错</li>
</ol>
<h3 id="16-2-4-选择智能指针"><a href="#16-2-4-选择智能指针" class="headerlink" title="16.2.4 选择智能指针"></a>16.2.4 选择智能指针</h3><ol>
<li><p>选择shared_ptr的情况：<br>1.有一个指针数组，并使用一些辅助指针来标识特定的元素<br>2.两个对象包含都指向第三个对象的指针<br>3.STL容器包含指针</p>
</li>
<li><p>STL算法都支持赋值和复制操作，可用于shared_ptr，只要不调用将一个unique_ptr复制和赋值给另一个的方法或算法，但不能用于unique_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;unique_ptr&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vp</span>(size);</span><br><span class="line">vp.<span class="built_in">push_back</span>(unique_ptr&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure>
<p>push_back()调用没有问题，因为它返回一个临时unique_ptr，被赋给vp中的一个unique_ptr</p>
</li>
<li><p>unique_ptr为右值时，可将其赋给dhared_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>shared_ptr包含一个显示构造函数，可将右值unique_ptr转换为shared_ptr</p>
</li>
</ol>
<h2 id="16-3-标准模板库"><a href="#16-3-标准模板库" class="headerlink" title="16.3 标准模板库"></a>16.3 标准模板库</h2><ol>
<li><p>迭代器能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针</p>
</li>
<li><p>容器：数组，队列，链表，是选择一种能存储多种数据类型的数据类型成为容器</p>
</li>
<li><p>操作：搜索，排列和随机排列,适用于所有容器类的非成员函数，省去了大量重复的工作</p>
</li>
<li><p>STL不是面向对象编程，而是一种不同的编程模式——泛型编程</p>
</li>
<li><p>数学矢量与计算矢量不一样</p>
</li>
<li><p>能够分配容器的对象大小的容器，都使用了动态内存分配</p>
</li>
</ol>
<h3 id="16-3-1-模板类vector"><a href="#16-3-1-模板类vector" class="headerlink" title="16.3.1 模板类vector"></a>16.3.1 模板类vector</h3><ol>
<li><p>分配器：管理内存分配和释放的类</p>
</li>
<li><p>各种STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vectorr&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类使用new和delete来分配和释放内存， allocator<T>为分配器</p>
</li>
</ol>
<h3 id="16-3-2-可执行的操作"><a href="#16-3-2-可执行的操作" class="headerlink" title="16.3.2 可执行的操作"></a>16.3.2 可执行的操作</h3><ol>
<li><p>所有的STL容器都提供了一些基本方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">swap</span>()交换对象的内容</span><br><span class="line"><span class="built_in">begin</span>()返回一个指向容器中第一个元素</span><br><span class="line"><span class="built_in">end</span>()超过容器尾的迭代器</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器解除引用和递增</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>*()返回指向当前元素的指针</span><br><span class="line"><span class="keyword">operator</span>++()递增迭代器</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.每个容器类都定义了一个合适的迭代器，该迭代器是一个名为iterator的模板类，作用域为整个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pd = scores.<span class="built_in">begin</span>(); <span class="comment">//C++11自动类型推断</span></span><br></pre></td></tr></table></figure>
<p>声明了一个迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line">pd = scores.<span class="built_in">begin</span>();</span><br><span class="line">*pd = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>一般带有指针的名字都会有指针的性质，只不过在取地址这里有点不一样</p>
</li>
<li><p>迭代器遍历容器内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(pd = scores.<span class="built_in">begin</span>();pd!=scores.<span class="built_in">end</span>();pd++)</span><br></pre></td></tr></table></figure>
</li>
<li><p>vector类的才有的push_back()，在矢量末尾添加元素,它将负责内存管理，增加矢量的长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">scores.<span class="built_in">push_back</span>(<span class="number">100</span>);</span><br><span class="line">scores.<span class="built_in">push_back</span>(a);</span><br></pre></td></tr></table></figure>
<p>erase()方法删除矢量中给定区间的元素</p>
</li>
<li><p>vector提供了随机访问功能，因此可以有begin()+2操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.<span class="built_in">erase</span>(scores.<span class="built_in">begin</span>(),scores.<span class="built_in">begin</span>()+<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>insert()方法将元素插入到矢量中的指定位置，该区间是另一个容器对象的一部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; old_v;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; new_v;</span><br><span class="line">...</span><br><span class="line">old_v.<span class="built_in">insert</span>(old_v.<span class="built_in">begin</span>()+<span class="number">2</span>,new_v.<span class="built_in">begin</span>(),new_v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>swap()交换两个对象的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; old_v;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; new_v;</span><br><span class="line">old_v.<span class="built_in">swap</span>(new_v);</span><br></pre></td></tr></table></figure>
</li>
<li><p>8个容器类，需要支持10中操作，都有自己的成员函数，则要定义80个成员函数，但采用STL方式时，只需要10个非成员函数即可</p>
</li>
<li><p>即使有执行相同任务的非成员函数，STL有时也会定义一个成员函数，因为类特定算法的效率比通用算法高，vector成员函数swap()效率比非成员函数swap()高，但非成员函数让你能够交换两个不同容器的内容</p>
</li>
<li><p>STL函数：for_each(),random_shuffle()和sort()，必须包含<algorithm></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Review&gt;::iterator pr;</span><br><span class="line">		<span class="keyword">for</span> (pr = books.<span class="built_in">begin</span>(); pr != books.<span class="built_in">end</span>(); pr++)</span><br><span class="line">			<span class="built_in">ShowReview</span>(*pr);</span><br><span class="line">替换为：</span><br><span class="line">for_each(books.<span class="built_in">begin</span>(),books.<span class="built_in">end</span>(),ShowReview);</span><br></pre></td></tr></table></figure>
<p>最后一个参数是指向函数的指针(函数对象)，该函数不可以修改容器元素的值</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">random_shuffle</span>(books.<span class="built_in">begin</span>(),books.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>随机排列该区间中的元素，要求容器类允许随机访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Review&amp; r1,<span class="type">const</span> Review&amp; r2) <span class="type">const</span>;   <span class="comment">//注意是使用的是布尔类型的返回值，现在函数总是用布尔类型的返回值和循环是否结束</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(r1.title&lt;r2.title)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(r1.title==r2.title &amp;&amp; r1.rating&lt;r2.rating)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(books.<span class="built_in">begin</span>(),books.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>sort()第一个版本使用为存储在容器中的类型元素定义的&lt;运算符，如果容器元素类型是用户定义的，则要使用sort()，必须定义能够该类型对象的operator&lt;()函数，为Review提供了成员或非成员函数operator&lt;()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorseThan</span><span class="params">(<span class="type">const</span> Review&amp; r1,<span class="type">const</span> Review&amp; r2)</span> <span class="type">const</span></span>;  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(r1.title&lt;r2.title)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(r1.title==r2.title &amp;&amp; r1.rating&lt;r2.rating)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(books.<span class="built_in">begin</span>(),books.<span class="built_in">end</span>(),WorseThan);</span><br></pre></td></tr></table></figure>
<p>第二种版本的sort()</p>
<h3 id="16-3-4-基于范围的for循环"><a href="#16-3-4-基于范围的for循环" class="headerlink" title="16.3.4 基于范围的for循环"></a>16.3.4 基于范围的for循环</h3><ol>
<li>基于范围的for循环是为用于STL而设计的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">10.0</span>,<span class="number">20.0</span>,<span class="number">30.0</span>,<span class="number">40.0</span>,<span class="number">50.0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> x: prices)</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.循环将依次将books中的每个Review对象传递给ShowReview()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : books)</span><br><span class="line">	<span class="built_in">ShowReview</span>(x);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>不同于for_each()，基于范围的for循环可以修改容器中的元素，但要指定一个引用参数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InflateReview</span><span class="params">(Review&amp; r)</span></span>&#123;r.rating++;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : books)                                                        <span class="comment">//两个地方必须要有引用</span></span><br><span class="line">	<span class="built_in">InflateReview</span>(x);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="16-4-泛型编程"><a href="#16-4-泛型编程" class="headerlink" title="16.4 泛型编程"></a>16.4 泛型编程</h2><ol>
<li><p>STL是一种泛型编程，面向对象编程关注的是编程的数据方面，使任何数据类型能存在容器中，而泛型编程关注的是算法，使任何容器能运用于算法，共同特定是抽象和创建可重用代码</p>
</li>
<li><p>模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型</p>
</li>
<li><p>定义一种链表类型的迭代器类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> item;</span><br><span class="line">	Node* p_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* pt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">iterator</span>(<span class="number">0</span>) : <span class="built_in">pt</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">	<span class="built_in">iterator</span>(Node* pn) : <span class="built_in">pt</span>(pn) &#123;&#125;;</span><br><span class="line">	<span class="type">double</span> <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> pt-&gt;item;&#125;</span><br><span class="line">	iterator <span class="keyword">operator</span>++()                                                     <span class="comment">//是返回的是类对象</span></span><br><span class="line">	&#123;</span><br><span class="line">		pt = pt-&gt;p_next;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">		pt = pt-&gt;p_next;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>find_ar()与find_ll几乎相同，区别在于结束的条件不同，这就需要不同的容器了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span>* iterator;</span><br><span class="line"><span class="function">iterator <span class="title">find_ar</span><span class="params">(iterator begin,iterator end,<span class="type">double</span> &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	iterator ar;</span><br><span class="line">	<span class="keyword">for</span>(ar = begin;ar!=end;ar++)</span><br><span class="line">		<span class="keyword">if</span>(*ar == val)</span><br><span class="line">			<span class="keyword">return</span> ar;</span><br><span class="line">	<span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">find_ll</span><span class="params">(iterator head,<span class="type">const</span> <span class="type">double</span> &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	interator start;</span><br><span class="line">	<span class="keyword">for</span>(start = head;start!=<span class="number">0</span>;start++)</span><br><span class="line">		<span class="keyword">if</span>(*start == val)</span><br><span class="line">			<span class="keyword">return</span> start;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find()函数的实现方法</p>
</li>
<li><p>每个容器类定义了相应的迭代器类型，可能是指针，可能是对象，每个容器类都有begin()和end()方法，都使用++，让迭代器递增</p>
</li>
<li><p>C++11新增的自动类型推断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pr = scores.<span class="built_in">begin</span>();pr != scores.<span class="built_in">end</span>();pr++)</span><br><span class="line">	cout &lt;&lt; *pr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>最好避免直接使用迭代器，而尽量使用for_each()，和基于范围的for循环</p>
</li>
<li><p>有了迭代器算法才能通用，基于算法的要求，设计基本迭代器的特征和容器的特征</p>
</li>
</ol>
<h3 id="16-4-2-迭代器类型"><a href="#16-4-2-迭代器类型" class="headerlink" title="16.4.2 迭代器类型"></a>16.4.2 迭代器类型</h3><ol>
<li><p>不同的算法对迭代器的要求也不同，排序算法需要能够随机访问，可以通过定义+运算符来实现,迭代器也是一个类，含有构造函数</p>
</li>
<li><p>如果两个迭代器相同，则解除引用操作得到的值将相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter1 == iter2</span><br><span class="line">*iter1 == *iter2</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出迭代器只能修改容器值，而不能读取，程序的输出就是容器的输入，输入和输出迭代器都是单通行，不能保证第二次遍历容器时，顺序不变，也不能保证其先前值仍然可以被解除引用</p>
</li>
<li><p>正向迭代器可以对前面的迭代器值解除引用，可以读取和修改数据，也可以只读取数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pirw;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pirw;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双向迭代器中，reverse函数可以交换第一个元素和最后一个元素，将指向第一个元素的指针加1，指向第一个元素的指针减1</p>
</li>
<li><p>sort()函数需要随机访问迭代器，所以只能用于支持这种迭代器的容器，随机访问迭代器实现为一个常规指针，正向迭代器实现为一个类</p>
</li>
<li><p>一种迭代器的类型是不一样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator</span><br><span class="line">vector&lt;<span class="type">double</span>&gt;::iterator         <span class="comment">//两种类型的迭代器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>每个容器类都定义了一个类级typedef名称——iterator</p>
</li>
</ol>
<p>9.如果所设计的容器类需要迭代器，可考虑STL，它包含用于标准种类的迭代器模板</p>
<h3 id="16-4-4-概念，改进和模型"><a href="#16-4-4-概念，改进和模型" class="headerlink" title="16.4.4 概念，改进和模型"></a>16.4.4 概念，改进和模型</h3><ol>
<li><p>将指针用作迭代器，使得STL算法用于常规数组</p>
</li>
<li><p>将一个数组复制到一个矢量中copy()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> casts[<span class="number">10</span>] = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dice[<span class="number">10</span>];                                        <span class="comment">//copy()不能自动根据发送值调整目标容器的长度</span></span><br><span class="line"><span class="built_in">copy</span>(casts,casts+<span class="number">10</span>,dice.<span class="built_in">begin</span>())</span><br></pre></td></tr></table></figure>
<p>前两个参数必须是输入迭代器，最后一个必须是输出迭代器</p>
</li>
<li><p>输出流迭代器，STL为这种迭代器提供了ostream_iterator模板，是输出迭代器的一个模型，也是一个适配器——类或函数，可以将一些其他接口转换为STL使用的接口(使得cout可以在算法中使用)，迭代器就是STL的接口，要包含头文件iterator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>,<span class="type">char</span>&gt; <span class="title">out_iter</span><span class="params">(cout,<span class="string">&quot; &quot;</span>)</span></span>;    <span class="comment">//构造函数的第一个参数指出了要使用的输出流，第二个参数指出了要使用的分隔符</span></span><br><span class="line">out_iter++ = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>out_iter才是迭代器，意味着将15和有空格组成的字符串发送到输出流中，并为下一个输出做准备</p>
</li>
<li><p>copy()函数的另一种用法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(dice.<span class="built_in">begin</span>(),dice.<span class="built_in">end</span>(),out_iter);</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(dice.<span class="built_in">begin</span>(),dice.<span class="built_in">end</span>(),<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>,<span class="type">char</span>&gt;(cout,<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>,<span class="type">char</span>&gt;(cin),istream_iterator&lt;<span class="type">int</span>,<span class="type">char</span>&gt;,dice.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>
<p>将dice的内容复制到cout输出流中，即显示容器的内容</p>
</li>
<li><p>其他有用的迭代器(reverse_iterator,back_insert_iterator,frint_insert_iterator)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(dice.<span class="built_in">rbegin</span>(),dice.<span class="built_in">rend</span>(),out_iter);</span><br></pre></td></tr></table></figure>
<p>这样不必声明反向迭代器reverse_iterator，rbegin()和end()返回的值相同，但类型不同(reverse_iterator,iterator)</p>
</li>
<li><p>反向指针先通过递减，再解除引用来解决rbegin()的超尾的问题，rp指向位置6，则*rp将是位置5的值 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::reverse_iterator ri;</span><br><span class="line"><span class="keyword">for</span>(ri = dice.<span class="built_in">rbegin</span>();ri != dice.<span class="built_in">rend</span>();ri++)</span><br><span class="line">	cout &lt;&lt; *ri &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三种插入迭代器：back_insert_iterator,front_insert_iterator,insert_iterator</p>
</li>
<li><p>back_insert_iterator只能于允许在尾部快速插入的容器(快速插入指的是一个小时固定的算法)，vector满足，将容器类型作为模板参数，将实际的容器标识符作为构造函数参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">back_insert_iterator&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">back_iter</span>(dice);     </span><br></pre></td></tr></table></figure>
<p>构造函数将假设传递给它的类型有一个push_back()方法</p>
</li>
<li><p>front_insert_iterator，满足queue，不满足vector，完成任务很快</p>
</li>
<li><p>insert_iterator没有这些限制，还需要一个指示插入位置的构造函数参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert_iterator&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">insert_iter</span>(dice,dice.<span class="built_in">begin</span>());     </span><br></pre></td></tr></table></figure>
</li>
<li><p>二维数组也是同样的运用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1[<span class="number">2</span>] = &#123;<span class="string">&quot;fsdaf&quot;</span>,<span class="string">&quot;ffsadfds&quot;</span>&#125;</span><br><span class="line">vector&lt;string&gt; <span class="built_in">s2</span>(<span class="number">4</span>);        </span><br><span class="line"><span class="built_in">copy</span>(s1,s1+<span class="number">2</span>,s2.<span class="built_in">begin</span>());                                      <span class="comment">//stirng没有迭代器</span></span><br></pre></td></tr></table></figure></li>
<li><p>可以用insert_iterator将复制数据的算法转换为插入数据的算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(s1,s1+<span class="number">2</span>,back_insert_iterator&lt;vector&lt;string&gt; &gt;(words));</span><br></pre></td></tr></table></figure>
</li>
<li><p>这些预定义迭代器增加了函数的功能，比如copy()函数</p>
</li>
</ol>
<h3 id="16-4-5-容器的种类"><a href="#16-4-5-容器的种类" class="headerlink" title="16.4.5 容器的种类"></a>16.4.5 容器的种类</h3><ol>
<li><p>STL具有容器概念和容器类型，容器类型是可用于创建具体容器对象的模板，有deque,list,queue,priority_queue,stack,vector,map,multimap,set,multiset,bitset</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;deque&quot;</span>: <span class="string">&quot;双端队列（double-ended queue），可以从中端和末端插入和删除元素，是可以随机访问的&quot;</span>,</span><br><span class="line"><span class="string">&quot;list&quot;</span>: <span class="string">&quot;链表（list）是一个双向链表，可以随时在任何位置插入或删除元素。&quot;</span>,</span><br><span class="line"><span class="string">&quot;queue&quot;</span>: <span class="string">&quot;队列（queue）是一种先进先出（FIFO）的数据结构，只能在末端添加元素，在前端删除元素。&quot;</span>,</span><br><span class="line"><span class="string">&quot;priority_queue&quot;</span>: <span class="string">&quot;优先队列（priority queue）是一种特殊的队列，每个元素都有一个优先级，优先级最高的元素最先出队。&quot;</span>,</span><br><span class="line"><span class="string">&quot;stack&quot;</span>: <span class="string">&quot;栈（stack）是一种后进先出（LIFO）的数据结构，只能在顶端添加或删除元素。&quot;</span>,</span><br><span class="line"><span class="string">&quot;vector&quot;</span>: <span class="string">&quot;向量（vector）是动态数组，可以动态地增加和减少元素，在尾部添加和删除元素的时间是固定的，但在头部或中间插入和删除元素为线性时间，还是一种反转容器&quot;</span>,</span><br><span class="line"><span class="string">&quot;map&quot;</span>: <span class="string">&quot;映射（map）是一种关联数组，它存储的是键值对（key-value pairs）。&quot;</span>,</span><br><span class="line"><span class="string">&quot;multimap&quot;</span>: <span class="string">&quot;多重映射（multimap）类似于映射，但允许存在多个相同的键。&quot;</span>,</span><br><span class="line"><span class="string">&quot;set&quot;</span>: <span class="string">&quot;集合（set）是一种不包含重复元素的无序集合。&quot;</span>,</span><br><span class="line"><span class="string">&quot;multiset&quot;</span>: <span class="string">&quot;多重集合（multiset）类似于集合，但允许存在重复的元素。&quot;</span>,</span><br><span class="line"><span class="string">&quot;bitset&quot;</span>: <span class="string">&quot;位集（bitset）是一种特殊的数组，它存储的是位（0或1）。&quot;</span></span><br></pre></td></tr></table></figure>
<p>C++11新增的容器类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map：基于哈希表的关联容器，用于存储键值对，查找、插入和删除操作的平均时间复杂度为<span class="built_in">O</span>(<span class="number">1</span>)。</span><br><span class="line">std::unordered_set：基于哈希表的集合容器，用于存储唯一的键，查找、插入和删除操作的平均时间复杂度为<span class="built_in">O</span>(<span class="number">1</span>)。</span><br><span class="line">std::forward_list：单向链表容器，只支持正序遍历，插入和删除操作在链表头部和尾部速度很快。</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些基本的容器特征</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X a;</span><br><span class="line">(&amp;a)-&gt;~<span class="built_in">X</span>();       <span class="comment">//线性时间</span></span><br><span class="line"></span><br><span class="line">a.<span class="built_in">size</span>();         <span class="comment">//固定时间</span></span><br><span class="line"></span><br><span class="line">a.<span class="built_in">swap</span>();         <span class="comment">//固定时间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>“复杂度”，从快到慢：<br>1.编译时间，在编译时执行，指向时间为0<br>2.固定时间，在运行时执行，指向时间为O(1)，独立于对象中的元素数目<br>3.线性时间，时间与元素数目成正比，指向时间为O(n)</p>
</li>
<li><p>序列是基本的容器概念的改进，包括deque,list,vector,forward_list,queue,stack,priority_queue，要求是正向迭代器，保证了元素将按特定顺序排序，即除了第一和最后，每个元素前后都分别有一个元素</p>
</li>
<li><p>为list,deque定义了push_front，而没有为vector定义，是因为在矢量前插入一个元素，需要移动大量的元素，而list和deque的允许将元素添加到前端，而不移动其他元素，以固定时间来完成，所以vector没有必要定义push_front</p>
</li>
<li><p>deque和vector都对元素进行随机访问和在中部执行线性时间的插入和删除，但vector容器执行的更快，因为vector的内存是连续的，而deque的内存不是连续的，所以vector的访问速度更快，deque更复杂</p>
</li>
<li><p>双向链表可以双向遍历链表，可以从后面往前面遍历，也是反转容器 </p>
</li>
<li><p>list成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(list&lt;T,Alloc&gt;&amp;x)</span></span>;        <span class="comment">//将两个链表合并，两个链表必须是已经排序，合并后x为空，为线性时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp;value)</span></span>;         <span class="comment">//删除所有值为value的元素，线性时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unique</span><span class="params">()</span></span>;                      <span class="comment">//将连续的相同(即相邻的相同值)的元素压缩为单个元素，可以结合sort()来使用，线性时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;                        <span class="comment">//使用&lt;运算给发，将元素排序，线性时间为NlogN</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator pos,list&lt;T,Alloc&gt; x)</span>     <span class="comment">//将x中的元素插入到pos之前，x将为空，为固定时间</span></span></span><br></pre></td></tr></table></figure>
<p>非成员函数sort()，需要随机访问迭代器，不能用于链表，所以只能使用类中的成员函数版本</p>
</li>
<li><p>list工具箱：list方法组成了一个方便的工具箱，例如有两个邮件列表要整理，则可以对每个列表进行排序，合并它们，然后使用unique()来删除重复的元素</p>
</li>
<li><p>C++11新增的forward_list，实现单链表，无反向迭代器，因为每个节点都只链接到下一个节点，而没有链接到前一个节点</p>
</li>
<li><p>queue模板类是一个适配器类，让底层类(deque)展示典型的队列接口，既不允许随机访问，也不允许遍历队列，只允许队列的基本操作，使用这个值与栈一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push：在队列的末尾添加一个元素。</span><br><span class="line">pop：从队列的开头移除一个元素，并返回该元素。</span><br><span class="line">front：返回队列的第一个元素，但不移除该元素。</span><br><span class="line">back：返回队列的最后一个元素，但不移除该元素。</span><br><span class="line">empty：检查队列是否为空，如果为空则返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">size：返回队列中的元素个数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>priority_queue是另一个适配器类，与queue操作相同，主要是priority_queue最大的元素被移到队首，底层类是vector，可以修改用于确定哪个元素放到队首的比较方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq1;</span><br></pre></td></tr></table></figure>
<p>这用到了构造函数</p>
</li>
<li><p>stack模板类，与queue相同，也是适配器类，底层类是vector，给底层类提供了典型的栈接口，既不允许随机访问，也不允许遍历栈，只允许栈的基本操作：将压入推到栈顶，从栈顶弹出元素，查看栈顶的值，检查元素数目和测试栈是否为空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span>：判断栈是否为空，如果为空则返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="type">const</span>：返回栈的元素个数。</span></span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span>：返回栈顶元素，并弹出该元素。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span>：将元素压入栈中。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span>：弹出栈顶元素。</span></span><br></pre></td></tr></table></figure>
<p>如果要使用栈值，必须首先使用top()来检索这个值，然后使用pop()将它从栈中删除</p>
</li>
<li><p>array模板类并非STL容器，因为其长度是固定的，没有定义调整容器大小的操作，如push_back()和insert()，可将标准STL算法用于array对象，如copy()和for_each()</p>
</li>
</ol>
<h3 id="16-4-6-关联容器"><a href="#16-4-6-关联容器" class="headerlink" title="16.4.6 关联容器"></a>16.4.6 关联容器</h3><ol>
<li><p>关联容器将值与键冠梁在一起，并使用键来查找值，优点在于它提供了对元素的快速访问，允许插入元素新元素，但不能指定元素的插入位置原因是关联容器通常有用于确定数据放置位置的算法，而不是使用迭代器，以便能够快速找到元素</p>
</li>
<li><p>关联容器通常是使用某种树实现的，4种关联容器：set，multiset,map,multimap，前两种是在头文件set中定义，后两种是在map中定义的</p>
</li>
<li><p>set其值类型与键相同，键是唯一的，不会有多个相同的键，multimap可能有多个值的键相同</p>
</li>
<li><p>map中，值与键的类型不同，键是唯一的，每个键只对应一个值，multimap可能有一个键可以与多个值关联</p>
</li>
<li><p>set模板类可反转，可排序，且键是唯一的，所以不能存储多个相同的值,第二个模板参数，可用于指示用来对键进行的比较函数对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; A;</span><br><span class="line">set&lt;stirng less&lt;string&gt; &gt; A;</span><br><span class="line"></span><br><span class="line">cconst <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line">string s1[N] = &#123;<span class="string">&quot;adsf&quot;</span>, <span class="string">&quot;bwe&quot;</span>, <span class="string">&quot;cfdsf&quot;</span>, <span class="string">&quot;dzv&quot;</span>, <span class="string">&quot;ev&quot;</span>, <span class="string">&quot;fbn&quot;</span>&#125;;</span><br><span class="line"><span class="function">set&lt;string&gt; <span class="title">A</span><span class="params">(s1, s1 + N)</span></span>;</span><br><span class="line"><span class="function">ostream_iterator&lt;string, <span class="type">char</span>&gt; <span class="title">out</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), out);</span><br></pre></td></tr></table></figure>
<p>set有一个将迭代器区间作为参数的构造函数，键是唯一的，所以”for”在数组两次出现，但在集合中只出现一次，且集合被排序</p>
</li>
<li><p>数学为集合定义了一些标准操作，如并集，交集，这些操作的算法，是通用函数，不是类方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_union</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>(), ostream_iterator&lt;string,<span class="type">char</span>&gt; <span class="built_in">out</span>(cout, <span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure>
<p>显示集合A和B的并集，并进行了排序</p>
</li>
<li><p>multimap的模板参数指定键的类型和存储的值的类型，为将信息结合在一起，实际的值的类型将键类型与数据类型结合为一对，STL使用模板类pair&lt;class T,call U&gt;将两种值存储到一个对象中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>,string&gt; codes;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">const</span> <span class="type">int</span>,string&gt;</span><br></pre></td></tr></table></figure>
<p>codes对象的值类型为pair&lt;const int,string&gt;</p>
</li>
<li><p>用区号作为键来存储城市名，这恰好与codes值类型一致</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">const</span> <span class="type">int</span>,string&gt; <span class="title">iteam</span><span class="params">(<span class="number">231</span>, <span class="string">&quot;New York&quot;</span>)</span></span>;</span><br><span class="line">codes.<span class="built_in">insert</span>(iteam);</span><br></pre></td></tr></table></figure>
<p>因为数据项是按键排序的，所以不需要指出插入位置</p>
</li>
</ol>
<h3 id="16-4-7-无序关联容器"><a href="#16-4-7-无序关联容器" class="headerlink" title="16.4.7 无序关联容器"></a>16.4.7 无序关联容器</h3><ol>
<li>无序关联容器也将值与键关联起来，并使用键来查找值，是基于哈希表，旨在提高添加和删除元素的速度以及查找算法的效率：unordered_set,unordered_multiset,unordered_map,unordered_multimap</li>
</ol>
<h2 id="16-5-函数对象"><a href="#16-5-函数对象" class="headerlink" title="16.5 函数对象"></a>16.5 函数对象</h2><ol>
<li>很多STL算法使用了函数对象，包括函数名，指向函数的指针和重载了()运算符的类对象(即定义了函数operator()()的类)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Linear</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">double</span> slope;</span><br><span class="line">		<span class="type">double</span> y0;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> x)</span>  </span>&#123;<span class="keyword">return</span> y0+slope*x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Linear f1;</span><br><span class="line"><span class="type">double</span> y1 = <span class="built_in">f1</span>(<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="16-5-1-函数符概念"><a href="#16-5-1-函数符概念" class="headerlink" title="16.5.1 函数符概念"></a>16.5.1 函数符概念</h3><ol>
<li><p>生成器是不用参数就可以调用的函数符，一元函数是用一个参数就可以调用的函数符，例如，for_each()是一元函数，因为它每次用于一个容器元素，返回bool值的一元函数是谓词</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorseThan</span><span class="params">(<span class="type">const</span> Review&amp; r1, <span class="type">const</span> Review&amp; r2)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(books.<span class="built_in">begin</span>(),books.<span class="built_in">end</span>(),WorseThan);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tooBig</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="keyword">return</span> n &gt; <span class="number">100</span>;&#125;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line">scores.<span class="built_in">remove_if</span>(tooBig);      <span class="comment">//删除链表中所有大于100的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tooBig2</span><span class="params">(<span class="type">const</span> T &amp; val,<span class="type">const</span> T &amp; lim)</span>         <span class="comment">//可以将两个参数的模板函数转换为单个参数的函数对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val &gt; lim;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tempalte&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TooBig</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T cutoff;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">TooBig</span>(<span class="type">const</span> T &amp; t) : <span class="built_in">cutoff</span>(t) &#123;&#125;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> &amp; v)</span></span>&#123;<span class="keyword">return</span> v &gt; cutoff;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TooBig&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">scores.<span class="built_in">remove_if</span>(p);                  <span class="comment">//直接使用类对象</span></span><br></pre></td></tr></table></figure>
<p>n的值来自链表中，设计一个TooBing类，来控制大于多少的元素将被删除</p>
</li>
<li><p>函数对象是一种适配器，使函数或类成员函数能够满足不同的接口(接口就是函数或类成员函数)</p>
</li>
</ol>
<h3 id="16-5-2-预定义的函数符"><a href="#16-5-2-预定义的函数符" class="headerlink" title="16.5.2 预定义的函数符"></a>16.5.2 预定义的函数符</h3><ol>
<li><p>STL定义了多个基本函数符，它们执行诸如将两个值相加，比较两个值是否相等操作，transform()有两个版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v.<span class="built_in">begin</span>(),sqrt);         <span class="comment">//计算每个元素的平方根</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v1.<span class="built_in">begin</span>(),v.<span class="built_in">begin</span>(),mean);      <span class="comment">//计算v所有元素和v1的第一个元素的平均值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v1.<span class="built_in">begin</span>(),v.<span class="built_in">begin</span>(),<span class="built_in">plus</span>&lt;<span class="type">double</span>&gt;());     <span class="comment">//()可有可无，函数对象不会带参数的</span></span><br></pre></td></tr></table></figure>
<p>头文件functional定义了多个模板类函数对象，其中包括plus类</p>
</li>
<li><p>对于所有内置的算术运算符，关系运算符和逻辑运算符，STL都提供了函数对象，例如，+ plus<int>()和 - minus<int>()是两个函数对象</p>
</li>
</ol>
<h3 id="16-5-3-自适应函数符和函数适配器"><a href="#16-5-3-自适应函数符和函数适配器" class="headerlink" title="16.5.3 自适应函数符和函数适配器"></a>16.5.3 自适应函数符和函数适配器</h3><ol>
<li><p>表16.12列出的预定义函数符都是自适应的，函数符自适应性的意义在于：函数适配器对象可以使用函数对象，使函数能匹配不同的接口</p>
</li>
<li><p>函数适配器将接受两个参数的函数符转换为接受1个参数的函数符，前面的TooBig2示例提供了一种方法，但STL使用binder1st和binder2nd类自动完成这个过程，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">binder1st</span>(f2,val) f1;     <span class="comment">//f2是一个自适应二元函数</span></span><br></pre></td></tr></table></figure>
<p>f1对象将与f2的第一个参数val相关联</p>
</li>
<li><p>函数binder1st()与binder1st类的作用相同，binder2st，只是将常数赋给第二个参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(gr8.<span class="built_in">begin</span>(),gr8.<span class="built_in">end</span>(),out,<span class="built_in">bind1st</span>(<span class="built_in">multiplies</span>&lt;<span class="type">int</span>&gt;(),<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>将二元函数multiplies()转换为将参数乘以2的一元函数</p>
</li>
</ol>
<h2 id="16-6-算法"><a href="#16-6-算法" class="headerlink" title="16.6 算法"></a>16.6 算法</h2><ol>
<li><p>STL的非成员函数：sort(),copy(),find(),random_shuffle(),set_union(),set_intersection(),set_difference(),transform()，有些函数接受一个函数对象</p>
</li>
<li><p>统一的容器设计使得不同类型的容器之间具有明显的关系，例如可以使用copy()将vector对象中的值复制到list对象中，用&#x3D;&#x3D;来比较不同类型的容器，如deque和vector，之所以能这样做是容器都使用迭代器来提供访问容器中的数据</p>
</li>
</ol>
<h3 id="16-6-1-算法组"><a href="#16-6-1-算法组" class="headerlink" title="16.6.1 算法组"></a>16.6.1 算法组</h3><ol>
<li>通用数字运算的算法在头文件numeric中定义，vector最有可能使用这些操作的容器</li>
</ol>
<h3 id="16-6-2-算法的通用特征"><a href="#16-6-2-算法的通用特征" class="headerlink" title="16.6.2 算法的通用特征"></a>16.6.2 算法的通用特征</h3><ol>
<li><p>sort()的结果被存放在原始数据的位置上，copy()将结果发送到另一个位置，transform()可以以这两种方式完成工作</p>
</li>
<li><p>copy()的原型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>,<span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">copy</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这包含了两种迭代器</p>
</li>
<li><p>有些算法有两个版本：就地版本和复制版本，复制版本的名称将以_copy()结尾，将接受一个多的输出迭代器参数</p>
</li>
</ol>
<h1 id="第17章-泛型编程注意的事项"><a href="#第17章-泛型编程注意的事项" class="headerlink" title="第17章 泛型编程注意的事项"></a>第17章 泛型编程注意的事项</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Review</span> &#123;</span><br><span class="line">	string title;</span><br><span class="line">	<span class="type">int</span> rating;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FillReview</span><span class="params">(Review&amp; rr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowReview</span><span class="params">(<span class="type">const</span> Review&amp; rr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Review&gt; books;</span><br><span class="line">	Review temp;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">FillReview</span>(temp))                                                 <span class="comment">//FillReview()函数的返回值为true或false</span></span><br><span class="line">		books.<span class="built_in">push_back</span>(temp);                                               <span class="comment">//添加在后面</span></span><br><span class="line">	<span class="type">int</span> num = books.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;You enter the following:\n&quot;</span> &lt;&lt; <span class="string">&quot;Rating Book\n&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">			<span class="built_in">ShowReview</span>(books[i]);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Reprising:\n&quot;</span> &lt;&lt; <span class="string">&quot;Rating book&quot;</span> &lt;&lt; endl;</span><br><span class="line">		vector&lt;Review&gt;::iterator pr;</span><br><span class="line">		<span class="keyword">for</span> (pr = books.<span class="built_in">begin</span>(); pr != books.<span class="built_in">end</span>(); pr++)</span><br><span class="line">			<span class="built_in">ShowReview</span>(*pr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FillReview</span><span class="params">(Review&amp; rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter book title: &quot;</span>;</span><br><span class="line">	<span class="built_in">getline</span>(cin, rr.title);</span><br><span class="line">	<span class="keyword">if</span> (rr.title == <span class="string">&quot;quit&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enter book rating: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; rr.rating;</span><br><span class="line">	<span class="keyword">if</span> (!cin)                                                                <span class="comment">//判断是否输入了</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	cin.<span class="built_in">get</span>();                                                               <span class="comment">//在连续输入时要考虑&quot;\n&quot;的存在</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowReview</span><span class="params">(<span class="type">const</span> Review&amp; rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; rr.rating &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; rr.title &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>string对象初始化<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string s1[<span class="number">2</span>] = &#123;<span class="string">&quot;fsdaf&quot;</span>,<span class="string">&quot;ffsadfds&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">s2</span><span class="params">(<span class="number">4</span>)</span></span>;                                <span class="comment">//两个不同表示数组大小的方式</span></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> STL中的类，对象和通常函数都要处理空间名称</span><br><span class="line">```c++</span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">B</span><span class="params">(s2,s2+N)</span></span>;</span><br><span class="line"><span class="function">std::ostream_iterator&lt;std::string,<span class="type">char</span>&gt; <span class="title">out</span><span class="params">(std::cout,<span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">copy</span>(B.<span class="built_in">begin</span>(),B.<span class="built_in">end</span>(),out);</span><br></pre></td></tr></table></figure></li>
</ol>
</article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.jinyincaibao.online/2023/08/19/2/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=undefined&amp;url=https://www.jinyincaibao.online/2023/08/19/2/&amp;pic=undefined" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>计算机语言<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/66dd47e6d9c307b7e9aae384.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.jinyincaibao.online/2023/08/19/2/">原创</a><a class="post-copyright-title"><span>C++</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"></span><a class="link" href="https://www.jinyincaibao.online">金银财宝</a></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a class="link" href="https://www.jinyincaibao.online/2023/08/19/2/">https://www.jinyincaibao.online/2023/08/19/2/</a></span><span class="copy-button" onclick="rm.copyPageUrl('https://www.jinyincaibao.online/2023/08/19/2/)'"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.jinyincaibao.online" target="_blank">金银财宝</a>！</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/08/18/7/"><img class="prev-cover" src="https://pic.imgdb.cn/item/66dd301bd9c307b7e980d563.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构与算法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author-info-top"> <div class="card-info-avatar"><a class="avatar-img" href="/about"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66daa709d9c307b7e9042d3a.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></a><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="writing_hand" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270d.png">✍️</g-emoji><span>on Studying</span></div></div></div></div><div class="author-info__sayhi" id="author-info__sayhi"></div><h1 class="author-info__name">金银财宝</h1><div class="author-info__description">大好青年，事业有为。</div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/H-jfeng" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/frame_html?sid=dozdw2LJoUeyizdT&amp;r=0d94d63e78efbec9830f1bae3bd0223d&amp;lang=zh" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C"><span class="toc-number">1.</span> <span class="toc-text">第2章 开始学习C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%BF%9B%E5%85%A5C"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 进入C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-%E4%BD%BF%E7%94%A8cout%E8%BF%9B%E8%A1%8CC-%E8%BE%93%E5%87%BA"><span class="toc-number">1.1.1.</span> <span class="toc-text">2.1.6 使用cout进行C++输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">第6章 分支语句和逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">2.1.</span> <span class="toc-text">6.8 简单文件输入输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">第11章 使用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">11.6类的自动转换和强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-1%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">11.6.1转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-2%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">11.6.2转换函数和友元函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">4.</span> <span class="toc-text">第12章 类和动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">12.1动态内存和类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-1%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%B1%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">12.1.1开发一个动态内存类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-2-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">12.1.2 特殊成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-3-%E5%9B%9E%E5%88%B0Stringbad-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%93%AA%E9%87%8C%E5%87%BA%E4%BA%86%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.3.</span> <span class="toc-text">12.1.3 回到Stringbad: 复制构造函数的哪里出了问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-4-StringBad%E7%9A%84%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%EF%BC%9A%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.4.</span> <span class="toc-text">12.1.4 StringBad的其他问题：赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E6%96%B0Stirng%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">改进后的新Stirng类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-2%E6%AF%94%E8%BE%83%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">12.2.2比较成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-3%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6"><span class="toc-number">4.2.2.</span> <span class="toc-text">12.2.3使用中括号表示法访问字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-4-%E9%9D%99%E6%80%81%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">12.2.4 静态类成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-5-%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.2.4.</span> <span class="toc-text">12.2.5 进一步重载赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8new%E6%97%B6%E5%BA%94%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.3.</span> <span class="toc-text">12.3 在构造函数中使用new时应注意的事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-%E5%8C%85%E5%90%AB%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E7%9A%84%E9%80%90%E6%88%90%E5%91%98%E5%A4%8D%E5%88%B6"><span class="toc-number">4.3.1.</span> <span class="toc-text">12.3.1 包含类成员的类的逐成员复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E6%9C%89%E5%85%B3%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">4.4.</span> <span class="toc-text">12.4 有关返回对象的说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-1-%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91const%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">4.4.1.</span> <span class="toc-text">12.4.1 返回指向const对象的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-2-%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E9%9D%9Econst%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text">12.4.2 返回指向非const对象引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-3-%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.4.3.</span> <span class="toc-text">12.4.3 返回对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">4.5.</span> <span class="toc-text">12.5 使用指向对象的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-1-%E5%86%8D%E8%B0%88%E5%AE%9A%E4%BD%8Dnew%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.5.1.</span> <span class="toc-text">12.5.1 再谈定位new运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">5.</span> <span class="toc-text">第13章 类继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">13.1 一个简单的基类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">13.1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E8%80%83%E8%99%91"><span class="toc-number">5.1.2.</span> <span class="toc-text">13.1.2 构造函数：访问权限的考虑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-4-%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E7%89%B9%E6%AE%8A%E5%85%B3%E7%B3%BB"><span class="toc-number">5.1.3.</span> <span class="toc-text">13.1.4 派生类和基类之间的特殊关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E7%BB%A7%E6%89%BF%EF%BC%9Ais-a%E5%85%B3%E7%B3%BB"><span class="toc-number">5.2.</span> <span class="toc-text">13.2 继承：is-a关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-%E5%A4%9A%E6%80%81%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">5.3.</span> <span class="toc-text">13.3 多态公有继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-1-%E5%BC%80%E5%8F%91Brass%E7%B1%BB%E5%92%8CBrassPlus%E7%B1%BB"><span class="toc-number">5.3.1.</span> <span class="toc-text">13.3.1 开发Brass类和BrassPlus类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">5.4.</span> <span class="toc-text">13.4 静态联编和动态联编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-1-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">5.4.1.</span> <span class="toc-text">13.4.1 指针和引用类型的兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9Aprotected"><span class="toc-number">5.5.</span> <span class="toc-text">13.5 访问控制：protected</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB-ABC"><span class="toc-number">5.6.</span> <span class="toc-text">13.6 抽象基类(ABC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-1-%E5%BA%94%E7%94%A8ABC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.6.1.</span> <span class="toc-text">13.6.1 应用ABC概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">5.7.</span> <span class="toc-text">13.7 继承和动态内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-1-%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8D%E4%BD%BF%E7%94%A8new"><span class="toc-number">5.8.</span> <span class="toc-text">13.7.1 第一种情况：派生类不使用new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-2-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%BD%BF%E7%94%A8new"><span class="toc-number">5.9.</span> <span class="toc-text">13.7.2 第二种情况：派生类使用new</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-3-%E5%8F%8B%E5%85%83%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">5.9.1.</span> <span class="toc-text">13.7.3 友元的继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-c-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">第14章 c++中的代码重用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E5%8C%85%E5%90%AB%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">14.1 包含对象成员的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-1-valarray%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.1.</span> <span class="toc-text">14.1.1 valarray类简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-2-Student%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.1.2.</span> <span class="toc-text">14.1.2 Student类的设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">6.2.</span> <span class="toc-text">14.2 私有继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">14.2.1 初始化基类组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-2-%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">14.2.2 访问基类的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-3-%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.3.</span> <span class="toc-text">14.2.3 访问基类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-3-%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.4.</span> <span class="toc-text">14.2.3 访问基类的友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-4-%E4%BD%BF%E7%94%A8%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84Student%E7%B1%BB"><span class="toc-number">6.2.5.</span> <span class="toc-text">14.2.4 使用修改后的Student类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-5-%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="toc-number">6.2.6.</span> <span class="toc-text">14.2.5 保护继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-6-%E4%BD%BF%E7%94%A8using%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">6.2.7.</span> <span class="toc-text">14.2.6 使用using重新定义访问权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">6.3.</span> <span class="toc-text">14.3 多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.4.</span> <span class="toc-text">14.4 类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-1-%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">6.4.1.</span> <span class="toc-text">14.4.1 定义模板类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-2-%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.4.2.</span> <span class="toc-text">14.4.2 使用类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-3-%E6%8C%87%E9%92%88%E6%A0%88-x2F-%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.4.3.</span> <span class="toc-text">14.4.3 指针栈&#x2F;指针模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-4-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E7%A4%BA%E4%BE%8B%E5%92%8C%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">6.4.4.</span> <span class="toc-text">14.4.4 数组模板示例和非类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-4-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E6%80%A7"><span class="toc-number">6.4.5.</span> <span class="toc-text">14.4.4 模板的多功能性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-6-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%85%B7%E4%BD%93%E5%8C%96"><span class="toc-number">6.4.6.</span> <span class="toc-text">14.4.6 模板的具体化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-7-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.4.7.</span> <span class="toc-text">14.4.7 成员模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-8-%E5%B0%86%E6%A8%A1%E6%9D%BF%E7%94%A8%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-number">6.4.8.</span> <span class="toc-text">14.4.8 将模板用作参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-8-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E5%8F%8B%E5%85%83"><span class="toc-number">6.4.9.</span> <span class="toc-text">14.4.8 模板类和友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-8-%E6%A8%A1%E6%9D%BF%E5%88%AB%E5%90%8D"><span class="toc-number">6.4.10.</span> <span class="toc-text">14.4.8 模板别名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96"><span class="toc-number">7.</span> <span class="toc-text">第15章 友元、异常和其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E5%8F%8B%E5%85%83"><span class="toc-number">7.1.</span> <span class="toc-text">15.1 友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-1-%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">7.1.1.</span> <span class="toc-text">15.1.1 友元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-2-%E5%8F%8B%E5%85%83%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.2.</span> <span class="toc-text">15.1.2 友元成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-3-%E5%85%B6%E4%BB%96%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-number">7.1.3.</span> <span class="toc-text">15.1.3 其他友元关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-4-%E5%85%B1%E5%90%8C%E7%9A%84%E5%8F%8B%E5%85%83"><span class="toc-number">7.1.4.</span> <span class="toc-text">15.1.4 共同的友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">15.2 嵌套类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-1-%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%92%8C%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">7.3.</span> <span class="toc-text">15.2.1 嵌套类和访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-2-%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">7.4.</span> <span class="toc-text">15.2.2 模板中的嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-3%E5%BC%82%E5%B8%B8"><span class="toc-number">7.5.</span> <span class="toc-text">15.3异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-RTTI"><span class="toc-number">7.6.</span> <span class="toc-text">15.4 RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-1-RTTI%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">7.7.</span> <span class="toc-text">15.4.1 RTTI的用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-2-RTTI%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">7.8.</span> <span class="toc-text">15.4.2 RTTI的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-5-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.9.</span> <span class="toc-text">15.5 类型转换运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">第16章 string类和标准模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-string%E7%B1%BB"><span class="toc-number">8.1.</span> <span class="toc-text">16.1 string类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-1-%E6%9E%84%E9%80%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.1.1.</span> <span class="toc-text">16.1.1 构造字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-2-string%E7%B1%BB%E8%BE%93%E5%85%A5"><span class="toc-number">8.1.2.</span> <span class="toc-text">16.1.2 string类输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-3-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.1.3.</span> <span class="toc-text">16.1.3  使用字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">16.2 智能指针模板类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-1-%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">8.2.1.</span> <span class="toc-text">16.2.1 使用智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-3-unique-ptr%E4%BC%98%E4%BA%8Eauto-ptr"><span class="toc-number">8.2.2.</span> <span class="toc-text">16.2.3 unique_ptr优于auto_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-4-%E9%80%89%E6%8B%A9%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">8.2.3.</span> <span class="toc-text">16.2.4 选择智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">8.3.</span> <span class="toc-text">16.3 标准模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-1-%E6%A8%A1%E6%9D%BF%E7%B1%BBvector"><span class="toc-number">8.3.1.</span> <span class="toc-text">16.3.1 模板类vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-2-%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">8.3.2.</span> <span class="toc-text">16.3.2 可执行的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-4-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-number">8.3.3.</span> <span class="toc-text">16.3.4 基于范围的for循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-4-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text">16.4 泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.4.1.</span> <span class="toc-text">16.4.2 迭代器类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-4-%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%94%B9%E8%BF%9B%E5%92%8C%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.4.2.</span> <span class="toc-text">16.4.4 概念，改进和模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-5-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">8.4.3.</span> <span class="toc-text">16.4.5 容器的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-6-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">8.4.4.</span> <span class="toc-text">16.4.6 关联容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-7-%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">8.4.5.</span> <span class="toc-text">16.4.7 无序关联容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-5-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.5.</span> <span class="toc-text">16.5 函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-1-%E5%87%BD%E6%95%B0%E7%AC%A6%E6%A6%82%E5%BF%B5"><span class="toc-number">8.5.1.</span> <span class="toc-text">16.5.1 函数符概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-2-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E7%AC%A6"><span class="toc-number">8.5.2.</span> <span class="toc-text">16.5.2 预定义的函数符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-3-%E8%87%AA%E9%80%82%E5%BA%94%E5%87%BD%E6%95%B0%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.5.3.</span> <span class="toc-text">16.5.3 自适应函数符和函数适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-6-%E7%AE%97%E6%B3%95"><span class="toc-number">8.6.</span> <span class="toc-text">16.6 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-1-%E7%AE%97%E6%B3%95%E7%BB%84"><span class="toc-number">8.6.1.</span> <span class="toc-text">16.6.1 算法组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-2-%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%9A%E7%94%A8%E7%89%B9%E5%BE%81"><span class="toc-number">8.6.2.</span> <span class="toc-text">16.6.2 算法的通用特征</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.</span> <span class="toc-text">第17章 泛型编程注意的事项</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:anzhiyu-c@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://weibo.com/u/6378063631" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.facebook.com/profile.php?id=100092208016287&amp;sk=about" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><img class="footer_mini_logo" title="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src="https://pic.imgdb.cn/item/66dd9db5d9c307b7e93f321e.png" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/1463547681?spm_id_from=333.1007.0.0" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.douyin.com/user/self?from_tab_name=main&amp;showTab=like" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" target="_blank" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a><a class="footer-item" title="更新日志" target="_blank" href="/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" target="_blank" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" target="_blank" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" target="_blank" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" target="_blank" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" target="_blank" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" target="_blank" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><div class="copyright">&copy;2020 - 2024 By 金银财宝</div><div id="workboard"><img class="workSituationImg boardsign" src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div></footer></div></div></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://pic.imgdb.cn/item/66daa709d9c307b7e9042d3a.png"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
    Pace.restart()
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://pic.imgdb.cn/item/66dd949dd9c307b7e9308f6b.jpg"/><script async="async" src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66daa709d9c307b7e9042d3a.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8921687509&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 统计图</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button type="button" title="切换背景" onclick="toggleWinbox()"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="center-console" type="button" title="中控台"><i class="anzhiyufont anzhiyu-icon-fish"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><div id="console-music-bg"></div><meting-js id="8921687509" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="console"><div class="close-btn" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-xmark" style="font-size: 35px;"></i></div><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://img1.imgtp.com/2023/08/15/BePdzusW.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/08/15/BePdzusW.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://img1.imgtp.com/2023/08/15/jqcGMBFZ.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/08/15/jqcGMBFZ.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/html/" style="font-size: 1.05rem; color: rgb(40, 43, 66);">html<sup>1</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem; color: rgb(61, 7, 107);">嵌入式编程<sup>1</sup></a><a href="/tags/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD/" style="font-size: 1.05rem; color: rgb(11, 4, 72);">考研英语<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 1.05rem; color: rgb(25, 56, 76);">计算机<sup>2</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem; color: rgb(67, 9, 105);">计算机语言<sup>3</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem; color: rgb(109, 184, 44);">面试<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem; color: rgb(165, 10, 199);">项目<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8921687509&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@17.3.1/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>var meting_api = "https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r";
</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 1.3.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 金银财宝 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2021 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
      img.title = "下班了就该开开心心的玩耍，嘿嘿~";
      img.alt = "下班了就该开开心心的玩耍，嘿嘿~";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";</script><script>//动态标题
let leaveTitle = 'w(ﾟДﾟ)w 不要走！再看看嘛！';
let backTitle = '♪(^∇^*)欢迎肥来！';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | 金银财宝")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();

anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script>LA.init({id: "3FaQCNdNtNTCmsoI", ck: "3FaQCNdNtNTCmsoI"});
new LingQue.Monitor().init({id: "3FaQCNdNtNTCmsoI", sendSuspicious:true});</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.0/icon/ali_iconfont_css.css"><script src="/js/sakura.js"></script><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script src="/js/share.js"></script><script async data-pjax src="/js/imgloaded.js?1"></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script defer="true" src="/js/welcome.js"></script><script async src="/js/fps.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<container><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></container>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/charts/'|| '/charts/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?Fomalhaut-Blog",['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'],'Fomalhaut-Blog')
    }
  </script><!-- hexo injector body_end end --></body></html>