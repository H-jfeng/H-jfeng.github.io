<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++ | Hjfeng🪂</title><meta name="keywords" content="C++"><meta name="author" content="Hjfeng🪂"><meta name="copyright" content="Hjfeng🪂"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#9796f0"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++"><meta name="application-name" content="C++"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#9796f0"><meta name="description" content="C++在C++中对数组的定义必须在栈区,即使用new，但为了有更多的功能可以使用string,对于指针的定义可以是常量指针，尤其是作为函数的参数时int a&#x3D;10,int *p&#x3D;&amp;a;void a(const *p,int c); 在C++中一般的地址可以像数组一样使用char *a&#x3D;new char[7];a[1]&#x3D;’a’; C++中的while循">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="https://www.jingyingcaibao.club/2023/02/19/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/index.html">
<meta property="og:site_name" content="Hjfeng🪂">
<meta property="og:description" content="C++在C++中对数组的定义必须在栈区,即使用new，但为了有更多的功能可以使用string,对于指针的定义可以是常量指针，尤其是作为函数的参数时int a&#x3D;10,int *p&#x3D;&amp;a;void a(const *p,int c); 在C++中一般的地址可以像数组一样使用char *a&#x3D;new char[7];a[1]&#x3D;’a’; C++中的while循">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.imgtp.com/2023/06/08/O3WKNAND.jpg">
<meta property="article:published_time" content="2023-02-19T04:00:00.000Z">
<meta property="article:modified_time" content="2023-02-19T04:00:00.000Z">
<meta property="article:author" content="Hjfeng🪂">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.imgtp.com/2023/06/08/O3WKNAND.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.jingyingcaibao.club/2023/02/19/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: undefined,
  navMusic: true,
  changeMainColorPost: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-19 12:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#9796f0')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#9796f0')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><style id="transPercent"></style><style id="themeColor"></style><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/"><div class="title">Hjfeng🪂</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8921687509&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/webroot/"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 小地址</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> AI</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/ChatGPT/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> ChatGPT</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 统计图</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" style="display: flex"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div class="nav-button" id="darkmode_navswitch"><a class="darkmode_switchbutton" type="button" href="javascript:void(0);" title="浅色和深色模式转换" onclick="anzhiyu.switchDarkMode()"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke" style="font-size: 1.3rem"></i></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E8%AF%AD%E8%A8%80/">C++语言</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a></span></div></div><h1 class="post-title">C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-19T04:00:00.000Z" title="发表于 2023-02-19 12:00:00">2023-02-19</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-19T04:00:00.000Z" title="更新于 2023-02-19 12:00:00">2023-02-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">14.5k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C++"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为湘潭"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>湘潭</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img1.imgtp.com/2023/06/08/O3WKNAND.jpg"></div></header><main class="layout" id="content-inner"><div id="post"><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><div id="ai-tag">Tianli GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己</div><div class="ai-btn-item">生成本文简介</div><div class="ai-btn-item">推荐相关文章</div><div class="ai-btn-item">前往主页</div><div class="ai-btn-item" id="go-tianli-blog">前往tianli博客</div></div><script data-pjax>(function(){
  // 当前随机到的ai摘要到index
  let lastAiRandomIndex = -1;
  let animationRunning = true; // 标志变量，控制动画函数的运行
  // 当前gpt模式
  let mode = "tianli"
  // 刷新点击次数
  let refreshNum = 0
  // 记录上一次传递给aiAbstract的参数
  let prevParam;
  const aiTitleRefreshIcon = document.querySelector(".ai-title .anzhiyufont.anzhiyu-icon-arrow-rotate-right")
  const explanation = document.querySelector(".ai-explanation");
  const post_ai = document.querySelector(".post-ai-description");
  let ai_str = "";
  let ai_str_length = "";
  let delay_init = 600;
  let i = 0;
  let j = 0;
  let sto = [];
  let elapsed = 0;
  const animate = timestamp => {
    if (!animationRunning) {
      return; // 动画函数停止运行
    }
    if (!animate.start) animate.start = timestamp;
    elapsed = timestamp - animate.start;
    if (elapsed >= 20) {
      animate.start = timestamp;
      if (i < ai_str_length - 1) {
        let char = ai_str.charAt(i + 1);
        let delay = /[,.，。!?！？]/.test(char) ? 150 : 20;
        if (explanation.firstElementChild) {
          explanation.removeChild(explanation.firstElementChild);
        }
        explanation.innerHTML += char;
        let div = document.createElement("div");
        div.className = "ai-cursor";
        explanation.appendChild(div);
        i++;
        if (delay === 150) {
          document.querySelector(".ai-explanation .ai-cursor").style.opacity = "0";
        }
        if (i === ai_str_length - 1) {
          observer.disconnect(); // 暂停监听
          explanation.removeChild(explanation.firstElementChild);
        }
        sto[0] = setTimeout(() => {
          requestAnimationFrame(animate);
        }, delay);
      }
    } else {
      requestAnimationFrame(animate);
    }
  };
  const observer = new IntersectionObserver(
    entries => {
      let isVisible = entries[0].isIntersecting;
      animationRunning = isVisible; // 标志变量更新
      if (animationRunning) {
        delay_init = i === 0 ? 200 : 20;
        sto[1] = setTimeout(() => {
          if (j) {
            i = 0;
            j = 0;
          }
          if (i === 0) {
            explanation.innerHTML = ai_str.charAt(0);
          }
          requestAnimationFrame(animate);
        }, delay_init);
      }
    },
    { threshold: 0 }
  );
  function clearSTO() {
    if (sto.length) {
      sto.forEach(item => {
        if (item) {
          clearTimeout(item);
        }
      });
    }
  }
  function startAI(str, df = true) {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    observer.disconnect(); // 暂停上一次监听
    explanation.innerHTML = df ? "生成中. . ." : "请等待. . .";
    ai_str = str;
    ai_str_length = ai_str.length;
    observer.observe(post_ai); //启动新监听
  }

  async function aiAbstract(num = 1000) {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    observer.disconnect(); // 暂停上一次监听
    if (mode === "tianli") {
      num = Math.max(10, Math.min(2000, num));
      const options = {
        key: "i5m48wFrNQDM9fwUs2Lz",
        Referer: "https://www.jingyingcaibao.club/"
      };
      const truncateDescription = ("C++" + "C++, 11.6类的自动转换和强制类型转换, 11.6.1转换函数, 11.6.2转换函数和友元函数, 第十二章 类和动态内存分配, 12.1动态内存和类, 12.1.1开发一个动态内存类, 12.1.2 特殊成员函数, 12.1.3 回到Stringbad 复制构造函数的哪里出了问题, 12.1.4 StringBad的其他问题：赋值运算符, 改进后的新Stirng类, 12.2.2比较成员函数, 12.2.3使用中括号表示法访问字符, 12.2.4 静态类成员函数, 12.2.5 进一步重载赋值运算符, 12.3 在构造函数中使用new时应注意的事项, 12.3.1 包含类成员的类的逐成员复制, 12.4 有关返回对象的说明, 12.4.1 返回指向const对象的引用, 12.4.2 返回指向非const对象引用, 12.4.3 返回对象, 12.5 使用指向对象的指针, 12.5.1 再谈定位new运算符, 第13章 类继承, 13.1 一个简单的基类, 13.1.1, 13.1.2 构造函数：访问权限的考虑, 13.1.4 派生类和基类之间的特殊关系, 13.2 继承：is-a关系, 13.3 多态公有继承, 13.3.1 开发Brass类和BrassPlus类, 13.4 静态联编和动态联编, 13.4.1 指针和引用类型的兼容性, 13.5 访问控制：protected, 13.6 抽象基类(ABC), 13.6.1 应用ABC概念, 13.7 继承和动态内存分配, 13.7.1 第一种情况：派生类不使用new, 13.7.2 第二种情况：派生类使用new, 13.7.3 友元的继承, 第14章 c++中的代码重用, 14.1 包含对象成员的类, 14.1.1 valarray类简介, 14.1.2 Student类的设计, 14.2 私有继承, 14.2.1 初始化基类组件, 14.2.2 访问基类的方法, 14.2.3 访问基类对象, 14.2.3 访问基类的友元函数, 14.2.4 使用修改后的Student类, 14.2.5 保护继承, 14.2.6 使用using重新定义访问权限, 14.3 多重继承, 14.4 类模板, 14.4.1 定义模板类, 14.4.2 使用类模板, 14.4.3 指针栈x2F指针模板, 14.4.4 数组模板示例和非类型参数, 14.4.4 模板的多功能性, 14.4.6 模板的具体化, 14.4.7 成员模板, 14.4.8 将模板用作参数, 14.4.8 模板类和友元, 14.4.8 模板别名, 第15章 友元、异常和其他, 15.1 友元, 15.1.1 友元类, 15.1.2 友元成员函数, 15.1.3 其他友元关系, 15.1.4 共同的友元, 15.2 嵌套类在中对数组的定义必须在栈区即使用但为了有更多的功能可以使用对于指针的定义可以是常量指针尤其是作为函数的参数时在中一般的地址可以像数组一样使用中的循环用处很大可以也可以使用地址作为判断条件相当于表示当数组有元素时继续循环在类中的第二个的在参数为类时使用的关于如果有是整数则会输出没有小数点也会是不会是数字二维数组作为函数的参数时的写法模板类类似于类也是一种动态数组你可以在运行阶段设置对象的长度它是使用创建动态数组的替代品它是用和来管理内必须包含头文件其次包含在名称空间中的长度为在你插入或添加值时自动调整长度或者括号中可以是常量也可以是变量模板类与数组一样对象的长度是固定的也使用栈不是堆不需定义结构变量就能使用结构了使用类必须包含头文件是用来计算对象的长度的可以将关系运算符用于对象指向一个的值为不能修改都不可以但可以这样在声明函数的指针形参时或数组形参时一定要声明为指向的指针强制类型转换运算符有字符函数库二维数组作为函数时的使用列数是固定的函数可变返回引用时最重要的一点是应避免返回函数终止时不再存在的内存单元引用可以返回在函数中的成员作为返回值因为是在堆中而不是栈中函数模板的用途进行数值的交换函数重载的作用是在不同的参数如数组和结构与普通的常量时使得方法不一样而导致要重新写方法但要达到的目的是一致的这是模板与重载的结合使用使得的功能更丰富交换了结构体的成员运用了显式具体化则运用了显式实列化没有自己的方法定位运算符第二次分配的用法不可使用一般的才可以都是输出字符串地址的方法强制转换为静态变量的用法链接性为外部的静态变量链接性为外部的静态变量并且让内部使用链接性为内部的静态变量无链接性的静态变量创建新的名称空间所创建的每个新对象都有自己的存储空间用于存储其内部变量和类成员但同一个类的所有对象共享同一组类方法即每种方法只有一个副本在中调用成员函数被称为发送消息因此将同样的消息发送给两个不同的对象将调用同一个方法但该方法被用于两个不同的对象为对象动态分配存储空间在这种情况下对象没有名称但可以使用指针来管理该对象叫对象指针构造函数与的结合在构造函数构造出对象之前对象是不存在的因此构造函数被用来创建对象而不是用对象调用的定义默认构造函数的两种方法提供的默认构造函数它创建对象但不初始化其成员这样创建后可以不用显示初始化不需要打技术用来防止多重包含对象已经存在因此这条语句不是进行初始化而是将新值赋给它会创建一个新的临时的对象然后调用析构函数这是错误的无法保证调用的对象不被修改而是意思是不修改调用的对象只要类方法不修改调用的对象就应将其声明为一个方法涉及到两个对象并返回一个对象时就要使用指针设置为对象的地址由于该函数返回了两个对象之一因此返回类型也应为引用使用则是的引用但没有引用在中构造函数只能在类定义中定义不可在类外定义不可以使用这种默认构造函数了但可以这样写这个结束号可加可不加指针对象就该这样使用因为声明类并没有创建对象将没有用于存储的空间这是正确的这是错误的不能使用它数据成员是数组时必须使用枚举在类声明中声明的枚举的作用域为整个类该常量与其他静态变量存储在一起而不是存储在对象中表示的是返回真假要重载运算符需使用被称为运算符函数的特殊函数形式将重载是数组索引运算符将两个数组相加可以定义一个表示数组的类并重载运算符运算符重载的目的是使运算符能对类产生作用一个是对整个成员数据相加一个是对一个成员数据相加相当函数名友元函数不是成员函数不能由对象调用一般是对重载运算符函数进行友元操作不能使用成员运算符来调用在定义时不用只是与成员函数有相同的访问权限是友元函数重载是成员函数重载可以这样使用表示的是类型的表示指针也即地址这个构造函数用于将类型的值转换为类类型将构造函数用作隐式转换函数把一个值赋给对象只能使用显示强制类型转换可以这样写转换函数没有声明返回类型但将返回所需的值也不使用调用的形式这是隐式转换显示转换函数功能相同的非转换函数对象将转换为类对象进行相加类的动态内存分配不仅可以及时删除内存还可以改变数组的长度在创建多个对象数组时而不浪费内存在类成员中使用指针字符串并不保存在对象中而是被单独保存在堆内存中对象保存了指到哪里去查找字符串的信息只是保存了指针将字符串复制到内存中即创建字符串的副本这是错误的这只保存了地址而没有创建字符串的副本这个使用的是复制构造函数而不是一般的构造函数一个对象初始化另一个对象但调用了赋值运算符复制构造函数的原型为它创建对象的一个副本指针都会调用复制构造函数都是生成一个临时对象一个对象赋给另一个对象这个对象也是对象的一个副本指针如果类中包含这样的静态数据成员即其值将在新对象被创建时发生改变则应该提供一个显示复制构造函数来处理计数问题这里复制的并不是字符串而是一个指向字符串的指针显示复制构造函数赋值运算符也是用了成员的复制的重载静态成员函数使用把字符串赋值给类对指针一般不使用引用输入运算符的重载必须要有把字符串赋值给类的赋值函数类库是可以修改的函数库是不能修改的类表示俱乐部的乒乓球成员类表示一些成员参加过乒乓球锦标赛公有继承对象包括基类对象创建派生类对象时程序首先创建基类对象派生类构造函数必须使用基类构造函数派生类更具体一些构造函数列表初始化派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数它有两个参数括号就包含两个参数这是调用了基类的默认构造函数参数虽然与基类默认构造函数不一样但可以使用将调用基类的复制构造函数基类指针可以指向派生类对象或引用派生类对象基类引用或指针参数可以指向基类对象或派生类对象也是一样的可以将基类对象初始化派生类对象也可以将派生类对象赋值给基类对象必须像一样先定义基类引用将调用隐式赋值构造函数即派生类对象是一个基类对象可以对基类执行的任何操作也可以对派生类对象执行香蕉是水果不可有律师就像是鲨鱼早餐是水果早餐有水果栈不是数组栈不包括数组索引多态公有继承虚方法使得派生类和基类对象使用的方法有所不同为基类声明一个虚析构函数也是一种惯例在中对数组的定义必须在栈区即使用但为了有更多的功能可以使用对于指针的定义可以是常量指针尤其是作为函数的参数时在中一般的地址可以像数组一样使用中的循环用处很大可以使用地址作为判断条件也可以使用数组作为判断条件相当于表示当数组有元素时继续循环在类中的第二个在参数为类时使用关于如果有是整数则会输出没有小数点也会输出不会是数字二维数组作为函数的参数时的写法模板类类似于类也是一种动态数组你可以在运行阶段设置对象的长度它是使用创建动态数组的替代品它是用和来管理内存必须包含头文件其次包含在命名空间中的长度为在你插入或添加值时自动调整长度或者括号中可以是常量也可以是变量模板类与数组一样对象的长度是固定的也使用栈不是堆不需定义结构变量就能使用结构了类的自动转换和强制类型转换数据类型的转换都是正确的将进行自动类型转换不会进行自动转换是不兼容的类型可进行强制类型转换下面的构造函数用于将类型的值转换为类类型介绍的是转换构造函数只能是接受一个参数的构造函数才能这样可以先创建一个临时的的对象并将作为初始值然后将临时对象的内容复制到中为类的隐式转换是自动进行的是关闭隐式转换但仍然允许显式强制类型转换转换还存在二义性还可以用于将值传递给接受参数的函数如果提供了构造函数并且是成员函数的加法函数则可以这样做但只有友元函数才允许这样做转换函数转换函数的概念是将类类型转换为某种类型是用户定义的强制类型转换转换函数必须是类方法不能指定返回类型不能有参数转换为类型的函数返回一个数注意虽然没有声明返回类型但也将返回所需的值是四舍五入的方式而不是去掉小数部分类类型转换为某种类型也会存在二义性不能用于转换函数但可以使用非转换函数替换只能进行强制转换是非法的可以警告应谨慎地使用隐式转换函数通常使用显式的强制类型转换转换函数和友元函数实现加法时的选择要将量和量相加可以有两种方法第十二章类和动态内存分配动态内存和类开发一个动态内存类使用动态内存分配来开发类使用指针而不是数组这意味着类声明没有为字符串分配存储空间静态类成员特点无论创建了多少对象所有对象共享同一个静态成员例如成员可以记录所创建的对象数目不能在类声明中初始化静态成员变量只能在文件中初始化类外也不可以初始化但如果静态成员是整数类型或枚举类型见第十章则可以在类声明中初始化创建构造函数不会包括末尾的空字符记录对象的数量字符串并不保存在对象中而是保存在堆内存中对象仅保存了指出到哪里去查找字符串的信息不能这样做这只保存了地址而没有创建字符串副本析构函数的使用对象声明放在一个内部代码块中因为析构函数将在定义对象的代码块执行完毕时调用对象的删除的顺序与创建顺序相反在进行输出类时是运用了重载运算符注意查看重载运算符函数中输出的是什么内容编译器会自动生成成员函数和自动使用你不使用函数构造函数析构函数为复制构造函数会创建对象的一个副本调用了一个函数特殊成员函数特殊成员函数是自动定义的有默认构造函数如果没有定义默认析构函数如果没有定义复制构造函数如果没有定义赋值运算符如果没有定义地址运算符如果没有定义返回调用对象的地址即指针的值新增移动构造函数移动运算符默认构造函数如果定义了构造函数将不会定义默认构造函数如果希望在创建对象时不显示地对它进行初始话则必须显示地定义默认构造函数它还可以来设定特定的值在创建对象时不显示地对它进行初始话带参数的构造函数也可以是默认构造函数只要所有参数都有默认值但只有一个默认构造函数不然会造成二义性复制构造函数它用于初始化过程而不是常规的赋值过程每当程序生成了对象副本时编译器都将使用复制构造函数使用初始化一个匿名对象并将新对象的地址赋给指针当按值传递和返回对象时以及编译器生成临时对象例如将个对象相加时编译器可能生成临时的对象来保存中间结果都将调用复制构造函数复制构造函数初始化函数的形参由于按值传递对象将调用复制构造函数在用类为函数的参数时应该按引用传递对象如果成员本身就是类对象则将使用这个类的复制函数来复制成员对象静态成员不受影响因为它们属于整个类显示复制构造函数如果类中包含这样的静态数据成员即其值将在对象被创建时发生变化则应该提供一个显示复制构造函数来处理计数问题回到复制构造函数的哪里出了问题这里复制的并不是字符串而是一个指向字符串的指针得到两个指向同一个字符串的指针相当于由于私有成员是无法访问的因此这些代码是不能通过编译的指向的内容已经被的析构函数释放定义一个显式复制构造函数以解决问题深度复制该复制构造函数应当复制字符串并将副本的地址赋给成员如果类中包含了使用初始化的指针成员应当定义一个深度复制函数的其他问题赋值运算符赋值运算符的功能以及何时使用它将已有的对象赋给另一个对象时将使用重载的赋值运算符使用函数表示法时与复制构造函数相似赋值运算符也对成员进行逐个复制如果成员本身就是类对象则程序将使用为这个类定义的赋值运算符来复制该成员但静态数据成员不受影响赋值的问题与复制的问题的一样的解决赋值的问题函数返回一个指向调用对象的引用即指针代码首先检查自我复制这是通过查看赋值运算符右边的地址是否与接收对象的地址相同来完成的赋值操作并不创建新的对象因此不需要调整静态数据成员的值改进后的新类标准字符串函数库的功能空指针用于表示空指针重载运算符为对象数组输入内容为对象数组输出到屏幕上找到对象数组中最短的对象比较成员函数将比较函数作为友元有助于对象与常规的字符串进行比较将被转换为然后编译器将使用某个构造函数将代码转换为使用中括号表示法访问字符一般是在类这种数组中不是指它包含有四个对象而是第四个字符将赋给指向的引用访问的是私有数据但由于是类的一个方法因此能够修改数组的内容后三者是等同的是常量只能使用常量函数如果只有定义则下面的代码将出错因此提供常量版本静态类成员函数不能通过对象调用静态成员函数甚至不能使用指针它不属于对象属于类调用它的方式可以使用类名和作用域解析运算符调用它可以访问静态成员但不能访问两种的差别进一步重载赋值运算符将常规字符串复制到对象中一般来说必须释放指向的内存在构造函数中使用时应注意的事项如果有多个构造函数则必须以相同的方式使用要么带中括号要么不带中括号因为只有一个析构函数然而将指针初始化为空两种都兼容包含类成员的类的逐成员复制和都使用动态内存分配但不需要为类编写复制构造函数和赋值运算符会将使用成员类定义的复制构造函数和赋值运算符有关返回对象的说明返回指向对象的引用第一个与返回有关返回的是或和都被声明为引用所有才使用返回指向非对象引用的返回类型必须是而不能仅仅是如果使用返回类型将调用类的复制构造函数而类没有公有的复制构造函数返回对象如果被返回的对象是被调用函数中的局部变量则不应按引用方式返回它只能是返回对象使用指向对象的指针使用结构体的方式来使用成员使用初始化对象将调用复制构造函数这里指针指向创建的未被命名对象但复制构造函数会给它创建内容再谈定位运算符内存缓冲区实则指的是数组要这样做的原因在于不能与定位运算符配合使用将用于将自动调用为指向的的对象调用析构函数用于时不会为使用定位运算符创建的对象调用析构函数而是需要显示的调用析构函数一般情况下将自动调用析构函数这是需要显示调用析构函数的少数几种情况之一对地址输出的不同输出地址的方式不同定位运算符创建的对象的删除顺序与创建的顺序相反原因在于晚创建的对象可能依赖于早创建的对象另外当所有对象都被消除后才能释放缓冲区第章类继承面向对象编程的主要目的之一是提供可重用的代码通过继承完成的一些工作可以在已有的基础上添加功能例如对于数组类可以添加数学运算可以给类添加数据例如对于字符串类可以添加显示颜色的数据成员可以修改类方法的行为例如提供给飞机乘客的服务的类可以提供更高级别服务的类初始化列表语法可以减少一个步骤它直接使用的复制构造函数将初始化为一个简单的基类构造函数必须给新成员和继承的成员提供数据第二个构造函数使用一个类为参数包含继承类的构造函数的写法构造函数访问权限的考虑派生类不能直接访问基类的私有成员而必须通过基类方法进行访问列如构造函数不能直接设置继承的成员派生类构造函数必须使用基类构造函数创建派生类对象时程序首先创建基类对象使用成员初始化列表来完成调用了的构造函数省略了成员初始化列表程序将调用默认的基类构造函数等效有第二个构造函数的代码上述方法声明是在类外声明的与在类内声明的形式有很大的不一样释放对象的顺序与创建对象的顺序相反先执行派生类的析构函数派生类和基类之间的特殊关系基类指针或引用可以指向和引用派生类对象基类指针或引用只能用于调用基类方法不能使用基类指针或引用来调用派生类的方法对于形参为指向基类的指针或引用的函数也可以使用派生类作为实参按值传递将派生类对象的基类部分传递给函数引用兼容性属性让你能够将基类对象初始化为派生类对象要初始化基类要调用构造函数的原型基类定义中没有这样的构造函数但存在隐式复制构造函数同样也可以将派生类对象赋给基类对象将使用隐式重载赋值运算符继承关系公有继承是最常用的方式它建立一种关系新类将继承原始类的所有数据成员公有继承不建立关系关系午餐有水果将水果的对象作为午餐类的数据成员公有继承不建立关系即律师就像鲨鱼不应从鲨鱼类派生出律师类继承可以在基类的基础上添加基础但不能删除基类的属性公有继承不建立关系即作为来实现使用数组来实现栈不可以因为栈不是数组所以坚持使用的关系当满足的关系就可以使用公有继承多态公有继承概念同一个方法在派生类和基类中的行为是不同的即称为多态具有多种形态两种实现方法在派生类中重新定义基类的方法使用虚方法开发类和类虚方法的定义会在派生类中重新定义基类的方法但函数名一样的关键字只用于类声明的方法原型中引用类型或指针类型选择方法在继承类中的使用方法没有使用将根据引用类型或指针类型选择方法本应该这样定义的引用变量的类型为所以都为方法使用将根据引用类型或指针类型选择方法本应该这样定义的第二个是可以在派生类方法中调用基类的方法如果该方法是虚方法是使用作用域解析运算符来调用基类方法而不是派生类对象来调用方法如果不是虚方法则不必使用作用域解析运算符使用格式化方法和将浮点值的输出模式设置为定点创建指向的指针数组可以使用一个数组来表示多种类型的对象这也是多态指针既可以指向对象也可以指向对象与一般的数组定义是完全不一样的是的指针数组所以可以进行分配内存类对象的输入与一般的数据输入是不一样的多态是由下述代码提供的指的是指针不是值为何需要虚构函数静态联编和动态联编在编译过程就知道使用哪一个函数是静态联编因为虚函数的存在编译器不知道用户将选择哪种类型的对象只能在程序运行的时候确定正确的虚函数方法叫动态联编总之编译器对虚方法使用动态联编根据对象类型将关联到或指针和引用类型的兼容性不允许将一种类型地址或引用赋给另一种类型的指针或引用但基类和派生类可以而不必进行类型转换虚函数的工作原理给每个对象添加一个隐藏成员隐藏成员是一个指向函数地址数组的指针被称为虚函数表虚析构函数析构函数应当是虚函数即使它不执行任何操作除非类不用做基类析构函数不应进行操作如果没有虚析构函数语句将调用析构函数将释放派生类对象中的基类部分指向的内存但不会释放新的类成员指向的内存如果有虚析构函数则先调用析构函数在调用析构函数虚函数的参数要相同但返回值可以不同重新定义将隐藏方法两个都将被隐藏重新定义继承的方法并不是重载将隐藏所有的同名基类的方法访问控制与相似在类外只能用公有类成员来访问部分中的类成员区别在于继承方面派生类的成员可以直接访问基类的保护成员但不能直接访问基类的私有成员在派生类中与公有成员相识例如可以编写只有在派生类中可以这样使用保护数据成员可以简化代码的编写工作但又使保护数据成员成为公有变量被轻易修改抽象基类前面已经接受了简单继承和多态继承另一种建立继承的方法类和类有共点可以建立拥有他们共同点的类这个类还包含类和类不的同的方法应被声明为虚函数但至少应有一个纯虚函数抽象函数通过使用纯虚函数来提供未实现的函数当类声明中包含纯虚函数时则不能创建该类的对象只能用做基类因此可以从类派生出类和类类和类被称为具体类具有相同的基类可以用指针数组同时管理这两种对象类的纯虚函数也应该定于应用概念是一种必须实施的接口这种模式在基于组件的编程模式中很常见每个或者派生类是组件继承和动态内存分配第一种情况派生类不使用基类使用动态内存分配包含特殊方法析构函数复制构造函数重载赋值运算符而派生类不需要第二种情况派生类使用必须为派生类定义特殊方法派生类的析构函数派生类的复制构造函数是基类的引用可以指向派生类型派生类的重载赋值运算符显示调用基类赋值运算符对指针的返回返回类型也是引用不可用代替不然编译器会从而形成递归调用友元的继承类的友元访问和的方法使用强制类型转换第章中的代码重用可以定义一个通用的栈模板然后创建表示或值栈的类包含对象成员的类对于考试分数可以使用一个定长数组这限制了数组的长度可以使用动态内存分配的指针并提供大量的支持代码也可以使用动态内存分配的类表示该数组还可以在标准库中查找一个表示这种数据的类自己开发这样的类一点问题也没有类简介它支持将数组中所有元素的值相加以及在数组中找出最大和最小的值的操作提供的算术支持比和的多几个使用其构造函数的例子指定长度的空数组初始化列表先有长度再有数值长度放后面这个类的方法返回数组的长度返回字符串的长度类的设计可以从和这两个类派生出类这是多重公有继承一种关系但这里并不合适学生类与这些类不是的关系模板类一般使用自定义的形式也在放在私有部分意味着可以在类的实现中使用它当在类外面不能使用在类中可以直接使用和这两个类的方法初始化被包含的对象时构造函数将使用成员名因为初始化的是成员对象而不是继承的对象在构造函数有一个参数时考虑隐式转换函数没有使用可以写如下将创建一个个元素的对象但着一般是不允许的如果使用了将会发生错误初始化顺序它们被声明的顺序而不是它们在初始化列表中的顺序先初始化成员而不是成员在一个成员的值作为另一个成员的初始化表达式的一部分使初始化的顺序就非常重要是一个对象所以调用函数可以使用类的方法同样该函数也可以实现的输出但没有重载运算符因此类定义了一个私有辅助方法引用返回的更快在包含函数的文件中一般还自定义函数私有继承另一种实现关系的途径私有继承基类的公有成员和保护成员都将成为派生类的私有成员可以在派生类的成员函数中使用它们即只能在派生类的方法中使用基类的方法是使用接口与包含的特性一致也是将另外两个类的对象做为的成员是使用实现访问限定符的默认类型是私有类应从两个类派生而来使用多个基类的继承被称为多重继承包含与私有继承的区别包含提供了两个对象成员而私有继承提供了两个无名的子对象成员初始化基类组件有隐式地继承组件和显式地包含组件私有继承类的构造函数将使用类名来初始化访问基类的方法在没有确定对象时可以使用类名和作用域解析运算符来调用基类的方法但函数的作用域与方法的作用域不一致时就使用解析运算符访问基类对象使用强制类型转换将对象转换为对象表示对象为避免调用构造函数创建新的对象可使用强制类型转换来创建一个引用访问基类的友元函数用类名显式地限定函数名不合适于友元函数可以使用显示地转换为基类来调用正确的函数不修改的强制类型转换调用时并不是输出类的全部成员而只是要进入函数里面去看过程使用修改后的类两个版本的类的公有接口方法完全相同因此可以使用同一个程序测试它们使用包含比私有继承好如果某个类需要个对象可以使用包含声明个独立的成员如果新类需要访问原有类的保护成员或需要重新定义虚函数则应使用私有继承保护继承第三代类体现出保护继承和私有继承的区别使用重新定义访问权限在派生类类外调用基类对象的方法使用一个声明来指出派生类可以使用特定的基类成员即使采用的是私有派生可以这样使用声明只使用成员名没有圆括号函数特征标和返回类型多重继承类模板不如编写一个泛型栈然后将具体的类型作为参数传递给这个类这样就可以使用不同类型的栈例如栈和栈定义模板类为函数名尖括号中的内容相当于函数的参数列表看作是变量的类型名看作变量的名称可以使用模板成员函数替换原有类的类方法每个函数头都将以相同模板声明打头应改为作用域解析符与类名也要改如果在类声明中定义了方法内联定义则可以省略模板前缀和类限定符不能将模板成员函数放在独立的实现文件中由于模板不是函数它们不能单独编译使用类模板使用的算法必须与类型一致一般与是可以用在同一个模板类中的栈与指针栈有相同的功能但不能用在同一个模板类中指针栈指针模板使用一个指针数组其中每个指针都指向不同的字符串用使用动态数组返回类型为类时也要使用这是缩写只能在类中使用数组模板示例和非类型参数模板常用作容器类主要是为容器类提供可重用代码数组模板的成员是数组为类型参数为非类型或表达式参数编译器将使用替换使用替换表达式参数可以是整型枚举引用或指针因此是不合法的但是合法的模板代码不能修改参数的值也不能使用参数的地址如和用作参数的值必须是常量表达式介绍一个允许指定数组大小的简单数组模板第一种使用动态数组和构造函数参数来提供元素数目第二种使用模板参数来提供常规数组的大小就是这样做的表达式参数方法的缺点每种数组大小都将生成自己的模板将生成两个独立的类声明使用动态数组和构造函数参数的方法的优点更通用数组大小是作为类成员存储在定义中的可以将一种大小的数组赋给另一种大小的数组模板的多功能性模板类可用作基类也可用作组件类还可用作其他模板的类型参数递归使用模板对于前面的数组模板定义这使得是一个包含个元素的数组其中每个元素都是一个包含个元素的数组与之等价的常规数组声明即使没有这样的函数也可以这样使用控制输出宽度的方法使用多个类型参数模板类的类名是而不是默认类型模板参数为型为型模板的具体化隐式实例化显式实例化之后将生成一个类显式具体化假设模板使用运算符来对值进行比较对于数字这管用如果是将不管用这将要求类定义使用而不是来对值进行比较这种情况下可以提供一个显式模板具体化即为一种具体类型定义的模板而不是泛型定义的模板部分具体化第二个声明使用通用模板时将转换为类型如果是部分具体化将转换为模板该考虑的类型常规类型成员模板模板可用作结构类或模板类的成员在模板外定义类和方法模板是嵌套的还必须指出和是类的成员而不能使用将模板用作参数是可以将类进行更改模板类和友元模板别名第章友元异常和其他友元友元类的所有方法都可以访问原始类的私有成员和保护成员友元类编写一个模拟电视机和遥控器的简单程序遥控器可以改变电视机的状态而不是的关系因此将类作为类的一个友元必须先定义放在公有位置满足的是一种先有电视再有遥控器的关系友元成员函数让特定是类成员成为另一个类的友元而不必让整个类成为友元让成为类的友元的方法是在类声明中将其声明为友元使用的是类的成员所以必须是友元必须使用前向声明声明中只包含方法声明并将实际的定义放在类之后其他友元关系共同的友元嵌套类").trim().substring(0, num)

      const queryParams = `key=${options.key}&content=${truncateDescription}`;
      const requestOptions = {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Referer: options.Referer
        },
      };
      try {
        let animationInterval = null
        if (animationInterval) clearInterval(animationInterval);
        animationInterval = setInterval(() => {
          const animationText = "生成中" + ".".repeat(j);
          explanation.innerHTML = animationText;
          j = (j % 3) + 1; // 在 1、2、3 之间循环
        }, 500);
        const response = await fetch(`https://summary.tianli0.top/?${queryParams}`, requestOptions);
        const result = await response.json();
        const summary = result.summary.trim();
        setTimeout(() => {
          aiTitleRefreshIcon.style.opacity = "1";
        }, 300)
        startAI(summary);
        clearInterval(animationInterval)

      } catch (error) {
        console.error(error);
        explanation.innerHTML = "发生异常" + error;
      }
    } else {
      const strArr = "true".split(",").map(item => item.trim()); // 将字符串转换为数组，去除每个字符串前后的空格
      if (strArr.length !== 1) {
        let randomIndex = Math.floor(Math.random() * strArr.length); // 随机生成一个索引
        while (randomIndex === lastAiRandomIndex) { // 如果随机到了上次的索引
          randomIndex = Math.floor(Math.random() * strArr.length); // 再次随机
        }
        lastAiRandomIndex = randomIndex; // 更新上次随机到的索引
        startAI(strArr[randomIndex]);
      } else {
        startAI(strArr[0])
      }
      setTimeout(() => {
        aiTitleRefreshIcon.style.opacity = "1";
      }, 600)
    }
  }

  function aiRecommend() {
    i = 0; //重置计数器
    j = 1;
    clearSTO();
    animationRunning = false;
    elapsed = 0;
    explanation.innerHTML = "生成中. . .";
    ai_str = "";
    ai_str_length = "";
    observer.disconnect(); // 暂停上一次监听
    sto[2] = setTimeout(() => {
      explanation.innerHTML = recommendList();
    }, 600);
  }
  function aiGoHome() {
    startAI("正在前往博客主页...", false);
    sto[2] = setTimeout(() => {
      pjax.loadUrl("/");
    }, 1000);
  }
  const ai_btn_item = document.querySelectorAll(".ai-btn-item");
  function Introduce() {
    if (mode == "tianli") {
      startAI("我是文章辅助AI: TianliGPT，点击下方的按钮，让我生成本文简介、推荐相关文章等。")
    } else {
      startAI("我是文章辅助AI: AnZhiYu GPT，点击下方的按钮，让我生成本文简介、推荐相关文章等。")
    }
  }
  function aiTitleRefreshIconClick() {
    aiTitleRefreshIcon.click()
  }
  const aiFunctions = [Introduce, aiTitleRefreshIconClick, aiRecommend, aiGoHome];
  ai_btn_item.forEach((item, index) => {
    item.addEventListener("click", () => {
      aiFunctions[index]();
    });
  });

  function recommendList() {
    let thumbnail = document.querySelectorAll('.relatedPosts-list a');
    if (!thumbnail.length) {
      const cardRecentPost = document.querySelector('.card-widget.card-recent-post'); 
      if (!cardRecentPost) return '';

      thumbnail = cardRecentPost.querySelectorAll('.aside-list-item a');

      let list = '';
      for (let i = 0; i < thumbnail.length; i++) {
        const item = thumbnail[i];
        list += `<div class="ai-recommend-item"><span class="index">${i + 1}：</span><a href="javascript:;" onclick="pjax.loadUrl('${item.href}')" title="${item.title}" data-pjax-state="">${item.title}</a></div>`;
      }
      
      return `很抱歉，无法找到类似的文章，你也可以看看本站最新发布的文章：<br /><div class="ai-recommend">${list}</div>`;
    }

    let list = '';
    for (let i = 0; i < thumbnail.length; i++) {
      const item = thumbnail[i];
      list += `<div class="ai-recommend-item"><span>推荐${i + 1}：</span><a href="javascript:;" onclick="pjax.loadUrl('${item.href}')" title="${item.title}" data-pjax-state="">${item.title}</a></div>`;
    }

    return `推荐文章：<br /><div class="ai-recommend">${list}</div>`;
  }


  function changeShowMode() {
    if (mode === "tianli") {
      mode = "local";
      document.getElementById("ai-tag").innerHTML = "AnZhiYu GPT";
      aiAbstract(1000);
    } else {
      mode = "tianli";
      document.getElementById("ai-tag").innerHTML = "Tianli GPT";

      const truncateDescription = ("" + "C++, 11.6类的自动转换和强制类型转换, 11.6.1转换函数, 11.6.2转换函数和友元函数, 第十二章 类和动态内存分配, 12.1动态内存和类, 12.1.1开发一个动态内存类, 12.1.2 特殊成员函数, 12.1.3 回到Stringbad 复制构造函数的哪里出了问题, 12.1.4 StringBad的其他问题：赋值运算符, 改进后的新Stirng类, 12.2.2比较成员函数, 12.2.3使用中括号表示法访问字符, 12.2.4 静态类成员函数, 12.2.5 进一步重载赋值运算符, 12.3 在构造函数中使用new时应注意的事项, 12.3.1 包含类成员的类的逐成员复制, 12.4 有关返回对象的说明, 12.4.1 返回指向const对象的引用, 12.4.2 返回指向非const对象引用, 12.4.3 返回对象, 12.5 使用指向对象的指针, 12.5.1 再谈定位new运算符, 第13章 类继承, 13.1 一个简单的基类, 13.1.1, 13.1.2 构造函数：访问权限的考虑, 13.1.4 派生类和基类之间的特殊关系, 13.2 继承：is-a关系, 13.3 多态公有继承, 13.3.1 开发Brass类和BrassPlus类, 13.4 静态联编和动态联编, 13.4.1 指针和引用类型的兼容性, 13.5 访问控制：protected, 13.6 抽象基类(ABC), 13.6.1 应用ABC概念, 13.7 继承和动态内存分配, 13.7.1 第一种情况：派生类不使用new, 13.7.2 第二种情况：派生类使用new, 13.7.3 友元的继承, 第14章 c++中的代码重用, 14.1 包含对象成员的类, 14.1.1 valarray类简介, 14.1.2 Student类的设计, 14.2 私有继承, 14.2.1 初始化基类组件, 14.2.2 访问基类的方法, 14.2.3 访问基类对象, 14.2.3 访问基类的友元函数, 14.2.4 使用修改后的Student类, 14.2.5 保护继承, 14.2.6 使用using重新定义访问权限, 14.3 多重继承, 14.4 类模板, 14.4.1 定义模板类, 14.4.2 使用类模板, 14.4.3 指针栈x2F指针模板, 14.4.4 数组模板示例和非类型参数, 14.4.4 模板的多功能性, 14.4.6 模板的具体化, 14.4.7 成员模板, 14.4.8 将模板用作参数, 14.4.8 模板类和友元, 14.4.8 模板别名, 第15章 友元、异常和其他, 15.1 友元, 15.1.1 友元类, 15.1.2 友元成员函数, 15.1.3 其他友元关系, 15.1.4 共同的友元, 15.2 嵌套类在中对数组的定义必须在栈区即使用但为了有更多的功能可以使用对于指针的定义可以是常量指针尤其是作为函数的参数时在中一般的地址可以像数组一样使用中的循环用处很大可以也可以使用地址作为判断条件相当于表示当数组有元素时继续循环在类中的第二个的在参数为类时使用的关于如果有是整数则会输出没有小数点也会是不会是数字二维数组作为函数的参数时的写法模板类类似于类也是一种动态数组你可以在运行阶段设置对象的长度它是使用创建动态数组的替代品它是用和来管理内必须包含头文件其次包含在名称空间中的长度为在你插入或添加值时自动调整长度或者括号中可以是常量也可以是变量模板类与数组一样对象的长度是固定的也使用栈不是堆不需定义结构变量就能使用结构了使用类必须包含头文件是用来计算对象的长度的可以将关系运算符用于对象指向一个的值为不能修改都不可以但可以这样在声明函数的指针形参时或数组形参时一定要声明为指向的指针强制类型转换运算符有字符函数库二维数组作为函数时的使用列数是固定的函数可变返回引用时最重要的一点是应避免返回函数终止时不再存在的内存单元引用可以返回在函数中的成员作为返回值因为是在堆中而不是栈中函数模板的用途进行数值的交换函数重载的作用是在不同的参数如数组和结构与普通的常量时使得方法不一样而导致要重新写方法但要达到的目的是一致的这是模板与重载的结合使用使得的功能更丰富交换了结构体的成员运用了显式具体化则运用了显式实列化没有自己的方法定位运算符第二次分配的用法不可使用一般的才可以都是输出字符串地址的方法强制转换为静态变量的用法链接性为外部的静态变量链接性为外部的静态变量并且让内部使用链接性为内部的静态变量无链接性的静态变量创建新的名称空间所创建的每个新对象都有自己的存储空间用于存储其内部变量和类成员但同一个类的所有对象共享同一组类方法即每种方法只有一个副本在中调用成员函数被称为发送消息因此将同样的消息发送给两个不同的对象将调用同一个方法但该方法被用于两个不同的对象为对象动态分配存储空间在这种情况下对象没有名称但可以使用指针来管理该对象叫对象指针构造函数与的结合在构造函数构造出对象之前对象是不存在的因此构造函数被用来创建对象而不是用对象调用的定义默认构造函数的两种方法提供的默认构造函数它创建对象但不初始化其成员这样创建后可以不用显示初始化不需要打技术用来防止多重包含对象已经存在因此这条语句不是进行初始化而是将新值赋给它会创建一个新的临时的对象然后调用析构函数这是错误的无法保证调用的对象不被修改而是意思是不修改调用的对象只要类方法不修改调用的对象就应将其声明为一个方法涉及到两个对象并返回一个对象时就要使用指针设置为对象的地址由于该函数返回了两个对象之一因此返回类型也应为引用使用则是的引用但没有引用在中构造函数只能在类定义中定义不可在类外定义不可以使用这种默认构造函数了但可以这样写这个结束号可加可不加指针对象就该这样使用因为声明类并没有创建对象将没有用于存储的空间这是正确的这是错误的不能使用它数据成员是数组时必须使用枚举在类声明中声明的枚举的作用域为整个类该常量与其他静态变量存储在一起而不是存储在对象中表示的是返回真假要重载运算符需使用被称为运算符函数的特殊函数形式将重载是数组索引运算符将两个数组相加可以定义一个表示数组的类并重载运算符运算符重载的目的是使运算符能对类产生作用一个是对整个成员数据相加一个是对一个成员数据相加相当函数名友元函数不是成员函数不能由对象调用一般是对重载运算符函数进行友元操作不能使用成员运算符来调用在定义时不用只是与成员函数有相同的访问权限是友元函数重载是成员函数重载可以这样使用表示的是类型的表示指针也即地址这个构造函数用于将类型的值转换为类类型将构造函数用作隐式转换函数把一个值赋给对象只能使用显示强制类型转换可以这样写转换函数没有声明返回类型但将返回所需的值也不使用调用的形式这是隐式转换显示转换函数功能相同的非转换函数对象将转换为类对象进行相加类的动态内存分配不仅可以及时删除内存还可以改变数组的长度在创建多个对象数组时而不浪费内存在类成员中使用指针字符串并不保存在对象中而是被单独保存在堆内存中对象保存了指到哪里去查找字符串的信息只是保存了指针将字符串复制到内存中即创建字符串的副本这是错误的这只保存了地址而没有创建字符串的副本这个使用的是复制构造函数而不是一般的构造函数一个对象初始化另一个对象但调用了赋值运算符复制构造函数的原型为它创建对象的一个副本指针都会调用复制构造函数都是生成一个临时对象一个对象赋给另一个对象这个对象也是对象的一个副本指针如果类中包含这样的静态数据成员即其值将在新对象被创建时发生改变则应该提供一个显示复制构造函数来处理计数问题这里复制的并不是字符串而是一个指向字符串的指针显示复制构造函数赋值运算符也是用了成员的复制的重载静态成员函数使用把字符串赋值给类对指针一般不使用引用输入运算符的重载必须要有把字符串赋值给类的赋值函数类库是可以修改的函数库是不能修改的类表示俱乐部的乒乓球成员类表示一些成员参加过乒乓球锦标赛公有继承对象包括基类对象创建派生类对象时程序首先创建基类对象派生类构造函数必须使用基类构造函数派生类更具体一些构造函数列表初始化派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数它有两个参数括号就包含两个参数这是调用了基类的默认构造函数参数虽然与基类默认构造函数不一样但可以使用将调用基类的复制构造函数基类指针可以指向派生类对象或引用派生类对象基类引用或指针参数可以指向基类对象或派生类对象也是一样的可以将基类对象初始化派生类对象也可以将派生类对象赋值给基类对象必须像一样先定义基类引用将调用隐式赋值构造函数即派生类对象是一个基类对象可以对基类执行的任何操作也可以对派生类对象执行香蕉是水果不可有律师就像是鲨鱼早餐是水果早餐有水果栈不是数组栈不包括数组索引多态公有继承虚方法使得派生类和基类对象使用的方法有所不同为基类声明一个虚析构函数也是一种惯例在中对数组的定义必须在栈区即使用但为了有更多的功能可以使用对于指针的定义可以是常量指针尤其是作为函数的参数时在中一般的地址可以像数组一样使用中的循环用处很大可以使用地址作为判断条件也可以使用数组作为判断条件相当于表示当数组有元素时继续循环在类中的第二个在参数为类时使用关于如果有是整数则会输出没有小数点也会输出不会是数字二维数组作为函数的参数时的写法模板类类似于类也是一种动态数组你可以在运行阶段设置对象的长度它是使用创建动态数组的替代品它是用和来管理内存必须包含头文件其次包含在命名空间中的长度为在你插入或添加值时自动调整长度或者括号中可以是常量也可以是变量模板类与数组一样对象的长度是固定的也使用栈不是堆不需定义结构变量就能使用结构了类的自动转换和强制类型转换数据类型的转换都是正确的将进行自动类型转换不会进行自动转换是不兼容的类型可进行强制类型转换下面的构造函数用于将类型的值转换为类类型介绍的是转换构造函数只能是接受一个参数的构造函数才能这样可以先创建一个临时的的对象并将作为初始值然后将临时对象的内容复制到中为类的隐式转换是自动进行的是关闭隐式转换但仍然允许显式强制类型转换转换还存在二义性还可以用于将值传递给接受参数的函数如果提供了构造函数并且是成员函数的加法函数则可以这样做但只有友元函数才允许这样做转换函数转换函数的概念是将类类型转换为某种类型是用户定义的强制类型转换转换函数必须是类方法不能指定返回类型不能有参数转换为类型的函数返回一个数注意虽然没有声明返回类型但也将返回所需的值是四舍五入的方式而不是去掉小数部分类类型转换为某种类型也会存在二义性不能用于转换函数但可以使用非转换函数替换只能进行强制转换是非法的可以警告应谨慎地使用隐式转换函数通常使用显式的强制类型转换转换函数和友元函数实现加法时的选择要将量和量相加可以有两种方法第十二章类和动态内存分配动态内存和类开发一个动态内存类使用动态内存分配来开发类使用指针而不是数组这意味着类声明没有为字符串分配存储空间静态类成员特点无论创建了多少对象所有对象共享同一个静态成员例如成员可以记录所创建的对象数目不能在类声明中初始化静态成员变量只能在文件中初始化类外也不可以初始化但如果静态成员是整数类型或枚举类型见第十章则可以在类声明中初始化创建构造函数不会包括末尾的空字符记录对象的数量字符串并不保存在对象中而是保存在堆内存中对象仅保存了指出到哪里去查找字符串的信息不能这样做这只保存了地址而没有创建字符串副本析构函数的使用对象声明放在一个内部代码块中因为析构函数将在定义对象的代码块执行完毕时调用对象的删除的顺序与创建顺序相反在进行输出类时是运用了重载运算符注意查看重载运算符函数中输出的是什么内容编译器会自动生成成员函数和自动使用你不使用函数构造函数析构函数为复制构造函数会创建对象的一个副本调用了一个函数特殊成员函数特殊成员函数是自动定义的有默认构造函数如果没有定义默认析构函数如果没有定义复制构造函数如果没有定义赋值运算符如果没有定义地址运算符如果没有定义返回调用对象的地址即指针的值新增移动构造函数移动运算符默认构造函数如果定义了构造函数将不会定义默认构造函数如果希望在创建对象时不显示地对它进行初始话则必须显示地定义默认构造函数它还可以来设定特定的值在创建对象时不显示地对它进行初始话带参数的构造函数也可以是默认构造函数只要所有参数都有默认值但只有一个默认构造函数不然会造成二义性复制构造函数它用于初始化过程而不是常规的赋值过程每当程序生成了对象副本时编译器都将使用复制构造函数使用初始化一个匿名对象并将新对象的地址赋给指针当按值传递和返回对象时以及编译器生成临时对象例如将个对象相加时编译器可能生成临时的对象来保存中间结果都将调用复制构造函数复制构造函数初始化函数的形参由于按值传递对象将调用复制构造函数在用类为函数的参数时应该按引用传递对象如果成员本身就是类对象则将使用这个类的复制函数来复制成员对象静态成员不受影响因为它们属于整个类显示复制构造函数如果类中包含这样的静态数据成员即其值将在对象被创建时发生变化则应该提供一个显示复制构造函数来处理计数问题回到复制构造函数的哪里出了问题这里复制的并不是字符串而是一个指向字符串的指针得到两个指向同一个字符串的指针相当于由于私有成员是无法访问的因此这些代码是不能通过编译的指向的内容已经被的析构函数释放定义一个显式复制构造函数以解决问题深度复制该复制构造函数应当复制字符串并将副本的地址赋给成员如果类中包含了使用初始化的指针成员应当定义一个深度复制函数的其他问题赋值运算符赋值运算符的功能以及何时使用它将已有的对象赋给另一个对象时将使用重载的赋值运算符使用函数表示法时与复制构造函数相似赋值运算符也对成员进行逐个复制如果成员本身就是类对象则程序将使用为这个类定义的赋值运算符来复制该成员但静态数据成员不受影响赋值的问题与复制的问题的一样的解决赋值的问题函数返回一个指向调用对象的引用即指针代码首先检查自我复制这是通过查看赋值运算符右边的地址是否与接收对象的地址相同来完成的赋值操作并不创建新的对象因此不需要调整静态数据成员的值改进后的新类标准字符串函数库的功能空指针用于表示空指针重载运算符为对象数组输入内容为对象数组输出到屏幕上找到对象数组中最短的对象比较成员函数将比较函数作为友元有助于对象与常规的字符串进行比较将被转换为然后编译器将使用某个构造函数将代码转换为使用中括号表示法访问字符一般是在类这种数组中不是指它包含有四个对象而是第四个字符将赋给指向的引用访问的是私有数据但由于是类的一个方法因此能够修改数组的内容后三者是等同的是常量只能使用常量函数如果只有定义则下面的代码将出错因此提供常量版本静态类成员函数不能通过对象调用静态成员函数甚至不能使用指针它不属于对象属于类调用它的方式可以使用类名和作用域解析运算符调用它可以访问静态成员但不能访问两种的差别进一步重载赋值运算符将常规字符串复制到对象中一般来说必须释放指向的内存在构造函数中使用时应注意的事项如果有多个构造函数则必须以相同的方式使用要么带中括号要么不带中括号因为只有一个析构函数然而将指针初始化为空两种都兼容包含类成员的类的逐成员复制和都使用动态内存分配但不需要为类编写复制构造函数和赋值运算符会将使用成员类定义的复制构造函数和赋值运算符有关返回对象的说明返回指向对象的引用第一个与返回有关返回的是或和都被声明为引用所有才使用返回指向非对象引用的返回类型必须是而不能仅仅是如果使用返回类型将调用类的复制构造函数而类没有公有的复制构造函数返回对象如果被返回的对象是被调用函数中的局部变量则不应按引用方式返回它只能是返回对象使用指向对象的指针使用结构体的方式来使用成员使用初始化对象将调用复制构造函数这里指针指向创建的未被命名对象但复制构造函数会给它创建内容再谈定位运算符内存缓冲区实则指的是数组要这样做的原因在于不能与定位运算符配合使用将用于将自动调用为指向的的对象调用析构函数用于时不会为使用定位运算符创建的对象调用析构函数而是需要显示的调用析构函数一般情况下将自动调用析构函数这是需要显示调用析构函数的少数几种情况之一对地址输出的不同输出地址的方式不同定位运算符创建的对象的删除顺序与创建的顺序相反原因在于晚创建的对象可能依赖于早创建的对象另外当所有对象都被消除后才能释放缓冲区第章类继承面向对象编程的主要目的之一是提供可重用的代码通过继承完成的一些工作可以在已有的基础上添加功能例如对于数组类可以添加数学运算可以给类添加数据例如对于字符串类可以添加显示颜色的数据成员可以修改类方法的行为例如提供给飞机乘客的服务的类可以提供更高级别服务的类初始化列表语法可以减少一个步骤它直接使用的复制构造函数将初始化为一个简单的基类构造函数必须给新成员和继承的成员提供数据第二个构造函数使用一个类为参数包含继承类的构造函数的写法构造函数访问权限的考虑派生类不能直接访问基类的私有成员而必须通过基类方法进行访问列如构造函数不能直接设置继承的成员派生类构造函数必须使用基类构造函数创建派生类对象时程序首先创建基类对象使用成员初始化列表来完成调用了的构造函数省略了成员初始化列表程序将调用默认的基类构造函数等效有第二个构造函数的代码上述方法声明是在类外声明的与在类内声明的形式有很大的不一样释放对象的顺序与创建对象的顺序相反先执行派生类的析构函数派生类和基类之间的特殊关系基类指针或引用可以指向和引用派生类对象基类指针或引用只能用于调用基类方法不能使用基类指针或引用来调用派生类的方法对于形参为指向基类的指针或引用的函数也可以使用派生类作为实参按值传递将派生类对象的基类部分传递给函数引用兼容性属性让你能够将基类对象初始化为派生类对象要初始化基类要调用构造函数的原型基类定义中没有这样的构造函数但存在隐式复制构造函数同样也可以将派生类对象赋给基类对象将使用隐式重载赋值运算符继承关系公有继承是最常用的方式它建立一种关系新类将继承原始类的所有数据成员公有继承不建立关系关系午餐有水果将水果的对象作为午餐类的数据成员公有继承不建立关系即律师就像鲨鱼不应从鲨鱼类派生出律师类继承可以在基类的基础上添加基础但不能删除基类的属性公有继承不建立关系即作为来实现使用数组来实现栈不可以因为栈不是数组所以坚持使用的关系当满足的关系就可以使用公有继承多态公有继承概念同一个方法在派生类和基类中的行为是不同的即称为多态具有多种形态两种实现方法在派生类中重新定义基类的方法使用虚方法开发类和类虚方法的定义会在派生类中重新定义基类的方法但函数名一样的关键字只用于类声明的方法原型中引用类型或指针类型选择方法在继承类中的使用方法没有使用将根据引用类型或指针类型选择方法本应该这样定义的引用变量的类型为所以都为方法使用将根据引用类型或指针类型选择方法本应该这样定义的第二个是可以在派生类方法中调用基类的方法如果该方法是虚方法是使用作用域解析运算符来调用基类方法而不是派生类对象来调用方法如果不是虚方法则不必使用作用域解析运算符使用格式化方法和将浮点值的输出模式设置为定点创建指向的指针数组可以使用一个数组来表示多种类型的对象这也是多态指针既可以指向对象也可以指向对象与一般的数组定义是完全不一样的是的指针数组所以可以进行分配内存类对象的输入与一般的数据输入是不一样的多态是由下述代码提供的指的是指针不是值为何需要虚构函数静态联编和动态联编在编译过程就知道使用哪一个函数是静态联编因为虚函数的存在编译器不知道用户将选择哪种类型的对象只能在程序运行的时候确定正确的虚函数方法叫动态联编总之编译器对虚方法使用动态联编根据对象类型将关联到或指针和引用类型的兼容性不允许将一种类型地址或引用赋给另一种类型的指针或引用但基类和派生类可以而不必进行类型转换虚函数的工作原理给每个对象添加一个隐藏成员隐藏成员是一个指向函数地址数组的指针被称为虚函数表虚析构函数析构函数应当是虚函数即使它不执行任何操作除非类不用做基类析构函数不应进行操作如果没有虚析构函数语句将调用析构函数将释放派生类对象中的基类部分指向的内存但不会释放新的类成员指向的内存如果有虚析构函数则先调用析构函数在调用析构函数虚函数的参数要相同但返回值可以不同重新定义将隐藏方法两个都将被隐藏重新定义继承的方法并不是重载将隐藏所有的同名基类的方法访问控制与相似在类外只能用公有类成员来访问部分中的类成员区别在于继承方面派生类的成员可以直接访问基类的保护成员但不能直接访问基类的私有成员在派生类中与公有成员相识例如可以编写只有在派生类中可以这样使用保护数据成员可以简化代码的编写工作但又使保护数据成员成为公有变量被轻易修改抽象基类前面已经接受了简单继承和多态继承另一种建立继承的方法类和类有共点可以建立拥有他们共同点的类这个类还包含类和类不的同的方法应被声明为虚函数但至少应有一个纯虚函数抽象函数通过使用纯虚函数来提供未实现的函数当类声明中包含纯虚函数时则不能创建该类的对象只能用做基类因此可以从类派生出类和类类和类被称为具体类具有相同的基类可以用指针数组同时管理这两种对象类的纯虚函数也应该定于应用概念是一种必须实施的接口这种模式在基于组件的编程模式中很常见每个或者派生类是组件继承和动态内存分配第一种情况派生类不使用基类使用动态内存分配包含特殊方法析构函数复制构造函数重载赋值运算符而派生类不需要第二种情况派生类使用必须为派生类定义特殊方法派生类的析构函数派生类的复制构造函数是基类的引用可以指向派生类型派生类的重载赋值运算符显示调用基类赋值运算符对指针的返回返回类型也是引用不可用代替不然编译器会从而形成递归调用友元的继承类的友元访问和的方法使用强制类型转换第章中的代码重用可以定义一个通用的栈模板然后创建表示或值栈的类包含对象成员的类对于考试分数可以使用一个定长数组这限制了数组的长度可以使用动态内存分配的指针并提供大量的支持代码也可以使用动态内存分配的类表示该数组还可以在标准库中查找一个表示这种数据的类自己开发这样的类一点问题也没有类简介它支持将数组中所有元素的值相加以及在数组中找出最大和最小的值的操作提供的算术支持比和的多几个使用其构造函数的例子指定长度的空数组初始化列表先有长度再有数值长度放后面这个类的方法返回数组的长度返回字符串的长度类的设计可以从和这两个类派生出类这是多重公有继承一种关系但这里并不合适学生类与这些类不是的关系模板类一般使用自定义的形式也在放在私有部分意味着可以在类的实现中使用它当在类外面不能使用在类中可以直接使用和这两个类的方法初始化被包含的对象时构造函数将使用成员名因为初始化的是成员对象而不是继承的对象在构造函数有一个参数时考虑隐式转换函数没有使用可以写如下将创建一个个元素的对象但着一般是不允许的如果使用了将会发生错误初始化顺序它们被声明的顺序而不是它们在初始化列表中的顺序先初始化成员而不是成员在一个成员的值作为另一个成员的初始化表达式的一部分使初始化的顺序就非常重要是一个对象所以调用函数可以使用类的方法同样该函数也可以实现的输出但没有重载运算符因此类定义了一个私有辅助方法引用返回的更快在包含函数的文件中一般还自定义函数私有继承另一种实现关系的途径私有继承基类的公有成员和保护成员都将成为派生类的私有成员可以在派生类的成员函数中使用它们即只能在派生类的方法中使用基类的方法是使用接口与包含的特性一致也是将另外两个类的对象做为的成员是使用实现访问限定符的默认类型是私有类应从两个类派生而来使用多个基类的继承被称为多重继承包含与私有继承的区别包含提供了两个对象成员而私有继承提供了两个无名的子对象成员初始化基类组件有隐式地继承组件和显式地包含组件私有继承类的构造函数将使用类名来初始化访问基类的方法在没有确定对象时可以使用类名和作用域解析运算符来调用基类的方法但函数的作用域与方法的作用域不一致时就使用解析运算符访问基类对象使用强制类型转换将对象转换为对象表示对象为避免调用构造函数创建新的对象可使用强制类型转换来创建一个引用访问基类的友元函数用类名显式地限定函数名不合适于友元函数可以使用显示地转换为基类来调用正确的函数不修改的强制类型转换调用时并不是输出类的全部成员而只是要进入函数里面去看过程使用修改后的类两个版本的类的公有接口方法完全相同因此可以使用同一个程序测试它们使用包含比私有继承好如果某个类需要个对象可以使用包含声明个独立的成员如果新类需要访问原有类的保护成员或需要重新定义虚函数则应使用私有继承保护继承第三代类体现出保护继承和私有继承的区别使用重新定义访问权限在派生类类外调用基类对象的方法使用一个声明来指出派生类可以使用特定的基类成员即使采用的是私有派生可以这样使用声明只使用成员名没有圆括号函数特征标和返回类型多重继承类模板不如编写一个泛型栈然后将具体的类型作为参数传递给这个类这样就可以使用不同类型的栈例如栈和栈定义模板类为函数名尖括号中的内容相当于函数的参数列表看作是变量的类型名看作变量的名称可以使用模板成员函数替换原有类的类方法每个函数头都将以相同模板声明打头应改为作用域解析符与类名也要改如果在类声明中定义了方法内联定义则可以省略模板前缀和类限定符不能将模板成员函数放在独立的实现文件中由于模板不是函数它们不能单独编译使用类模板使用的算法必须与类型一致一般与是可以用在同一个模板类中的栈与指针栈有相同的功能但不能用在同一个模板类中指针栈指针模板使用一个指针数组其中每个指针都指向不同的字符串用使用动态数组返回类型为类时也要使用这是缩写只能在类中使用数组模板示例和非类型参数模板常用作容器类主要是为容器类提供可重用代码数组模板的成员是数组为类型参数为非类型或表达式参数编译器将使用替换使用替换表达式参数可以是整型枚举引用或指针因此是不合法的但是合法的模板代码不能修改参数的值也不能使用参数的地址如和用作参数的值必须是常量表达式介绍一个允许指定数组大小的简单数组模板第一种使用动态数组和构造函数参数来提供元素数目第二种使用模板参数来提供常规数组的大小就是这样做的表达式参数方法的缺点每种数组大小都将生成自己的模板将生成两个独立的类声明使用动态数组和构造函数参数的方法的优点更通用数组大小是作为类成员存储在定义中的可以将一种大小的数组赋给另一种大小的数组模板的多功能性模板类可用作基类也可用作组件类还可用作其他模板的类型参数递归使用模板对于前面的数组模板定义这使得是一个包含个元素的数组其中每个元素都是一个包含个元素的数组与之等价的常规数组声明即使没有这样的函数也可以这样使用控制输出宽度的方法使用多个类型参数模板类的类名是而不是默认类型模板参数为型为型模板的具体化隐式实例化显式实例化之后将生成一个类显式具体化假设模板使用运算符来对值进行比较对于数字这管用如果是将不管用这将要求类定义使用而不是来对值进行比较这种情况下可以提供一个显式模板具体化即为一种具体类型定义的模板而不是泛型定义的模板部分具体化第二个声明使用通用模板时将转换为类型如果是部分具体化将转换为模板该考虑的类型常规类型成员模板模板可用作结构类或模板类的成员在模板外定义类和方法模板是嵌套的还必须指出和是类的成员而不能使用将模板用作参数是可以将类进行更改模板类和友元模板别名第章友元异常和其他友元友元类的所有方法都可以访问原始类的私有成员和保护成员友元类编写一个模拟电视机和遥控器的简单程序遥控器可以改变电视机的状态而不是的关系因此将类作为类的一个友元必须先定义放在公有位置满足的是一种先有电视再有遥控器的关系友元成员函数让特定是类成员成为另一个类的友元而不必让整个类成为友元让成为类的友元的方法是在类声明中将其声明为友元使用的是类的成员所以必须是友元必须使用前向声明声明中只包含方法声明并将实际的定义放在类之后其他友元关系共同的友元嵌套类").trim().substring(0, 1000);
      let value = Math.floor(Math.random() * 3) + 1000;
      while (value === prevParam || truncateDescription.length - value === prevParam) {
        value = Math.floor(Math.random() * 3) + 1000;
      }
      aiTitleRefreshIcon.style.opacity = "0.2";
      aiTitleRefreshIcon.style.transitionDuration = "0.3s";
      aiTitleRefreshIcon.style.transform = "rotate(" + 360 * refreshNum + "deg)";
      if (truncateDescription.length <= 1000) {
        let param = truncateDescription.length - Math.floor(Math.random() * 3);
        while (param === prevParam) {
          param = truncateDescription.length - Math.floor(Math.random() * 3);
        }
        aiAbstract(param);
        prevParam = param;
      } else {
        aiAbstract(value);
        prevParam = value;
      }
      refreshNum++;
    }
  }

  //- 监听tag点击事件
  document.getElementById("ai-tag").addEventListener("click", () => {
    if (mode === "tianli") {
      document.querySelectorAll(".ai-btn-item").forEach(item => item.style.display = "none");
      document.getElementById("go-tianli-blog").style.display = "block";
      startAI("你好，我是Tianli开发的摘要生成助理TianliGPT，是一个基于GPT-4的生成式AI。我在这里只负责摘要的预生成和显示，你无法与我直接沟通，如果你也需要一个这样的AI摘要接口，可以在下方购买。（暂未开放购买，敬请期待）")
    } else {
      document.getElementById("go-tianli-blog").style.display = "none";
      startAI("你好，我是本站摘要生成助理AnZhiYu GPT，是一个基于GPT-4的生成式AI。我在这里只负责摘要的预生成和显示，你无法与我直接沟通。")
    }

  });

  aiTitleRefreshIcon.addEventListener("click", () => {
    const truncateDescription = ("" + "C++, 11.6类的自动转换和强制类型转换, 11.6.1转换函数, 11.6.2转换函数和友元函数, 第十二章 类和动态内存分配, 12.1动态内存和类, 12.1.1开发一个动态内存类, 12.1.2 特殊成员函数, 12.1.3 回到Stringbad 复制构造函数的哪里出了问题, 12.1.4 StringBad的其他问题：赋值运算符, 改进后的新Stirng类, 12.2.2比较成员函数, 12.2.3使用中括号表示法访问字符, 12.2.4 静态类成员函数, 12.2.5 进一步重载赋值运算符, 12.3 在构造函数中使用new时应注意的事项, 12.3.1 包含类成员的类的逐成员复制, 12.4 有关返回对象的说明, 12.4.1 返回指向const对象的引用, 12.4.2 返回指向非const对象引用, 12.4.3 返回对象, 12.5 使用指向对象的指针, 12.5.1 再谈定位new运算符, 第13章 类继承, 13.1 一个简单的基类, 13.1.1, 13.1.2 构造函数：访问权限的考虑, 13.1.4 派生类和基类之间的特殊关系, 13.2 继承：is-a关系, 13.3 多态公有继承, 13.3.1 开发Brass类和BrassPlus类, 13.4 静态联编和动态联编, 13.4.1 指针和引用类型的兼容性, 13.5 访问控制：protected, 13.6 抽象基类(ABC), 13.6.1 应用ABC概念, 13.7 继承和动态内存分配, 13.7.1 第一种情况：派生类不使用new, 13.7.2 第二种情况：派生类使用new, 13.7.3 友元的继承, 第14章 c++中的代码重用, 14.1 包含对象成员的类, 14.1.1 valarray类简介, 14.1.2 Student类的设计, 14.2 私有继承, 14.2.1 初始化基类组件, 14.2.2 访问基类的方法, 14.2.3 访问基类对象, 14.2.3 访问基类的友元函数, 14.2.4 使用修改后的Student类, 14.2.5 保护继承, 14.2.6 使用using重新定义访问权限, 14.3 多重继承, 14.4 类模板, 14.4.1 定义模板类, 14.4.2 使用类模板, 14.4.3 指针栈x2F指针模板, 14.4.4 数组模板示例和非类型参数, 14.4.4 模板的多功能性, 14.4.6 模板的具体化, 14.4.7 成员模板, 14.4.8 将模板用作参数, 14.4.8 模板类和友元, 14.4.8 模板别名, 第15章 友元、异常和其他, 15.1 友元, 15.1.1 友元类, 15.1.2 友元成员函数, 15.1.3 其他友元关系, 15.1.4 共同的友元, 15.2 嵌套类在中对数组的定义必须在栈区即使用但为了有更多的功能可以使用对于指针的定义可以是常量指针尤其是作为函数的参数时在中一般的地址可以像数组一样使用中的循环用处很大可以也可以使用地址作为判断条件相当于表示当数组有元素时继续循环在类中的第二个的在参数为类时使用的关于如果有是整数则会输出没有小数点也会是不会是数字二维数组作为函数的参数时的写法模板类类似于类也是一种动态数组你可以在运行阶段设置对象的长度它是使用创建动态数组的替代品它是用和来管理内必须包含头文件其次包含在名称空间中的长度为在你插入或添加值时自动调整长度或者括号中可以是常量也可以是变量模板类与数组一样对象的长度是固定的也使用栈不是堆不需定义结构变量就能使用结构了使用类必须包含头文件是用来计算对象的长度的可以将关系运算符用于对象指向一个的值为不能修改都不可以但可以这样在声明函数的指针形参时或数组形参时一定要声明为指向的指针强制类型转换运算符有字符函数库二维数组作为函数时的使用列数是固定的函数可变返回引用时最重要的一点是应避免返回函数终止时不再存在的内存单元引用可以返回在函数中的成员作为返回值因为是在堆中而不是栈中函数模板的用途进行数值的交换函数重载的作用是在不同的参数如数组和结构与普通的常量时使得方法不一样而导致要重新写方法但要达到的目的是一致的这是模板与重载的结合使用使得的功能更丰富交换了结构体的成员运用了显式具体化则运用了显式实列化没有自己的方法定位运算符第二次分配的用法不可使用一般的才可以都是输出字符串地址的方法强制转换为静态变量的用法链接性为外部的静态变量链接性为外部的静态变量并且让内部使用链接性为内部的静态变量无链接性的静态变量创建新的名称空间所创建的每个新对象都有自己的存储空间用于存储其内部变量和类成员但同一个类的所有对象共享同一组类方法即每种方法只有一个副本在中调用成员函数被称为发送消息因此将同样的消息发送给两个不同的对象将调用同一个方法但该方法被用于两个不同的对象为对象动态分配存储空间在这种情况下对象没有名称但可以使用指针来管理该对象叫对象指针构造函数与的结合在构造函数构造出对象之前对象是不存在的因此构造函数被用来创建对象而不是用对象调用的定义默认构造函数的两种方法提供的默认构造函数它创建对象但不初始化其成员这样创建后可以不用显示初始化不需要打技术用来防止多重包含对象已经存在因此这条语句不是进行初始化而是将新值赋给它会创建一个新的临时的对象然后调用析构函数这是错误的无法保证调用的对象不被修改而是意思是不修改调用的对象只要类方法不修改调用的对象就应将其声明为一个方法涉及到两个对象并返回一个对象时就要使用指针设置为对象的地址由于该函数返回了两个对象之一因此返回类型也应为引用使用则是的引用但没有引用在中构造函数只能在类定义中定义不可在类外定义不可以使用这种默认构造函数了但可以这样写这个结束号可加可不加指针对象就该这样使用因为声明类并没有创建对象将没有用于存储的空间这是正确的这是错误的不能使用它数据成员是数组时必须使用枚举在类声明中声明的枚举的作用域为整个类该常量与其他静态变量存储在一起而不是存储在对象中表示的是返回真假要重载运算符需使用被称为运算符函数的特殊函数形式将重载是数组索引运算符将两个数组相加可以定义一个表示数组的类并重载运算符运算符重载的目的是使运算符能对类产生作用一个是对整个成员数据相加一个是对一个成员数据相加相当函数名友元函数不是成员函数不能由对象调用一般是对重载运算符函数进行友元操作不能使用成员运算符来调用在定义时不用只是与成员函数有相同的访问权限是友元函数重载是成员函数重载可以这样使用表示的是类型的表示指针也即地址这个构造函数用于将类型的值转换为类类型将构造函数用作隐式转换函数把一个值赋给对象只能使用显示强制类型转换可以这样写转换函数没有声明返回类型但将返回所需的值也不使用调用的形式这是隐式转换显示转换函数功能相同的非转换函数对象将转换为类对象进行相加类的动态内存分配不仅可以及时删除内存还可以改变数组的长度在创建多个对象数组时而不浪费内存在类成员中使用指针字符串并不保存在对象中而是被单独保存在堆内存中对象保存了指到哪里去查找字符串的信息只是保存了指针将字符串复制到内存中即创建字符串的副本这是错误的这只保存了地址而没有创建字符串的副本这个使用的是复制构造函数而不是一般的构造函数一个对象初始化另一个对象但调用了赋值运算符复制构造函数的原型为它创建对象的一个副本指针都会调用复制构造函数都是生成一个临时对象一个对象赋给另一个对象这个对象也是对象的一个副本指针如果类中包含这样的静态数据成员即其值将在新对象被创建时发生改变则应该提供一个显示复制构造函数来处理计数问题这里复制的并不是字符串而是一个指向字符串的指针显示复制构造函数赋值运算符也是用了成员的复制的重载静态成员函数使用把字符串赋值给类对指针一般不使用引用输入运算符的重载必须要有把字符串赋值给类的赋值函数类库是可以修改的函数库是不能修改的类表示俱乐部的乒乓球成员类表示一些成员参加过乒乓球锦标赛公有继承对象包括基类对象创建派生类对象时程序首先创建基类对象派生类构造函数必须使用基类构造函数派生类更具体一些构造函数列表初始化派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数它有两个参数括号就包含两个参数这是调用了基类的默认构造函数参数虽然与基类默认构造函数不一样但可以使用将调用基类的复制构造函数基类指针可以指向派生类对象或引用派生类对象基类引用或指针参数可以指向基类对象或派生类对象也是一样的可以将基类对象初始化派生类对象也可以将派生类对象赋值给基类对象必须像一样先定义基类引用将调用隐式赋值构造函数即派生类对象是一个基类对象可以对基类执行的任何操作也可以对派生类对象执行香蕉是水果不可有律师就像是鲨鱼早餐是水果早餐有水果栈不是数组栈不包括数组索引多态公有继承虚方法使得派生类和基类对象使用的方法有所不同为基类声明一个虚析构函数也是一种惯例在中对数组的定义必须在栈区即使用但为了有更多的功能可以使用对于指针的定义可以是常量指针尤其是作为函数的参数时在中一般的地址可以像数组一样使用中的循环用处很大可以使用地址作为判断条件也可以使用数组作为判断条件相当于表示当数组有元素时继续循环在类中的第二个在参数为类时使用关于如果有是整数则会输出没有小数点也会输出不会是数字二维数组作为函数的参数时的写法模板类类似于类也是一种动态数组你可以在运行阶段设置对象的长度它是使用创建动态数组的替代品它是用和来管理内存必须包含头文件其次包含在命名空间中的长度为在你插入或添加值时自动调整长度或者括号中可以是常量也可以是变量模板类与数组一样对象的长度是固定的也使用栈不是堆不需定义结构变量就能使用结构了类的自动转换和强制类型转换数据类型的转换都是正确的将进行自动类型转换不会进行自动转换是不兼容的类型可进行强制类型转换下面的构造函数用于将类型的值转换为类类型介绍的是转换构造函数只能是接受一个参数的构造函数才能这样可以先创建一个临时的的对象并将作为初始值然后将临时对象的内容复制到中为类的隐式转换是自动进行的是关闭隐式转换但仍然允许显式强制类型转换转换还存在二义性还可以用于将值传递给接受参数的函数如果提供了构造函数并且是成员函数的加法函数则可以这样做但只有友元函数才允许这样做转换函数转换函数的概念是将类类型转换为某种类型是用户定义的强制类型转换转换函数必须是类方法不能指定返回类型不能有参数转换为类型的函数返回一个数注意虽然没有声明返回类型但也将返回所需的值是四舍五入的方式而不是去掉小数部分类类型转换为某种类型也会存在二义性不能用于转换函数但可以使用非转换函数替换只能进行强制转换是非法的可以警告应谨慎地使用隐式转换函数通常使用显式的强制类型转换转换函数和友元函数实现加法时的选择要将量和量相加可以有两种方法第十二章类和动态内存分配动态内存和类开发一个动态内存类使用动态内存分配来开发类使用指针而不是数组这意味着类声明没有为字符串分配存储空间静态类成员特点无论创建了多少对象所有对象共享同一个静态成员例如成员可以记录所创建的对象数目不能在类声明中初始化静态成员变量只能在文件中初始化类外也不可以初始化但如果静态成员是整数类型或枚举类型见第十章则可以在类声明中初始化创建构造函数不会包括末尾的空字符记录对象的数量字符串并不保存在对象中而是保存在堆内存中对象仅保存了指出到哪里去查找字符串的信息不能这样做这只保存了地址而没有创建字符串副本析构函数的使用对象声明放在一个内部代码块中因为析构函数将在定义对象的代码块执行完毕时调用对象的删除的顺序与创建顺序相反在进行输出类时是运用了重载运算符注意查看重载运算符函数中输出的是什么内容编译器会自动生成成员函数和自动使用你不使用函数构造函数析构函数为复制构造函数会创建对象的一个副本调用了一个函数特殊成员函数特殊成员函数是自动定义的有默认构造函数如果没有定义默认析构函数如果没有定义复制构造函数如果没有定义赋值运算符如果没有定义地址运算符如果没有定义返回调用对象的地址即指针的值新增移动构造函数移动运算符默认构造函数如果定义了构造函数将不会定义默认构造函数如果希望在创建对象时不显示地对它进行初始话则必须显示地定义默认构造函数它还可以来设定特定的值在创建对象时不显示地对它进行初始话带参数的构造函数也可以是默认构造函数只要所有参数都有默认值但只有一个默认构造函数不然会造成二义性复制构造函数它用于初始化过程而不是常规的赋值过程每当程序生成了对象副本时编译器都将使用复制构造函数使用初始化一个匿名对象并将新对象的地址赋给指针当按值传递和返回对象时以及编译器生成临时对象例如将个对象相加时编译器可能生成临时的对象来保存中间结果都将调用复制构造函数复制构造函数初始化函数的形参由于按值传递对象将调用复制构造函数在用类为函数的参数时应该按引用传递对象如果成员本身就是类对象则将使用这个类的复制函数来复制成员对象静态成员不受影响因为它们属于整个类显示复制构造函数如果类中包含这样的静态数据成员即其值将在对象被创建时发生变化则应该提供一个显示复制构造函数来处理计数问题回到复制构造函数的哪里出了问题这里复制的并不是字符串而是一个指向字符串的指针得到两个指向同一个字符串的指针相当于由于私有成员是无法访问的因此这些代码是不能通过编译的指向的内容已经被的析构函数释放定义一个显式复制构造函数以解决问题深度复制该复制构造函数应当复制字符串并将副本的地址赋给成员如果类中包含了使用初始化的指针成员应当定义一个深度复制函数的其他问题赋值运算符赋值运算符的功能以及何时使用它将已有的对象赋给另一个对象时将使用重载的赋值运算符使用函数表示法时与复制构造函数相似赋值运算符也对成员进行逐个复制如果成员本身就是类对象则程序将使用为这个类定义的赋值运算符来复制该成员但静态数据成员不受影响赋值的问题与复制的问题的一样的解决赋值的问题函数返回一个指向调用对象的引用即指针代码首先检查自我复制这是通过查看赋值运算符右边的地址是否与接收对象的地址相同来完成的赋值操作并不创建新的对象因此不需要调整静态数据成员的值改进后的新类标准字符串函数库的功能空指针用于表示空指针重载运算符为对象数组输入内容为对象数组输出到屏幕上找到对象数组中最短的对象比较成员函数将比较函数作为友元有助于对象与常规的字符串进行比较将被转换为然后编译器将使用某个构造函数将代码转换为使用中括号表示法访问字符一般是在类这种数组中不是指它包含有四个对象而是第四个字符将赋给指向的引用访问的是私有数据但由于是类的一个方法因此能够修改数组的内容后三者是等同的是常量只能使用常量函数如果只有定义则下面的代码将出错因此提供常量版本静态类成员函数不能通过对象调用静态成员函数甚至不能使用指针它不属于对象属于类调用它的方式可以使用类名和作用域解析运算符调用它可以访问静态成员但不能访问两种的差别进一步重载赋值运算符将常规字符串复制到对象中一般来说必须释放指向的内存在构造函数中使用时应注意的事项如果有多个构造函数则必须以相同的方式使用要么带中括号要么不带中括号因为只有一个析构函数然而将指针初始化为空两种都兼容包含类成员的类的逐成员复制和都使用动态内存分配但不需要为类编写复制构造函数和赋值运算符会将使用成员类定义的复制构造函数和赋值运算符有关返回对象的说明返回指向对象的引用第一个与返回有关返回的是或和都被声明为引用所有才使用返回指向非对象引用的返回类型必须是而不能仅仅是如果使用返回类型将调用类的复制构造函数而类没有公有的复制构造函数返回对象如果被返回的对象是被调用函数中的局部变量则不应按引用方式返回它只能是返回对象使用指向对象的指针使用结构体的方式来使用成员使用初始化对象将调用复制构造函数这里指针指向创建的未被命名对象但复制构造函数会给它创建内容再谈定位运算符内存缓冲区实则指的是数组要这样做的原因在于不能与定位运算符配合使用将用于将自动调用为指向的的对象调用析构函数用于时不会为使用定位运算符创建的对象调用析构函数而是需要显示的调用析构函数一般情况下将自动调用析构函数这是需要显示调用析构函数的少数几种情况之一对地址输出的不同输出地址的方式不同定位运算符创建的对象的删除顺序与创建的顺序相反原因在于晚创建的对象可能依赖于早创建的对象另外当所有对象都被消除后才能释放缓冲区第章类继承面向对象编程的主要目的之一是提供可重用的代码通过继承完成的一些工作可以在已有的基础上添加功能例如对于数组类可以添加数学运算可以给类添加数据例如对于字符串类可以添加显示颜色的数据成员可以修改类方法的行为例如提供给飞机乘客的服务的类可以提供更高级别服务的类初始化列表语法可以减少一个步骤它直接使用的复制构造函数将初始化为一个简单的基类构造函数必须给新成员和继承的成员提供数据第二个构造函数使用一个类为参数包含继承类的构造函数的写法构造函数访问权限的考虑派生类不能直接访问基类的私有成员而必须通过基类方法进行访问列如构造函数不能直接设置继承的成员派生类构造函数必须使用基类构造函数创建派生类对象时程序首先创建基类对象使用成员初始化列表来完成调用了的构造函数省略了成员初始化列表程序将调用默认的基类构造函数等效有第二个构造函数的代码上述方法声明是在类外声明的与在类内声明的形式有很大的不一样释放对象的顺序与创建对象的顺序相反先执行派生类的析构函数派生类和基类之间的特殊关系基类指针或引用可以指向和引用派生类对象基类指针或引用只能用于调用基类方法不能使用基类指针或引用来调用派生类的方法对于形参为指向基类的指针或引用的函数也可以使用派生类作为实参按值传递将派生类对象的基类部分传递给函数引用兼容性属性让你能够将基类对象初始化为派生类对象要初始化基类要调用构造函数的原型基类定义中没有这样的构造函数但存在隐式复制构造函数同样也可以将派生类对象赋给基类对象将使用隐式重载赋值运算符继承关系公有继承是最常用的方式它建立一种关系新类将继承原始类的所有数据成员公有继承不建立关系关系午餐有水果将水果的对象作为午餐类的数据成员公有继承不建立关系即律师就像鲨鱼不应从鲨鱼类派生出律师类继承可以在基类的基础上添加基础但不能删除基类的属性公有继承不建立关系即作为来实现使用数组来实现栈不可以因为栈不是数组所以坚持使用的关系当满足的关系就可以使用公有继承多态公有继承概念同一个方法在派生类和基类中的行为是不同的即称为多态具有多种形态两种实现方法在派生类中重新定义基类的方法使用虚方法开发类和类虚方法的定义会在派生类中重新定义基类的方法但函数名一样的关键字只用于类声明的方法原型中引用类型或指针类型选择方法在继承类中的使用方法没有使用将根据引用类型或指针类型选择方法本应该这样定义的引用变量的类型为所以都为方法使用将根据引用类型或指针类型选择方法本应该这样定义的第二个是可以在派生类方法中调用基类的方法如果该方法是虚方法是使用作用域解析运算符来调用基类方法而不是派生类对象来调用方法如果不是虚方法则不必使用作用域解析运算符使用格式化方法和将浮点值的输出模式设置为定点创建指向的指针数组可以使用一个数组来表示多种类型的对象这也是多态指针既可以指向对象也可以指向对象与一般的数组定义是完全不一样的是的指针数组所以可以进行分配内存类对象的输入与一般的数据输入是不一样的多态是由下述代码提供的指的是指针不是值为何需要虚构函数静态联编和动态联编在编译过程就知道使用哪一个函数是静态联编因为虚函数的存在编译器不知道用户将选择哪种类型的对象只能在程序运行的时候确定正确的虚函数方法叫动态联编总之编译器对虚方法使用动态联编根据对象类型将关联到或指针和引用类型的兼容性不允许将一种类型地址或引用赋给另一种类型的指针或引用但基类和派生类可以而不必进行类型转换虚函数的工作原理给每个对象添加一个隐藏成员隐藏成员是一个指向函数地址数组的指针被称为虚函数表虚析构函数析构函数应当是虚函数即使它不执行任何操作除非类不用做基类析构函数不应进行操作如果没有虚析构函数语句将调用析构函数将释放派生类对象中的基类部分指向的内存但不会释放新的类成员指向的内存如果有虚析构函数则先调用析构函数在调用析构函数虚函数的参数要相同但返回值可以不同重新定义将隐藏方法两个都将被隐藏重新定义继承的方法并不是重载将隐藏所有的同名基类的方法访问控制与相似在类外只能用公有类成员来访问部分中的类成员区别在于继承方面派生类的成员可以直接访问基类的保护成员但不能直接访问基类的私有成员在派生类中与公有成员相识例如可以编写只有在派生类中可以这样使用保护数据成员可以简化代码的编写工作但又使保护数据成员成为公有变量被轻易修改抽象基类前面已经接受了简单继承和多态继承另一种建立继承的方法类和类有共点可以建立拥有他们共同点的类这个类还包含类和类不的同的方法应被声明为虚函数但至少应有一个纯虚函数抽象函数通过使用纯虚函数来提供未实现的函数当类声明中包含纯虚函数时则不能创建该类的对象只能用做基类因此可以从类派生出类和类类和类被称为具体类具有相同的基类可以用指针数组同时管理这两种对象类的纯虚函数也应该定于应用概念是一种必须实施的接口这种模式在基于组件的编程模式中很常见每个或者派生类是组件继承和动态内存分配第一种情况派生类不使用基类使用动态内存分配包含特殊方法析构函数复制构造函数重载赋值运算符而派生类不需要第二种情况派生类使用必须为派生类定义特殊方法派生类的析构函数派生类的复制构造函数是基类的引用可以指向派生类型派生类的重载赋值运算符显示调用基类赋值运算符对指针的返回返回类型也是引用不可用代替不然编译器会从而形成递归调用友元的继承类的友元访问和的方法使用强制类型转换第章中的代码重用可以定义一个通用的栈模板然后创建表示或值栈的类包含对象成员的类对于考试分数可以使用一个定长数组这限制了数组的长度可以使用动态内存分配的指针并提供大量的支持代码也可以使用动态内存分配的类表示该数组还可以在标准库中查找一个表示这种数据的类自己开发这样的类一点问题也没有类简介它支持将数组中所有元素的值相加以及在数组中找出最大和最小的值的操作提供的算术支持比和的多几个使用其构造函数的例子指定长度的空数组初始化列表先有长度再有数值长度放后面这个类的方法返回数组的长度返回字符串的长度类的设计可以从和这两个类派生出类这是多重公有继承一种关系但这里并不合适学生类与这些类不是的关系模板类一般使用自定义的形式也在放在私有部分意味着可以在类的实现中使用它当在类外面不能使用在类中可以直接使用和这两个类的方法初始化被包含的对象时构造函数将使用成员名因为初始化的是成员对象而不是继承的对象在构造函数有一个参数时考虑隐式转换函数没有使用可以写如下将创建一个个元素的对象但着一般是不允许的如果使用了将会发生错误初始化顺序它们被声明的顺序而不是它们在初始化列表中的顺序先初始化成员而不是成员在一个成员的值作为另一个成员的初始化表达式的一部分使初始化的顺序就非常重要是一个对象所以调用函数可以使用类的方法同样该函数也可以实现的输出但没有重载运算符因此类定义了一个私有辅助方法引用返回的更快在包含函数的文件中一般还自定义函数私有继承另一种实现关系的途径私有继承基类的公有成员和保护成员都将成为派生类的私有成员可以在派生类的成员函数中使用它们即只能在派生类的方法中使用基类的方法是使用接口与包含的特性一致也是将另外两个类的对象做为的成员是使用实现访问限定符的默认类型是私有类应从两个类派生而来使用多个基类的继承被称为多重继承包含与私有继承的区别包含提供了两个对象成员而私有继承提供了两个无名的子对象成员初始化基类组件有隐式地继承组件和显式地包含组件私有继承类的构造函数将使用类名来初始化访问基类的方法在没有确定对象时可以使用类名和作用域解析运算符来调用基类的方法但函数的作用域与方法的作用域不一致时就使用解析运算符访问基类对象使用强制类型转换将对象转换为对象表示对象为避免调用构造函数创建新的对象可使用强制类型转换来创建一个引用访问基类的友元函数用类名显式地限定函数名不合适于友元函数可以使用显示地转换为基类来调用正确的函数不修改的强制类型转换调用时并不是输出类的全部成员而只是要进入函数里面去看过程使用修改后的类两个版本的类的公有接口方法完全相同因此可以使用同一个程序测试它们使用包含比私有继承好如果某个类需要个对象可以使用包含声明个独立的成员如果新类需要访问原有类的保护成员或需要重新定义虚函数则应使用私有继承保护继承第三代类体现出保护继承和私有继承的区别使用重新定义访问权限在派生类类外调用基类对象的方法使用一个声明来指出派生类可以使用特定的基类成员即使采用的是私有派生可以这样使用声明只使用成员名没有圆括号函数特征标和返回类型多重继承类模板不如编写一个泛型栈然后将具体的类型作为参数传递给这个类这样就可以使用不同类型的栈例如栈和栈定义模板类为函数名尖括号中的内容相当于函数的参数列表看作是变量的类型名看作变量的名称可以使用模板成员函数替换原有类的类方法每个函数头都将以相同模板声明打头应改为作用域解析符与类名也要改如果在类声明中定义了方法内联定义则可以省略模板前缀和类限定符不能将模板成员函数放在独立的实现文件中由于模板不是函数它们不能单独编译使用类模板使用的算法必须与类型一致一般与是可以用在同一个模板类中的栈与指针栈有相同的功能但不能用在同一个模板类中指针栈指针模板使用一个指针数组其中每个指针都指向不同的字符串用使用动态数组返回类型为类时也要使用这是缩写只能在类中使用数组模板示例和非类型参数模板常用作容器类主要是为容器类提供可重用代码数组模板的成员是数组为类型参数为非类型或表达式参数编译器将使用替换使用替换表达式参数可以是整型枚举引用或指针因此是不合法的但是合法的模板代码不能修改参数的值也不能使用参数的地址如和用作参数的值必须是常量表达式介绍一个允许指定数组大小的简单数组模板第一种使用动态数组和构造函数参数来提供元素数目第二种使用模板参数来提供常规数组的大小就是这样做的表达式参数方法的缺点每种数组大小都将生成自己的模板将生成两个独立的类声明使用动态数组和构造函数参数的方法的优点更通用数组大小是作为类成员存储在定义中的可以将一种大小的数组赋给另一种大小的数组模板的多功能性模板类可用作基类也可用作组件类还可用作其他模板的类型参数递归使用模板对于前面的数组模板定义这使得是一个包含个元素的数组其中每个元素都是一个包含个元素的数组与之等价的常规数组声明即使没有这样的函数也可以这样使用控制输出宽度的方法使用多个类型参数模板类的类名是而不是默认类型模板参数为型为型模板的具体化隐式实例化显式实例化之后将生成一个类显式具体化假设模板使用运算符来对值进行比较对于数字这管用如果是将不管用这将要求类定义使用而不是来对值进行比较这种情况下可以提供一个显式模板具体化即为一种具体类型定义的模板而不是泛型定义的模板部分具体化第二个声明使用通用模板时将转换为类型如果是部分具体化将转换为模板该考虑的类型常规类型成员模板模板可用作结构类或模板类的成员在模板外定义类和方法模板是嵌套的还必须指出和是类的成员而不能使用将模板用作参数是可以将类进行更改模板类和友元模板别名第章友元异常和其他友元友元类的所有方法都可以访问原始类的私有成员和保护成员友元类编写一个模拟电视机和遥控器的简单程序遥控器可以改变电视机的状态而不是的关系因此将类作为类的一个友元必须先定义放在公有位置满足的是一种先有电视再有遥控器的关系友元成员函数让特定是类成员成为另一个类的友元而不必让整个类成为友元让成为类的友元的方法是在类声明中将其声明为友元使用的是类的成员所以必须是友元必须使用前向声明声明中只包含方法声明并将实际的定义放在类之后其他友元关系共同的友元嵌套类").trim().substring(0, 1000);
    let value = Math.floor(Math.random() * 3) + 1000;
    while (value === prevParam || truncateDescription.length - value === prevParam) {
      value = Math.floor(Math.random() * 3) + 1000;
    }
    aiTitleRefreshIcon.style.opacity = "0.2";
    aiTitleRefreshIcon.style.transitionDuration = "0.3s";
    aiTitleRefreshIcon.style.transform = "rotate(" + 360 * refreshNum + "deg)";
    if (truncateDescription.length <= 1000) {
      let param = truncateDescription.length - Math.floor(Math.random() * 3);
      while (param === prevParam) {
        param = truncateDescription.length - Math.floor(Math.random() * 3);
      }
      aiAbstract(param);
      prevParam = param;
    } else {
      aiAbstract(value);
      prevParam = value;
    }
    showAiBtn();
    refreshNum++;
  });

  document.getElementById("go-tianli-blog").addEventListener("click", () => {
    window.open("https://afdian.net/item/886a79d4db6711eda42a52540025c377", "_blank");
  });
  
  if (false) {
    document.getElementById("ai-Toggle").addEventListener("click", () => {
      changeShowMode()
    });
  }

  function showAiBtn() {
    document.querySelectorAll(".ai-btn-item").forEach(item => {
      if (item.id !== "go-tianli-blog") {
        item.style.display = "block";
      }
      if (item.id === "go-tianli-blog") {
        item.style.display = "none";
      }
    });
  }


  aiAbstract();
  showAiBtn()
})()</script></div><article class="post-content" id="article-container"><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>在C++中对数组的定义必须在栈区,即使用new，但为了有更多的功能可以使用string,对于指针的定义可以是常量指针，尤其是作为函数的参数时<br>int a&#x3D;10,int *p&#x3D;&amp;a;<br>void a(const *p,int c);</p>
<p>在C++中一般的地址可以像数组一样使用<br>char *a&#x3D;new char[7];<br>a[1]&#x3D;’a’;</p>
<p>C++中的while循环用处很大可以<br>int a;<br>while(cin&gt;&gt;a)也可以使用地址作为判断条件<br>int s[12];<br>while(m&lt;&#x3D;n&amp;&amp;a[]) 相当于a[]!&#x3D;’\0’表示当s数组有元素时继续循环</p>
<p>在类中 Time operator+(const Time &amp; t) const的第二个const的在参数为类时使用的</p>
<p>关于cout如果有double a;cout&lt;&lt;a;a是整数则会输出没有小数点</p>
<p>cout&lt;&lt;’a’也会是a不会是数字</p>
<p>二维数组作为函数的参数时的写法<br>int a[2][2];<br>void a(int a[][2]);</p>
<p>模板类vector类似于string类,也是一种动态数组,你可以在运行阶段设置vector对象的长度,它是使用new创建动态数组的替代品,它是用new和delete来管理内,必须包含头文件<vector>,其次vector包含在名称空间std中<br>vector<int>vi   vi的长度为0,在你插入或添加值时自动调整长度<br>vector<int>vi(n)或者vi(2),括号中可以是常量也可以是变量 </p>
<p>模板类array与数组一样,array对象的长度是固定的,也使用栈,不是堆<br>array&lt;int,4&gt;a1;<br>array&lt;int,3&gt;a2&#x3D;{2,3,4};<br>a1&#x3D;a2;</p>
<p>struct a{<br>  int b;<br>}<br>a *p&#x3D;new a;<br>不需定义结构变量就能使用结构了</p>
<p>使用string类,必须包含头文件<string>,str.size()是用来计算string对象的长度的,可以将关系运算符用于string对象</p>
<p>const int *p&#x3D;&amp;a<br>p指向一个const int,*p的值为const不能修改 *p++,a++都不可以，但可以这样<br>a&#x3D;12;cout&lt;&lt;*p;<br>在声明函数的指针形参时或数组形参时,一定要声明为指向const的指针<br>int * const p&#x3D;&amp;a</p>
<p>强制类型转换运算符有<br>1.const_cast</p>
<span class='p red'>14.</span>字符函数库cctype
<p>1.isalphaw(ch)<br>2.isspace(ch)</p>
<p>二维数组作为函数时的使用<br>int sum(int a[][2],int size)or int sum(int (*a)[2],int size) 列数是固定的,函数可变</p>
<p>16.返回引用时最重要的一点是,应避免返回函数终止时不再存在的内存单元引用<br>const free_throws &amp; clone2(free_throws &amp; ft){<br>  free_throws newguy;<br>  newguy&#x3D;ft;<br>  return nreguy;<br>}</p>
<p>17.可以返回在函数中new的成员作为返回值,因为是在堆中,而不是栈中<br>char* left(const char* str, int n &#x3D; 1);<br>{<br>    if (n &lt; 0) {<br>        n &#x3D; 0;<br>    }<br>    char* p &#x3D; new char[n + 1];<br>    int i;<br>    for (i &#x3D; 0; i &lt; n &amp;&amp; str[i]; i++) {<br>        p[i] &#x3D; str[i];<br>    }<br>    while (i &lt;&#x3D; n) {<br>        p[i++] &#x3D; ‘\0’;<br>    }<br>    return p;<br>}</p>
<p>18.函数模板的用途,进行数值的交换<br>char* left(const char* str, int n &#x3D; 1);<br>{<br>    if (n &lt; 0) {<br>        n &#x3D; 0;<br>    }<br>    char* p &#x3D; new char[n + 1];<br>    int i;<br>    for (i &#x3D; 0; i &lt; n &amp;&amp; str[i]; i++) {<br>        p[i] &#x3D; str[i];<br>    }<br>    while (i &lt;&#x3D; n) {<br>        p[i++] &#x3D; ‘\0’;<br>    }<br>    return p;<br>}</p>
<p>19.函数重载的作用是在不同的参数如数组和结构与普通的常量时,使得方法不一样,而导致要重新写方法,但要达到的目的是一致的<br>void Swap(AnyType&amp; a, AnyType&amp; b) {<br>    AnyType temp;<br>    temp &#x3D; a;<br>    a &#x3D; b;<br>    b &#x3D; temp;<br>}</p>
<p>template <typename T><br>void Swap(T* a, , T* b,int n) {<br>    T temp;<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        temp &#x3D; a[i];<br>        a[i] &#x3D; b[i];<br>        b[i] &#x3D; temp;<br>    }<br>}<br>这是模板与重载的结合使用,使得Swap的功能更丰富</p>
<p>20.交换了结构体的成员,运用了显式具体化<br>template <typename T><br>void Swap(T &amp; a, , T &amp; b, int n);<br>template &lt;&gt; void Swap<job>(job&amp; j1, job&amp; j2) {<br>    double t1;<br>    int t2;<br>    t1 &#x3D; j1.salary;<br>    j1.salary &#x3D; j2.salary;<br>}</p>
<p>template void Swap<job>(job&amp; j1, job&amp; j2)；则运用了显式实列化,没有自己的方法</p>
<p>21.定位new运算符<br>char buffer1[50];<br>char buffer2[500];<br>chaff* p2 &#x3D; new(buffer1) chaff;<br>chaff* p2&#x3D; new(buffer1+N<em>sizeof(char)) char;    第二次分配的用法<br>int</em> p1 &#x3D; new(buffer2) int[20];<br>delete [] p1;<br>不可使用delete,一般的new才可以</p>
<p>22.都是输出字符串地址的方法<br>char buffer[4] &#x3D; “asd”;<br>    cout &lt;&lt; (void*)buffer &lt;&lt; endl;   强制转换为void*<br>    cout &lt;&lt; &amp;buffer[i] &lt;&lt; endl;</p>
<p>23.静态变量的用法<br>int global&#x3D;1000;   链接性为外部的静态变量<br>extern int global&#x3D;1000;  链接性为外部的静态变量,并且让内部使用<br>static int one&#x3D;12;  链接性为内部的静态变量<br>int main()<br>{<br> …..<br>}<br>void funct(int n)<br>{<br>    static int count&#x3D;9   无链接性的静态变量<br>}</p>
<p>24.创建新的名称空间<br>namespace Jack{<br>    double pail;<br>    void fetch();<br>}</p>
<p>25.所创建的每个新对象都有自己的存储空间,用于存储其内部变量和类成员,<br>但同一个类的所有对象共享同一组类方法,即每种方法只有一个副本,在OOP中，<br>调用成员函数被称为发送消息,因此将同样的消息发送给两个不同的对象将调用<br>同一个方法,但该方法被用于两个不同的对象</p>
<p>26.为对象动态分配存储空间,在这种情况下,对象没有名称,但可以使用指针来管理该对象,叫对象指针<br>stock* p &#x3D; new stock(“qwe”, 2);  构造函数与new的结合</p>
<p>27.在构造函数构造出对象之前,对象是不存在的,因此构造函数被用来创建对象,而不是用对象调用的</p>
<p>28.定义默认构造函数的两种方法<br>c++提供的默认构造函数,它创建对象,但不初始化其成员</p>
<p>stock::stock()<br>{<br>    company&#x3D;”ad”;<br>    shares&#x3D;0;<br>}</p>
<p>stock(const stock &amp;s&#x3D;”asd,int n&#x3D;1)<br>{<br>    ….      这样创建后,可以不用显示初始化    stock first,不需要打()<br>}<br>29.ifndef 技术用来防止多重包含</p>
<p>30.b对象已经存在,因此这条语句不是进行初始化,而是将新值赋给它<br>stock b;<br>b &#x3D; stock(“zxc”, 3);<br>会创建一个新的临时的对象,然后调用析构函数</p>
<p>31.这是错误的,show()无法保证调用的对象不被修改<br>const stock b(“asd”, 3);<br>b.show();<br>而是void show() const;意思是不修改调用的对象<br>只要类方法不修改调用的对象,就应将其声明为const</p>
<p>32.一个方法涉及到两个对象并返回一个对象时就要使用this指针,this设置为a对象的地址</p>
<p>33.由于该函数返回了两个const对象之一,因此返回类型也应为const引用<br>const stock &amp; topval(const  stock &amp; s) const;<br>使用a.topval(b),则s是b的引用,但a没有引用</p>
<p>34.在VS中构造函数只能在类定义中定义,不可在类外定义<br>class stock<br>{<br>private:<br>    string company&#x3D;”asd”;<br>    int shares;<br>public:<br>    stock() { company &#x3D; “zxc”; shares &#x3D; 0; };   不可以使用stock()这种默认构造函数了,但可以这样写stock(){}<br>    stock(const string&amp; oc, int n) { company &#x3D; oc; shares &#x3D; n; }    这个结束号可加可不加<br>    ~stock() { cout &lt;&lt; “Bye” &lt;&lt; endl; }<br>    void show() const;<br>    void gai();<br>    const stock &amp; topval(const  stock &amp; s) const;<br>};</p>
<p>35.指针对象就该这样使用<br>const stock* top &#x3D; &amp;mystuff[1];<br>top &#x3D; &amp;top-&gt;topval(mystuff[2]);<br>top-&gt;show();</p>
<p>36.因为声明类,并没有创建对象,将没有用于存储的空间<br>class stock<br>{<br>private:<br>    string company&#x3D;”asd”;<br>    int shares&#x3D;1;   这是正确的<br>    const int Months &#x3D; 1;   这是错误的,不能使用它<br>    double costs[Months];   数据成员是数组时,必须使用枚举<br>}</p>
<p>37.在类声明中声明的枚举的作用域为整个类<br>enum {Months&#x3D;1};<br>double costs[Months];<br>该常量与其他静态变量存储在一起,而不是存储在对象中<br>static const int a &#x3D; 1;</p>
<ol start="38">
<li>bool stock::isempty() const<br>{<br> return top &#x3D;&#x3D; 0;  top&#x3D;&#x3D;0表示的是返回真假<br>}</li>
</ol>
<p>39.要重载运算符,需使用被称为运算符函数的特殊函数形式<br>operator<a href=""></a>将重载[]是数组索引运算符<br>将两个数组相加可以定义一个表示数组的类,并重载+运算符<br>运算符重载的目的是使运算符能对类产生作用<br>40.一个是对整个成员数据相加,一个是对一个成员数据相加<br>stock stock::Sum(const stock&amp; t)const<br>{<br>    stock sum;<br>    sum.minutes &#x3D; minutes + t.minutes;<br>    sum.hour &#x3D; hour + t.hour + sum.minutes &#x2F; 60;<br>    sum.minutes %&#x3D; 60;<br>    return sum;<br>}</p>
<p>void stock::AddHor(int h)<br>{<br>    hour +&#x3D; h;<br>}</p>
<p>41.operator+   相当函数名<br>stock stock::operator+(const stock&amp; t)const</p>
<p>42.友元函数不是成员函数,不能由对象调用,一般是对重载运算符函数进行友元操作,不能使用成员运算符来调用  a &#x3D; operator*(2.75, b);<br>在定义时不用::,只是与成员函数有相同的访问权限</p>
<ol start="43">
<li>cout &lt;&lt; trip   是友元函数重载<br>trip &lt;&lt; cout   是成员函数重载</li>
</ol>
<p>ostream &amp; operator&lt;&lt;(ostream&amp; os, const stock&amp; t)<br>{<br>    os &lt;&lt; t.hour &lt;&lt; “ “ &lt;&lt; t.minutes &lt;&lt; endl;<br>}</p>
<p>void operator&lt;&lt;(ostream&amp; os, const stock&amp; t)<br>{<br>    os &lt;&lt; t.hour &lt;&lt; “ “ &lt;&lt; t.minutes &lt;&lt; endl;<br>}<br>可以这样使用 cout&lt;&lt; trip&lt;&lt; “dfs”</p>
<p>44.int *p&#x3D;10   p表示的是int *类型的,int *表示指针也即地址</p>
<p>45.这个构造函数用于将double类型的值转换为stock类类型,将构造函数用作隐式转换函数<br>stock::stock(double lbs)<br>{<br>    hour &#x3D; int(lbs);<br>    minutes &#x3D; int(lbs);<br>}</p>
<p>stock a;<br>a &#x3D; 19.9;   把一个值赋给对象</p>
<p>explicit stock(double lbs)  只能使用显示强制类型转换<br>stock a;<br>a&#x3D;stock(19.9);</p>
<p>void display(const stock &amp; st,int n);<br>disfplay(422,4);   可以这样写</p>
<p>46.转换函数<br>operator int() const<br>{<br>    return int (pounds+0.5);<br>}<br>stock v;<br>int a&#x3D;(int)v;   没有声明返回类型,但将返回所需的值,也不使用调用的形式<br>int a&#x3D;v;   这是隐式转换</p>
<p>explicit operator int() const;    显示转换函数</p>
<p>int stock::a(){return int(pound+0.5);}  功能相同的非转换函数<br>int plb&#x3D;对象.a();</p>
<p>stock t(6,7);<br>int r&#x3D;9;<br>stock e;<br>e&#x3D;t+r;   将r转换为类对象进行相加</p>
<p>47.类的动态内存分配不仅可以及时删除内存,还可以改变数组的长度,在创建多个对象数组时而不浪费内存<br>在类成员中使用char指针</p>
<p>48.字符串并不保存在对象中,而是被单独保存在堆内存中，对象保存了指到哪里去查找字符串的信息,只是保存了指针<br>String::String(const char* s)<br>{<br>    len &#x3D; strlen(s);<br>    str &#x3D; new char[len + 1];<br>    str&#x3D;nullptr;<br>    str&#x3D;0;<br>    str[1]&#x3D;’\0’;<br>    strcpy(str, s);    将字符串复制到内存中即创建字符串的副本<br>    str&#x3D;s;  这是错误的,这只保存了地址,而没有创建字符串的副本<br>    cout &lt;&lt; num_strings &lt;&lt; str &lt;&lt; endl;<br>}</p>
<p>49.这个使用的是复制构造函数,而不是一般的构造函数<br>String sailor&#x3D;sports;   一个对象初始化另一个对象,但调用了赋值运算符<br>String sailor&#x3D;String(sports);   复制构造函数的原型为<br>String(const &amp; string);  它创建对象的一个副本(指针)</p>
<p>String *a&#x3D;new String (motto)<br>String b&#x3D;String(c)<br>String c(s)      都会调用复制构造函数,都是生成一个临时对象</p>
<p>sailor&#x3D;sports   一个对象赋给另一个对象,这个对象也是sailor对象的一个副本(指针)</p>
<p>如果类中包含这样的静态数据成员,即其值将在新对象被创建时发生改变,则应该提供一个显示复制构造函数来处理计数问题</p>
<p>sailor.str&#x3D;sports.str   这里复制的并不是字符串,而是一个指向字符串的指针</p>
<p>显示复制构造函数<br>String::String(const char* s)<br>{<br>    len &#x3D; s.len;<br>    str &#x3D; new char[len + 1];<br>    strcpy(str, s.str);<br>    str&#x3D;s;<br>    cout &lt;&lt; num_strings &lt;&lt; str &lt;&lt; endl;<br>}</p>
<p>赋值运算符也是用了成员的复制</p>
<p>String &amp; String:: operator&#x3D;(const String &amp; s)<br>{<br>    if(thi&#x3D;&#x3D;&amp;s) return *this;<br>    delete [] str;<br>    len&#x3D;s.len;<br>    str&#x3D;new char[len+1];<br>    strcpy(str, s.str);<br>    return *this;<br>}</p>
<p>50.[]的重载<br>char &amp; String::operator[](int i)<br>{<br>    return str[i];<br>}</p>
<p>静态成员函数使用<br>static int HowMany() {return num_String}<br>int String::HowMany()<br>int count&#x3D;String::HowMany();</p>
<p>把字符串赋值给类<br>String &amp; String:: operator&#x3D;(const char*s)    对指针一般不使用引用<br>{<br>    if(thi&#x3D;&#x3D;&amp;s) return *this;<br>    delete [] str;<br>    len&#x3D;s.len;<br>    str&#x3D;new char[len+1];<br>    strcpy(str, s.str);<br>    return *this;<br>}</p>
<p>输入运算符的重载<br>istream &amp; operator&gt;&gt;(istream &amp; is, String &amp; s)<br>{<br>    char temp[2];<br>    is.get(temp,2);<br>    if(is){<br>        s&#x3D;temp;   必须要有把字符串赋值给类的赋值函数<br>    }<br>    while(is&amp;&amp;is.get()!&#x3D;’\n’)   continue;<br>    return is;<br>}</p>
<p>51.类库是可以修改的,函数库是不能修改的</p>
<p>52.TableTennisPlayer类表示俱乐部的乒乓球成员,RatedPlayer类表示一些成员参加过乒乓球锦标赛,公有继承对象包括基类对象<br>创建派生类对象时,程序首先创建基类对象派生类构造函数必须使用基类构造函数,派生类更具体一些</p>
<p>53.构造函数列表初始化<br>String(const string&amp; fn &#x3D; “none”, const string&amp; In &#x3D; “none”, bool ht &#x3D; false);<br>String::String(const string&amp; fn, const string&amp; In, bool ht) :firstname(fn), lastname(In), hasTable(ht) { }</p>
<p>54.派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数<br>derived::derived(typee1 x,type2 y):base(x,y)   它有两个参数,括号就包含两个参数</p>
<p>Stringn(const string&amp; fn &#x3D; “none”, const string&amp; In &#x3D; “none”, bool ht &#x3D; false,int g&#x3D;0);<br>Stringn::Stringn(const string&amp; fn, const string&amp; In, bool ht, int g) :String(fn, In, ht)<br>{<br>    rating &#x3D; g;<br>}<br>Stringn::Stringn(const string&amp; fn, const string&amp; In, bool ht, int g)<br>{<br>    rating &#x3D; g;    这是调用了基类的默认构造函数<br>}</p>
<p>Stringn(int r, const String&amp; tp);<br>Stringn::Stringn(int r, const String&amp; tp) :String(tp),rating(r)<br>{<br>                参数虽然与基类默认构造函数不一样,但可以使用,将调用基类的复制构造函数<br>}  </p>
<p>54.基类指针可以指向派生类对象或引用派生类对象<br>Stringn b(“sd”, “qw”, true, 2);<br>String&amp; c &#x3D; b;<br>String* d &#x3D; &amp;b;<br>基类引用或指针参数可以指向 基类对象或派生类对象<br>void show(const String&amp; s)<br>{<br>    s.Name();<br>}<br>show(d);<br>show(c);<br>void show(const String*s)   也是一样的</p>
<p>55.可以将基类对象初始化派生类对象,也可以将派生类对象赋值给基类对象<br>必须像54一样先定义基类引用<br>Stringn a(“sd”,”sdf”,false);<br>String b(a);      将调用隐式赋值构造函数<br>b&#x3D;a;</p>
<p>56.is-a即派生类对象是一个基类对象,可以对基类执行的任何操作,也可以对派生类对象执行<br>香蕉是水果   is-a   不可有律师就像是鲨鱼,早餐是水果<br>早餐有水果   have-a   栈不是数组,栈不包括数组索引<br>uses-a   is-like-a  is-implemented-as-a</p>
<p>57.多态公有继承<br>虚方法使得派生类和基类对象使用的方法有所不同<br>class brass<br>{<br>private: </p>
<p>public:<br>    virtual void withdraw(double amt);<br>    virtual ~brass(){};  为基类声明一个虚析构函数也是一种惯例<br>};</p>
<p>class brassplus :public brass<br>{<br>    private:<br>        int rating;<br>    public:<br>        virtual void withdraw(double amt);<br>};</p>
<div class="tabs" id="test1"><ul class="nav-tabs"></ul><div class="tab-contents"></div></div>

<ol>
<li><p>在C++中对数组的定义必须在栈区，即使用new。但为了有更多的功能，可以使用string。对于指针的定义可以是常量指针，尤其是作为函数的参数时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">(<span class="type">const</span> *p, <span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在C++中，一般的地址可以像数组一样使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *a = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">7</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++中的while循环用处很大，可以使用地址作为判断条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; a)</span><br></pre></td></tr></table></figure>
<p>也可以使用数组作为判断条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">while</span> (m &lt;= n &amp;&amp; a[])  <span class="comment">// 相当于a[] != &#x27;\0&#x27;，表示当s数组有元素时继续循环</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在类中，Time operator+(const Time &amp; t) const的第二个const在参数为类时使用。</p>
</li>
<li><p>关于cout，如果有double a; cout &lt;&lt; a;，a是整数则会输出没有小数点。cout &lt;&lt; ‘a’也会输出a，不会是数字。</p>
</li>
<li><p>二维数组作为函数的参数时的写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板类vector类似于string类，也是一种动态数组。你可以在运行阶段设置vector对象的长度，它是使用new创建动态数组的替代品，它是用new和delete来管理内存。必须包含头文件<vector>，其次vector包含在命名空间std中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi;  <span class="comment">// vi的长度为0，在你插入或添加值时自动调整长度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vi</span><span class="params">(n)</span></span>;  <span class="comment">// 或者 vi(2)，括号中可以是常量也可以是变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模板类array与数组一样，array对象的长度是固定的，也使用栈，不是堆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a1;</span><br><span class="line">array&lt;<span class="type">int</span>, 3&gt; a2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">a1 = a2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不需定义结构变量就能使用结构了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">A *p = <span class="keyword">new</span> A;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="11-6类的自动转换和强制类型转换"><a href="#11-6类的自动转换和强制类型转换" class="headerlink" title="11.6类的自动转换和强制类型转换"></a>11.6类的自动转换和强制类型转换</h2><ol>
<li><p>数据类型的转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> tine = <span class="number">11</span>;  </span><br><span class="line"><span class="type">int</span> side = <span class="number">3.33</span>;  都是正确的，将进行自动类型转换</span><br><span class="line"><span class="type">int</span> *p = <span class="number">10</span>;    不会进行自动转换，是不兼容的类型，可进行强制类型转换</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的构造函数用于将double类型的值转换为Stonewt类类型，介绍的是转换构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="type">double</span> lbs)   只能是接受一个参数的构造函数才能这样   Stonewt::<span class="built_in">Stonewt</span>(<span class="type">int</span> stn,<span class="type">double</span> lbs=<span class="number">0</span>)可以</span><br><span class="line">&#123;</span><br><span class="line">	stone = <span class="built_in">int</span>(lbs)/<span class="number">14</span>;</span><br><span class="line">	pounds = lbs; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt myCat;</span><br><span class="line">myCat = <span class="number">19.6</span>;</span><br><span class="line">先创建一个临时的Stonewt的对象，并将<span class="number">19.2</span>作为初始值，然后将临时对象的内容复制到myCat中,为类的隐式转换，是自动进行的</span><br></pre></td></tr></table></figure>
</li>
<li><p>explicit是关闭隐式转换，但仍然允许显式强制类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Stonewt</span><span class="params">(<span class="type">double</span> lbs)</span></span>;</span><br><span class="line">Stonewt myCat;</span><br><span class="line">myCat = <span class="number">19.6</span>;  NO</span><br><span class="line"></span><br><span class="line">myCat = <span class="built_in">Stonewt</span>(<span class="number">19.6</span>);   Yes</span><br><span class="line">myCat = (Stonewt)<span class="number">19.6</span>;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换还存在二义性，还可以用于将double值传递给接受Stonewt参数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> Stonewt &amp; st,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Wow&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">display</span>(<span class="number">422</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果提供了Stonewt(double)构造函数,并且是成员函数的加法函数则可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt <span class="title">jennySt</span><span class="params">(<span class="number">9</span>,<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> kennyD = <span class="number">176.0</span>;</span><br><span class="line">Stonewt total;</span><br><span class="line">total = jennySt+kennyD;</span><br></pre></td></tr></table></figure>
<p>但只有友元函数才允许这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt <span class="title">jennySt</span><span class="params">(<span class="number">9</span>,<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> kennyD = <span class="number">176.0</span>;</span><br><span class="line">Stonewt total;</span><br><span class="line">total = kennyD+jennySt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="11-6-1转换函数"><a href="#11-6-1转换函数" class="headerlink" title="11.6.1转换函数"></a>11.6.1转换函数</h3><ol>
<li>转换函数的概念：是将类类型转换为某种类型，是用户定义的强制类型转换</li>
</ol>
<p>2.转换函数必须是类方法，不能指定返回类型，不能有参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;    转换为<span class="type">double</span>类型的函数</span><br><span class="line"><span class="function">Stonewt::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pounds;   返回一个<span class="type">double</span>数</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Stonewt <span class="title">wolfe</span><span class="params">(<span class="number">285.7</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> honst = <span class="built_in">double</span>(wolfe);</span><br><span class="line"><span class="type">double</span> honst = (<span class="type">double</span>)wolfe;</span><br><span class="line"><span class="type">double</span> honst = wolfe;</span><br></pre></td></tr></table></figure>
<p>注意虽然没有声明返回类型，但也将返回所需的值，是四舍五入的方式而不是去掉小数部分</p>
<ol start="3">
<li><p>类类型转换为某种类型也会存在二义性</p>
</li>
<li><p>explicit 不能用于转换函数，但可以使用非转换函数替换，只能进行强制转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stonewt::Stone_to_Int</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">int</span> (pounds+<span class="number">0.5</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> plb = poppins;    是非法的</span><br><span class="line"><span class="type">int</span> plb = poppins.<span class="built_in">Stone_to_Int</span>();   可以</span><br></pre></td></tr></table></figure>
</li>
<li><p>警告：应谨慎地使用隐式转换函数。通常使用显式的强制类型转换</p>
</li>
</ol>
<h3 id="11-6-2转换函数和友元函数"><a href="#11-6-2转换函数和友元函数" class="headerlink" title="11.6.2转换函数和友元函数"></a>11.6.2转换函数和友元函数</h3><ol>
<li>实现加法时的选择，要将double量和Stonewt量相加可以有两种方法</li>
</ol>
<h1 id="第十二章-类和动态内存分配"><a href="#第十二章-类和动态内存分配" class="headerlink" title="第十二章 类和动态内存分配"></a>第十二章 类和动态内存分配</h1><h2 id="12-1动态内存和类"><a href="#12-1动态内存和类" class="headerlink" title="12.1动态内存和类"></a>12.1动态内存和类</h2><h3 id="12-1-1开发一个动态内存类"><a href="#12-1-1开发一个动态内存类" class="headerlink" title="12.1.1开发一个动态内存类"></a>12.1.1开发一个动态内存类</h3><ol>
<li><p>使用动态内存分配来开发类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str;   </span><br></pre></td></tr></table></figure>
<p>使用char指针，而不是char数组，这意味着类声明没有为字符串分配存储空间</p>
</li>
<li><p>静态类成员特点：<br>1.无论创建了多少对象，所有对象共享同一个静态成员，例如，num_strings成员可以记录所创建的对象数目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> num_strings;</span><br><span class="line"><span class="type">int</span> StringBad::num_strings = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>不能在类声明中初始化静态成员变量，只能在.c文件中初始化，类外也不可以初始化，但如果静态成员是const整数类型或枚举类型(见第十章)，则可以在类声明中初始化</p>
</li>
</ol>
<p>2.创建构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">	len = <span class="built_in">strlen</span>(s);   不会包括末尾的空字符<span class="string">&#x27;\0&#x27;</span></span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[len+<span class="number">1</span>];  </span><br><span class="line">	<span class="built_in">strcpy</span>(str,s);</span><br><span class="line">	num_strings++;  记录对象的数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串并不保存在对象中，而是保存在堆内存中，对象仅保存了指出到哪里去查找字符串的信息。不能这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = s;</span><br></pre></td></tr></table></figure>
<p>这只保存了地址，而没有创建字符串副本</p>
<ol start="3">
<li><p>析构函数的使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		StringBad knot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象声明放在一个内部代码块中，因为析构函数将在定义对象的代码块执行完毕时调用，对象的删除的顺序与创建顺序相反</p>
</li>
<li><p>在进行输出类时，是运用了重载运算符&lt;&lt;，注意查看重载运算符&lt;&lt;函数中输出的是什么内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBad knot;</span><br><span class="line">cout &lt;&lt; knot &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器会自动生成成员函数和自动使用你不使用函数：构造函数，析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp;);   为复制构造函数，会创建对象的一个副本</span><br><span class="line">StringBad sailor=sports《《 StringBad sailor=<span class="built_in">StringBad</span>(sports);  调用了一个函数</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-1-2-特殊成员函数"><a href="#12-1-2-特殊成员函数" class="headerlink" title="12.1.2 特殊成员函数"></a>12.1.2 特殊成员函数</h3><ol>
<li><p>特殊成员函数是自动定义的，有：<br>默认构造函数，如果没有定义<br>默认析构函数，如果没有定义<br>复制构造函数，如果没有定义<br>赋值运算符，如果没有定义<br>地址运算符，如果没有定义，返回调用对象的地址(即this指针的值)<br>c++11新增：<br>移动构造函数<br>移动运算符</p>
</li>
<li><p>默认构造函数<br>如果定义了构造函数，c++将不会定义默认构造函数。如果希望在创建对象时不显示地对它进行初始话，则必须显示地定义默认构造函数，它还可以来设定特定的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Klunk::<span class="built_in">Klunk</span>()</span><br><span class="line">&#123;</span><br><span class="line">	klunk_ct = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Klunk lunk;     在创建对象时不显示地对它进行初始话</span><br></pre></td></tr></table></figure>
<p>带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值，但只有一个默认构造函数，不然会造成二义性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Klunk</span>(<span class="type">int</span> n=<span class="number">0</span>)&#123;klunk_ct = n&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制构造函数<br>3.1它用于初始化过程，而不是常规的赋值过程，每当程序生成了对象副本时，编译器都将使用复制构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StirngBad * pStringBad = <span class="keyword">new</span> <span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp;);</span><br></pre></td></tr></table></figure>
<p>使用motto初始化一个匿名对象，并将新对象的地址赋给pstring指针</p>
</li>
</ol>
<p>3.2当按值传递和返回对象时以及编译器生成临时对象，例如将3个Vectir对象相加时，编译器可能生成临时的Vector对象来保存中间结果，都将调用复制构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callme1</span><span class="params">(StringBad n)</span></span>;    复制构造函数初始化<span class="built_in">callme2</span>()函数的StringBad形参</span><br><span class="line"><span class="built_in">callme2</span>(headline2);</span><br></pre></td></tr></table></figure>

<p>3.3由于按值传递对象将调用复制构造函数，在用类为函数的参数时应该按引用传递对象</p>
<p>3.4如果成员本身就是类对象，则将使用这个类的复制函数来复制成员对象。静态成员不受影响，因为它们属于整个类</p>
<ol start="4">
<li>显示复制构造函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	num_string++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果类中包含这样的静态数据成员，即其值将在对象被创建时发生变化，则应该提供一个显示复制构造函数来处理计数问题</li>
</ol>
<h3 id="12-1-3-回到Stringbad-复制构造函数的哪里出了问题"><a href="#12-1-3-回到Stringbad-复制构造函数的哪里出了问题" class="headerlink" title="12.1.3 回到Stringbad: 复制构造函数的哪里出了问题"></a>12.1.3 回到Stringbad: 复制构造函数的哪里出了问题</h3><ol>
<li><p>这里复制的并不是字符串，而是一个指向字符串的指针，得到两个指向同一个字符串的指针，相当于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sailor.str = sport.str;(由于私有成员是无法访问的，因此这些代码是不能通过编译的)</span><br></pre></td></tr></table></figure>
</li>
<li><p>sports.str指向的内容已经被sailor的析构函数释放</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] sailor.str;</span><br><span class="line"><span class="keyword">delete</span> [] sports.str;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个显式复制构造函数以解决问题(深度复制)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> StringBad &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">	num_string++;</span><br><span class="line">	len = st.len;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span> [len+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str,st.str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该复制构造函数应当复制字符串并将副本的地址赋给str成员,如果类中包含了使用new初始化的指针成员，应当定义一个深度复制函数</p>
</li>
</ol>
<h3 id="12-1-4-StringBad的其他问题：赋值运算符"><a href="#12-1-4-StringBad的其他问题：赋值运算符" class="headerlink" title="12.1.4 StringBad的其他问题：赋值运算符"></a>12.1.4 StringBad的其他问题：赋值运算符</h3><ol>
<li><p>赋值运算符的功能以及何时使用它<br>将已有的对象赋给另一个对象时，将使用重载的赋值运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBad &amp; StringBad::<span class="keyword">operator</span>=(<span class="type">const</span> StringBad &amp;);</span><br><span class="line">so = s1;</span><br><span class="line">使用函数表示法时：</span><br><span class="line">so.<span class="built_in">operator</span>(s1);</span><br></pre></td></tr></table></figure>
<p>与复制构造函数相似，赋值运算符也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响</p>
</li>
<li><p>赋值的问题与复制的问题的一样的</p>
</li>
<li><p>解决赋值的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringBad &amp; StringBad::<span class="keyword">operator</span>=(<span class="type">const</span> StringBad &amp;st)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>==&amp;st)     </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">delete</span> [] str;</span><br><span class="line">	len = st.len;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span> [len+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str,st.str);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.1函数返回一个指向调用对象的引用(即this指针)</p>
</li>
</ol>
<p>3.2代码首先检查自我复制，这是通过查看赋值运算符右边的地址(&amp; s)是否与接收对象的地址(this)相同来完成的</p>
<p>3.3赋值操作并不创建新的对象，因此不需要调整静态数据成员num_strings的值</p>
<h2 id="改进后的新Stirng类"><a href="#改进后的新Stirng类" class="headerlink" title="改进后的新Stirng类"></a>改进后的新Stirng类</h2><ol>
<li><p>标准字符串函数库cstring的功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span>  </span>&#123;<span class="keyword">return</span> len&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="built_in">operator</span>&lt;(<span class="type">const</span> String &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> String &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> String &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;&gt;(istream &amp; st,<span class="type">const</span> String &amp; st2);</span><br><span class="line"><span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="type">const</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)<span class="type">const</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">HowMany</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>c++11空指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>nullptr用于表示空指针</p>
</li>
<li><p>重载&gt;&gt;运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is,String &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> temp[<span class="number">80</span>];</span><br><span class="line">	is.<span class="built_in">get</span>(temp,<span class="number">80</span>)</span><br><span class="line">	<span class="keyword">if</span>(is)</span><br><span class="line">		str = temp;</span><br><span class="line">	<span class="keyword">while</span>(is&amp;&amp;is.<span class="built_in">get</span>()!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为对象数组输入内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String saying[n];</span><br><span class="line"><span class="type">char</span> temp[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	cin.<span class="built_in">get</span>(temp,<span class="number">80</span>);</span><br><span class="line">	<span class="keyword">while</span>(cin&amp;&amp;cin.<span class="built_in">get</span>()!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cin)</span><br><span class="line">		saying[i] = temp;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为对象数组输出到屏幕上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;saying[i][<span class="number">0</span>]&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;saying[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到对象数组中最短的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> shortest = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(saying[i].<span class="built_in">length</span>()&lt;saying[shortest].length)</span><br><span class="line">		shortest = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-2-2比较成员函数"><a href="#12-2-2比较成员函数" class="headerlink" title="12.2.2比较成员函数"></a>12.2.2比较成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> String &amp; st1,<span class="type">const</span> String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(st1.str,st2.str)&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> String &amp; st1,<span class="type">const</span> String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(st1.str,st2.str)&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> String &amp; st1,<span class="type">const</span> String &amp;st2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(st1.str,st2.str)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>将比较函数作为友元，有助于String对象与常规的c字符串进行比较<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;love&quot;</span>==answer)</span><br><span class="line">将被转换为：</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="string">&quot;love&quot;</span>,answer))</span><br><span class="line">然后，编译器将使用某个构造函数将代码转换为：</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="built_in">String</span>(<span class="string">&quot;love&quot;</span>),answer))</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-2-3使用中括号表示法访问字符"><a href="#12-2-3使用中括号表示法访问字符" class="headerlink" title="12.2.3使用中括号表示法访问字符"></a>12.2.3使用中括号表示法访问字符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">opera</span><span class="params">(<span class="string">&quot;The Magic Flute&quot;</span>)</span></span>;</span><br><span class="line">opera[<span class="number">4</span>];</span><br><span class="line"><span class="type">char</span> &amp; String::opera[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般是在String类这种数组中，opera[4]不是指它包含有四个对象，而是第四个字符</p>
<ol>
<li><p>将r赋给指向means.str[0]的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">means</span><span class="params">(<span class="string">&quot;might&quot;</span>)</span></span>;</span><br><span class="line">means[<span class="number">0</span>]=<span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">means.<span class="keyword">operator</span>[](<span class="number">0</span>)=<span class="string">&#x27;r</span></span><br><span class="line"><span class="string">means.str[0]=&#x27;</span>r<span class="number">&#x27;</span>   访问的是私有数据，但由于<span class="keyword">operator</span>[]()是类的一个方法，因此能够修改数组的内容</span><br></pre></td></tr></table></figure>
<p>后三者是等同的</p>
</li>
<li><p>answer是常量，只能使用常量函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> String <span class="title">answer</span><span class="params">(<span class="string">&quot;futile&quot;</span>)</span></span>;     </span><br><span class="line">如果只有<span class="keyword">operator</span>[]()定义，则下面的代码将出错：</span><br><span class="line">cout&lt;&lt;answer[<span class="number">1</span>];</span><br><span class="line">因此提供常量版本：</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp; String::opera[](<span class="type">int</span> i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-2-4-静态类成员函数"><a href="#12-2-4-静态类成员函数" class="headerlink" title="12.2.4 静态类成员函数"></a>12.2.4 静态类成员函数</h3><ol>
<li><p>不能通过对象调用静态成员函数，甚至不能使用this指针，它不属于对象，属于类，调用它的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = String::<span class="built_in">HowMany</span>();</span><br></pre></td></tr></table></figure>
<p>可以使用类名和作用域解析运算符调用它，可以访问静态成员num_string，但不能访问str</p>
</li>
<li><p>两种的差别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> num_strings;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> CLNLIM = <span class="number">80</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-2-5-进一步重载赋值运算符"><a href="#12-2-5-进一步重载赋值运算符" class="headerlink" title="12.2.5 进一步重载赋值运算符"></a>12.2.5 进一步重载赋值运算符</h3><ol>
<li>将常规字符串复制到String对象中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[] str;</span><br><span class="line">	len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span> [len+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str,s);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一般来说，必须释放str指向的内存</li>
</ol>
<h2 id="12-3-在构造函数中使用new时应注意的事项"><a href="#12-3-在构造函数中使用new时应注意的事项" class="headerlink" title="12.3 在构造函数中使用new时应注意的事项"></a>12.3 在构造函数中使用new时应注意的事项</h2><ol>
<li>如果有多个构造函数，则必须以相同的方式使用new，要么带中括号，要么不带中括号。因为只有一个析构函数，然而将指针初始化为空，两种都兼容</li>
</ol>
<h3 id="12-3-1-包含类成员的类的逐成员复制"><a href="#12-3-1-包含类成员的类的逐成员复制" class="headerlink" title="12.3.1 包含类成员的类的逐成员复制"></a>12.3.1 包含类成员的类的逐成员复制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magazine</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		String title;</span><br><span class="line">		string publisher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String和string都使用动态内存分配，但不需要为Magazine类编写复制构造函数和赋值运算符，会将使用成员类定义的复制构造函数和赋值运算符</p>
<h2 id="12-4-有关返回对象的说明"><a href="#12-4-有关返回对象的说明" class="headerlink" title="12.4 有关返回对象的说明"></a>12.4 有关返回对象的说明</h2><h3 id="12-4-1-返回指向const对象的引用"><a href="#12-4-1-返回指向const对象的引用" class="headerlink" title="12.4.1 返回指向const对象的引用"></a>12.4.1 返回指向const对象的引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Vector &amp; <span class="title">Max</span><span class="params">(<span class="type">const</span> Vector &amp; v1;<span class="type">const</span> Vector &amp; v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v1.<span class="built_in">magval</span>()&gt;v2.<span class="built_in">magval</span>())</span><br><span class="line">		<span class="keyword">return</span> v1;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个const与返回有关，返回的是v1或v2，v1和v2都被声明为const引用，所有才使用const</p>
<h3 id="12-4-2-返回指向非const对象引用"><a href="#12-4-2-返回指向非const对象引用" class="headerlink" title="12.4.2 返回指向非const对象引用"></a>12.4.2 返回指向非const对象引用</h3><p>operator&lt;&lt;()的返回类型必须是ostream &amp;，而不能仅仅是ostream。如果使用返回类型ostream，将调用ostream类的复制构造函数，而ostream类没有公有的复制构造函数</p>
<h3 id="12-4-3-返回对象"><a href="#12-4-3-返回对象" class="headerlink" title="12.4.3 返回对象"></a>12.4.3 返回对象</h3><p>如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，只能是返回对象</p>
<h2 id="12-5-使用指向对象的指针"><a href="#12-5-使用指向对象的指针" class="headerlink" title="12.5 使用指向对象的指针"></a>12.5 使用指向对象的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String * shortest = &amp;sayings[<span class="number">0</span>];</span><br><span class="line">shortest-&gt;<span class="built_in">length</span>()</span><br></pre></td></tr></table></figure>
<p>使用结构体的方式来使用成员</p>
<ol>
<li>使用new初始化对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String *favorite = <span class="keyword">new</span> <span class="built_in">String</span>(saying[choice]);</span><br><span class="line">将调用复制构造函数：</span><br><span class="line"><span class="built_in">String</span>()</span><br></pre></td></tr></table></figure>
这里指针favorite指向new创建的未被命名对象，但复制构造函数会给它创建内容</li>
</ol>
<h3 id="12-5-1-再谈定位new运算符"><a href="#12-5-1-再谈定位new运算符" class="headerlink" title="12.5.1 再谈定位new运算符"></a>12.5.1 再谈定位new运算符</h3><p>内存缓冲区实则指的是数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JustTesting</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string words;</span><br><span class="line">	<span class="type">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *buffer = <span class="keyword">new</span> <span class="type">char</span> [BUF];</span><br><span class="line">JustTesting *pc1,*pc2;，*pc3</span><br><span class="line">pcl = <span class="built_in">new</span> (buffer) JustTesting</span><br><span class="line">pc2 = <span class="keyword">new</span> <span class="built_in">JustTesting</span>(<span class="string">&quot;Heap&quot;</span>,<span class="number">10</span>);</span><br><span class="line">pc3 = <span class="built_in">new</span> (buffer+<span class="built_in">sizeof</span>(JustTesting)) <span class="built_in">JustTesting</span>()</span><br><span class="line"><span class="keyword">delete</span> [] buffer;   要这样做的原因在于：<span class="keyword">delete</span>不能与定位<span class="keyword">new</span>运算符配合使用</span><br><span class="line"><span class="keyword">delete</span> pc2;</span><br></pre></td></tr></table></figure>
<p>将delete用于pc2，将自动调用为pc2指向的的对象调用析构函数，用于buffer时，不会为使用定位new运算符创建的对象调用析构函数，而是需要显示的调用析构函数<br>，一般情况下将自动调用析构函数，这是需要显示调用析构函数的少数几种情况之一</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1-&gt;~<span class="built_in">JustTesting</span>();</span><br></pre></td></tr></table></figure>

<ol>
<li><p>cout对地址输出的不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;(<span class="type">void</span> *)buffer&lt;&lt;pc1&lt;&lt;pc2&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>buffer输出地址的方式不同</p>
</li>
<li><p>定位new运算符创建的对象的删除顺序与创建的顺序相反。原因在于晚创建的对象可能依赖于早创建的对象，另外当所有对象都被消除后，才能释放缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p3-&gt;~<span class="built_in">JustTesting</span>();</span><br><span class="line">p1-&gt;~<span class="built_in">JustTesting</span>();</span><br><span class="line"><span class="keyword">delete</span> [] buffer; </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第13章-类继承"><a href="#第13章-类继承" class="headerlink" title="第13章 类继承"></a>第13章 类继承</h1><p>面向对象编程的主要目的之一是提供可重用的代码</p>
<ol>
<li>通过继承完成的一些工作：<br>可以在已有的基础上添加功能。例如，对于数组类，可以添加数学运算。<br>可以给类添加数据。例如，对于字符串类，可以添加显示颜色的数据成员。<br>可以修改类方法的行为。例如，提供给飞机乘客的服务的类，可以提供更高级别服务的类。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Table::<span class="built_in">Table</span>(<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht):<span class="built_in">firstname</span>(fn),<span class="built_in">lastname</span>(ln),<span class="built_in">hasTable</span>(ht)&#123;&#125;</span><br><span class="line">Table::<span class="built_in">Table</span>(<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht)</span><br><span class="line">&#123;</span><br><span class="line">	firstname = fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
初始化列表语法可以减少一个步骤，它直接使用string的复制构造函数将firstname初始化为fny</li>
</ol>
<h2 id="13-1-一个简单的基类"><a href="#13-1-一个简单的基类" class="headerlink" title="13.1 一个简单的基类"></a>13.1 一个简单的基类</h2><h3 id="13-1-1"><a href="#13-1-1" class="headerlink" title="13.1.1"></a>13.1.1</h3><p>构造函数必须给新成员和继承的成员提供数据。第二个构造函数使用一个类为参数，包含firstname，lastname，hasTable</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RatePlayer</span>(<span class="type">int</span> r=<span class="number">0</span>,<span class="type">const</span> string &amp; fn=<span class="string">&quot;none&quot;</span>);</span><br><span class="line"><span class="built_in">RatePlayer</span>(<span class="type">int</span> r=<span class="number">0</span>,<span class="type">const</span> TableTennishPlayer &amp; tp);</span><br></pre></td></tr></table></figure>
<p>继承类的构造函数的写法</p>
<h3 id="13-1-2-构造函数：访问权限的考虑"><a href="#13-1-2-构造函数：访问权限的考虑" class="headerlink" title="13.1.2 构造函数：访问权限的考虑"></a>13.1.2 构造函数：访问权限的考虑</h3><ol>
<li><p>派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。列如，RatePlayer构造函数不能直接设置继承的成员，派生类构造函数必须使用基类构造函数</p>
</li>
<li><p>创建派生类对象时，程序首先创建基类对象。使用成员初始化列表来完成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r,<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht):<span class="built_in">TableTennisPalyer</span>(fn,ln,ht)</span><br><span class="line">&#123;</span><br><span class="line">	rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了TableTennisPalyer的构造函数</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r,<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht)</span><br><span class="line">&#123;</span><br><span class="line">	rating = r;</span><br><span class="line">&#125;</span><br><span class="line">省略了成员初始化列表，程序将调用默认的基类构造函数，等效有：</span><br><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r,<span class="type">const</span> string &amp; fn,<span class="type">const</span> string &amp; ln,<span class="type">bool</span> ht)：<span class="built_in">TableTennisPalyer</span>()</span><br><span class="line">&#123;</span><br><span class="line">	rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.第二个构造函数的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RatePlayer::<span class="built_in">RatePlayer</span>(<span class="type">int</span> r=<span class="number">0</span>,<span class="type">const</span> TableTennishPlayer &amp; tp):<span class="built_in">TableTennishPlayer</span>(tp),<span class="built_in">rating</span>(r) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>上述方法声明是在类外声明的，与在类内声明的形式有很大的不一样</p>
</li>
<li><p>释放对象的顺序与创建对象的顺序相反，先执行派生类的析构函数</p>
</li>
</ol>
<h3 id="13-1-4-派生类和基类之间的特殊关系"><a href="#13-1-4-派生类和基类之间的特殊关系" class="headerlink" title="13.1.4 派生类和基类之间的特殊关系"></a>13.1.4 派生类和基类之间的特殊关系</h3><ol>
<li><p>基类指针或引用可以指向和引用派生类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">TableTennisPlayer &amp; rt = rplayer;</span><br><span class="line">TableTennisPlayer * pt = &amp;rplayer;</span><br><span class="line">rt.<span class="built_in">Name</span>();</span><br><span class="line">pt-&gt;<span class="built_in">Name</span>();</span><br></pre></td></tr></table></figure>
<p>基类指针或引用只能用于调用基类方法，不能使用基类指针或引用来调用派生类的方法</p>
</li>
<li><p>对于形参为指向基类的指针或引用的函数，也可以使用派生类作为实参，按值传递将派生类对象的基类部分传递给函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">const</span> TableTennisPlayher &amp; rt)</span></span></span><br><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="built_in">Show</span>(rplayer1);</span><br><span class="line"><span class="built_in">Show</span>(player1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用兼容性属性让你能够将基类对象初始化为派生类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(rplayer1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>要初始化player1,基类要调用构造函数的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TableTennisPlayer</span>(<span class="type">const</span> RatedPlayer &amp; );</span><br></pre></td></tr></table></figure>
<p>基类定义中没有这样的构造函数，但存在隐式复制构造函数</p>
</li>
<li><p>同样，也可以将派生类对象赋给基类对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>,<span class="string">&quot;Mallory&quot;</span>,<span class="string">&quot;Duck&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">TableTennisPlayer player1;</span><br><span class="line">player1 = rplayer1;</span><br></pre></td></tr></table></figure>
<p>将使用隐式重载赋值运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TableTennisPlayher &amp; <span class="keyword">operator</span>=(<span class="type">const</span> TableTennisPlayher &amp; )<span class="type">const</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="13-2-继承：is-a关系"><a href="#13-2-继承：is-a关系" class="headerlink" title="13.2 继承：is-a关系"></a>13.2 继承：is-a关系</h2><ol>
<li><p>公有继承是最常用的方式，它建立一种is-a关系，新类将继承原始类的所有数据成员</p>
</li>
<li><p>公有继承不建立has-a关系，has-a关系：午餐有水果，将水果的对象作为午餐类的数据成员</p>
</li>
<li><p>公有继承不建立is-like-a关系,即律师就像鲨鱼，不应从鲨鱼类派生出律师类，继承可以在基类的基础上添加基础，但不能删除基类的属性</p>
</li>
<li><p>公有继承不建立is-implemented-as-a关系,即作为···来实现，使用数组来实现栈，不可以因为栈不是数组</p>
</li>
<li><p>所以坚持使用is-a的关系，当满足is-a的关系，就可以使用公有继承</p>
</li>
</ol>
<h2 id="13-3-多态公有继承"><a href="#13-3-多态公有继承" class="headerlink" title="13.3 多态公有继承"></a>13.3 多态公有继承</h2><ol>
<li><p>概念：同一个方法在派生类和基类中的行为是不同的即称为多态–具有多种形态</p>
</li>
<li><p>两种实现方法：<br>在派生类中重新定义基类的方法<br>使用虚方法</p>
</li>
</ol>
<h3 id="13-3-1-开发Brass类和BrassPlus类"><a href="#13-3-1-开发Brass类和BrassPlus类" class="headerlink" title="13.3.1 开发Brass类和BrassPlus类"></a>13.3.1 开发Brass类和BrassPlus类</h3><ol>
<li><p>虚方法的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrassPlus</span>:<span class="keyword">public</span> Brass </span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会在派生类中重新定义基类的方法,但函数名一样的，关键字virtual只用于类声明的方法原型中</p>
</li>
<li><p>引用类型或指针类型选择方法在继承类中的使用<br>方法没有使用virtual将根据引用类型或指针类型选择方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">dom</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">dot</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">Brass &amp; bl_ref = dom;   本应该这样定义的</span><br><span class="line">Brass &amp; b2_ref = dot;</span><br><span class="line">bl_ref.<span class="built_in">ViewAcct</span>();</span><br><span class="line">b2_ref.<span class="built_in">ViewAcct</span>();</span><br></pre></td></tr></table></figure>
<p>引用变量的类型为Brass,所以都为Brass::ViewAcct()</p>
</li>
</ol>
<p>方法使用virtual将根据引用类型或指针类型选择方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">dom</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">dot</span><span class="params">(<span class="string">&quot;D&quot;</span>,<span class="number">121</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">Brass &amp; bl_ref = dom;   本应该这样定义的</span><br><span class="line">Brass &amp; b2_ref = dot;</span><br></pre></td></tr></table></figure>
<p>第二个是BrassPlus::ViewAcct()</p>
<ol start="3">
<li><p>可以在派生类方法中调用基类的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::ViewAcct</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Brass::<span class="built_in">ViewAcct</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;df&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该方法是虚方法，是使用作用域解析运算符来调用基类方法，而不是派生类对象来调用方法；如果不是虚方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::ViewAcct</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ViewAcct</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;df&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则不必使用作用域解析运算符</p>
</li>
<li><p>使用格式化方法setf()和precision()将浮点值的输出模式设置为定点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建指向Brass的指针数组，可以使用一个数组来表示多种类型的对象，这也是多态，Brass指针既可以指向Brass对象，也可以指向BrassPlus对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Brass * p_clients[<span class="number">4</span>];       与一般的数组定义是完全不一样的</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p_clients[i]=<span class="keyword">new</span> <span class="built_in">Brass</span>(temp,tempnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是Brass的指针数组,所以可以进行new分配内存</p>
</li>
<li><p>类对象的输入与一般的数据输入是不一样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string temp;</span><br><span class="line"><span class="type">long</span> tempnum;</span><br><span class="line"><span class="built_in">getline</span>(cin,temp);</span><br><span class="line">cin&gt;&gt;tempnum;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多态是由下述代码提供的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p_clients[i]-&gt;ViewAcct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p_clients[i]指的是指针不是值</p>
</li>
<li><p>为何需要虚构函数</p>
</li>
</ol>
<h2 id="13-4-静态联编和动态联编"><a href="#13-4-静态联编和动态联编" class="headerlink" title="13.4 静态联编和动态联编"></a>13.4 静态联编和动态联编</h2><ol>
<li>在编译过程就知道使用哪一个函数，是静态联编。因为虚函数的存在编译器不知道用户将选择哪种类型的对象，只能在程序运行的时候确定正确的虚函数方法<br>叫动态联编，总之，编译器对虚方法使用动态联编，根据对象类型将ViewAcct()关联到Brass::ViewAcct()或BrassPlus::ViewAcct()</li>
</ol>
<h3 id="13-4-1-指针和引用类型的兼容性"><a href="#13-4-1-指针和引用类型的兼容性" class="headerlink" title="13.4.1 指针和引用类型的兼容性"></a>13.4.1 指针和引用类型的兼容性</h3><ol>
<li><p>c++不允许将一种类型地址或引用赋给另一种类型的指针或引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">2.5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x;</span><br><span class="line"><span class="type">long</span> &amp; rl = x;</span><br></pre></td></tr></table></figure>
<p>但基类和派生类可以，而不必进行类型转换</p>
</li>
<li><p>虚函数的工作原理：<br>给每个对象添加一个隐藏成员，隐藏成员是一个指向函数地址数组的指针，被称为虚函数表</p>
</li>
<li><p>虚析构函数<br>析构函数应当是虚函数，即使它不执行任何操作，除非类不用做基类，析构函数不应进行delete操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">BaseClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Employee *pe = <span class="keyword">new</span> Singer;</span><br><span class="line"><span class="keyword">delete</span> pe;</span><br></pre></td></tr></table></figure>
<p>如果没有虚析构函数，delete语句将调用<del>Employer()析构函数，将释放派生类对象中的基类部分指向的内存，但不会释放新的类成员指向的内存，如果有虚析构函<br>数则先调用</del>Singer析构函数，在调用~Employer()析构函数</p>
</li>
<li><p>虚函数的参数要相同，但返回值可以不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> Dwelling &amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span>:<span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> Hovel &amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新定义将隐藏方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">long</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">两个都将被隐藏</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span>:<span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span>  <span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新定义继承的方法并不是重载，将隐藏所有的同名基类的方法</p>
</li>
</ol>
<h2 id="13-5-访问控制：protected"><a href="#13-5-访问控制：protected" class="headerlink" title="13.5 访问控制：protected"></a>13.5 访问控制：protected</h2><ol>
<li>protected与private相似，在类外只能用公有类成员来访问protected部分中的类成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">brass</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		doubloe balance;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		doubloe balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
区别在于继承方面：派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员，在派生类中与公有成员相识。例如可以编写<br>BrassPlus::Withdraw()<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BrassPlus::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(amt&lt; balance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
只有在派生类中可以这样使用，保护数据成员可以简化代码的编写工作，但又使保护数据成员balance成为公有变量，被轻易修改</li>
</ol>
<h2 id="13-6-抽象基类-ABC"><a href="#13-6-抽象基类-ABC" class="headerlink" title="13.6 抽象基类(ABC)"></a>13.6 抽象基类(ABC)</h2><ol>
<li><p>前面已经接受了简单继承和多态继承</p>
</li>
<li><p>另一种建立继承的方法：Ellipse类和Circle类有共点，可以建立拥有他们共同点的类BaseEllipse，这个类还包含Ellipse类和Circle类不的同的方法，应<br>被声明为虚函数，但至少应有一个纯虚函数</p>
</li>
<li><p>抽象函数通过使用纯虚函数来提供未实现的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseEllipse</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当类声明中包含纯虚函数时，则不能创建该类的对象，只能用做基类，因此可以从BaseEllipse类派生出Ellipse类和Circle类</p>
</li>
<li><p>Ellipse类和Circle类被称为具体类，具有相同的基类，可以用BaseEllipse指针数组同时管理这两种对象</p>
</li>
<li><p>BaseEllipse类的纯虚函数也应该定于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BaseEllipse::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	balance -= amt; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	balance -= amt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-6-1-应用ABC概念"><a href="#13-6-1-应用ABC概念" class="headerlink" title="13.6.1 应用ABC概念"></a>13.6.1 应用ABC概念</h3><ol>
<li>ABC是一种必须实施的接口，这种模式在基于组件的编程模式中很常见，每个ABC或者派生类是组件</li>
</ol>
<h2 id="13-7-继承和动态内存分配"><a href="#13-7-继承和动态内存分配" class="headerlink" title="13.7 继承和动态内存分配"></a>13.7 继承和动态内存分配</h2><h2 id="13-7-1-第一种情况：派生类不使用new"><a href="#13-7-1-第一种情况：派生类不使用new" class="headerlink" title="13.7.1 第一种情况：派生类不使用new"></a>13.7.1 第一种情况：派生类不使用new</h2><ol>
<li>基类使用动态内存分配，包含特殊方法：析构函数，复制构造函数，重载赋值运算符，而派生类不需要</li>
</ol>
<h2 id="13-7-2-第二种情况：派生类使用new"><a href="#13-7-2-第二种情况：派生类使用new" class="headerlink" title="13.7.2 第二种情况：派生类使用new"></a>13.7.2 第二种情况：派生类使用new</h2><ol>
<li>必须为派生类定义特殊方法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">派生类的析构函数：</span><br><span class="line">baseDMA::~<span class="built_in">baseDMA</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hasDMA::~<span class="built_in">hasDMA</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] style;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>派生类的复制构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hasDMA::<span class="built_in">hasDMA</span>(<span class="type">const</span> hasDMA &amp;hs)</span><br><span class="line">         ：<span class="built_in">baseDMA</span>(hs)     是基类的引用可以指向派生类型</span><br><span class="line">&#123;</span><br><span class="line">	style = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(style,hs.style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>派生类的重载赋值运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hasDMA &amp; hasDMA::<span class="keyword">operator</span>=(<span class="type">const</span> hasDMA &amp;hs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;hs)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	baseDMA::<span class="keyword">operator</span>=(hs);    显示调用基类赋值运算符</span><br><span class="line">	<span class="keyword">delete</span> [] style;</span><br><span class="line">	style = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(style,hs.style);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;    对<span class="keyword">this</span>指针的返回，返回类型也是引用</span><br><span class="line">&#125;</span><br><span class="line">baseDMA::<span class="keyword">operator</span>=(hs)不可用*<span class="keyword">this</span> = hs代替不然编译器会hasDMA::<span class="keyword">operator</span>=()，从而形成递归调用</span><br></pre></td></tr></table></figure>

<h3 id="13-7-3-友元的继承"><a href="#13-7-3-友元的继承" class="headerlink" title="13.7.3 友元的继承"></a>13.7.3 友元的继承</h3><ol>
<li>hasDMA类的友元访问label和rating的方法：使用强制类型转换<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">baseDMA</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">char</span> *label;</span><br><span class="line">		<span class="type">int</span> rating;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> baseDMA &amp; rs)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; rs.rating &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="type">const</span> hasDMA &amp; hs)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; (<span class="type">const</span> baseDMA &amp;)hs;</span><br><span class="line">	os &lt;&lt; hs.style &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第14章-c-中的代码重用"><a href="#第14章-c-中的代码重用" class="headerlink" title="第14章 c++中的代码重用"></a>第14章 c++中的代码重用</h1><ol>
<li>可以定义一个通用的栈模板，然后创建表示int或double值栈的类</li>
</ol>
<h2 id="14-1-包含对象成员的类"><a href="#14-1-包含对象成员的类" class="headerlink" title="14.1 包含对象成员的类"></a>14.1 包含对象成员的类</h2><ol>
<li>对于考试分数，可以使用一个定长数组，这限制了数组的长度；可以使用动态内存分配的指针，并提供大量的支持代码；也可以使用动态内存分配的类表示该数组；<br>还可以在标准c++库中查找一个表示这种数据的类，自己开发这样的类一点问题也没有</li>
</ol>
<h3 id="14-1-1-valarray类简介"><a href="#14-1-1-valarray类简介" class="headerlink" title="14.1.1 valarray类简介"></a>14.1.1 valarray类简介</h3><ol>
<li><p>它支持将数组中所有元素的值相加以及在数组中找出最大和最小的值的操作，提供的算术支持比vector和array的多</p>
</li>
<li><p>几个使用其构造函数的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="type">double</span> gpa[<span class="number">5</span>] = &#123;<span class="number">3.1</span>,<span class="number">3.5</span>,<span class="number">3.8</span>,<span class="number">2.9</span>,<span class="number">3.3</span>&#125;;</span><br><span class="line">valarray &lt;<span class="type">double</span>&gt; v1;</span><br><span class="line">valarray &lt;<span class="type">int</span>&gt; <span class="built_in">v2</span>(<span class="number">8</span>);  指定长度的空数组</span><br><span class="line">valarray &lt;<span class="type">int</span>&gt; <span class="built_in">v3</span>(<span class="number">10</span>,<span class="number">8</span>);</span><br><span class="line">valarray &lt;<span class="type">double</span>&gt; <span class="built_in">v4</span>(gpa,<span class="number">4</span>);</span><br><span class="line">valarray &lt;<span class="type">int</span>&gt; v5 = &#123;<span class="number">12</span>,<span class="number">32</span>,<span class="number">34</span>&#125;;    初始化列表</span><br></pre></td></tr></table></figure>
<p>先有长度再有数值，长度放后面</p>
</li>
<li><p>这个类的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()   返回数组的长度</span><br><span class="line"><span class="built_in">length</span>()     返回字符串的长度</span><br><span class="line"><span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">min</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-1-2-Student类的设计"><a href="#14-1-2-Student类的设计" class="headerlink" title="14.1.2 Student类的设计"></a>14.1.2 Student类的设计</h3><ol>
<li><p>可以从string和valarray这两个类，派生出Student类，这是多重公有继承(一种is-a关系),但这里并不合适，学生类与这些类不是is-a的关系</p>
</li>
<li><p>模板类一般使用自定义的形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	privatef:</span><br><span class="line">		<span class="keyword">typedef</span> std::valarray&lt;<span class="type">double</span>&gt; ArrayDb;     也在<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放在私有部分意味着可以在Student类的实现中使用它，当在Student类外面不能使用</p>
</li>
<li><p>在Student类中，可以直接使用string和valarray这两个类的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Student</span>():<span class="built_in">name</span>(<span class="string">&quot;Null Student&quot;</span>),<span class="built_in">scores</span>()&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">const</span> string &amp; s)</span>:name(s),scores()&#123;</span>&#125;</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">int</span> n)</span>:name(<span class="string">&quot;Nully&quot;</span>),scores(n)&#123;</span>&#125;</span><br><span class="line">		<span class="built_in">Studeent</span>(<span class="type">const</span> string &amp; s,<span class="type">int</span> n):<span class="built_in">name</span>(s),<span class="built_in">scores</span>(n)&#123;&#125;</span><br><span class="line">		<span class="built_in">Studeent</span>(<span class="type">const</span> string &amp; s,<span class="type">const</span> ArrayDb &amp; a):<span class="built_in">name</span>(s),<span class="built_in">scores</span>(a)&#123;&#125;</span><br><span class="line">		<span class="built_in">Studeent</span>(<span class="type">const</span> <span class="type">char</span> *str,<span class="type">const</span> <span class="type">double</span> *pd,<span class="type">int</span> n):<span class="built_in">name</span>(str),<span class="built_in">scores</span>(pd,n)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化被包含的对象时，构造函数将使用成员名，因为初始化的是成员对象，而不是继承的对象</p>
</li>
<li><p>在构造函数有一个参数时，考虑隐式转换函数，没有使用explicit可以写如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> n):<span class="built_in">name</span>(<span class="string">&quot;Nully&quot;</span>),<span class="built_in">scores</span>(n)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">doh</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>将创建一个Nully,5个元素的doh对象，但着一般是不允许的</p>
</li>
</ol>
<p>如果使用了explicit：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Student</span><span class="params">(<span class="type">int</span> n)</span>:name(<span class="string">&quot;Nully&quot;</span>),scores(n)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">doh</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>将会发生错误</p>
<ol start="5">
<li><p>初始化顺序：它们被声明的顺序，而不是它们在初始化列表中的顺序  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Studeent</span>(<span class="type">const</span> string &amp; s,<span class="type">int</span> n):<span class="built_in">scores</span>(n),<span class="built_in">name</span>(s)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>先初始化name成员而不是scores成员，在一个成员的值作为另一个成员的初始化表达式的一部分使，初始化的顺序就非常重要</p>
</li>
<li><p>stu.name是一个string对象，所以调用函数operator&lt;&lt;(ostream &amp;,const string &amp;)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="type">const</span> Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">	os&lt;&lt;stu.name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scores.<span class="built_in">sum</span>()</span><br><span class="line">scores.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>
<p>可以使用scores类的方法，同样该函数也可以实现valarray的输出，但scores没有&lt;&lt;重载运算符，因此，Student类定义了一个私有辅助方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp; <span class="title">Student::arr_out</span><span class="params">(ostram &amp; os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> lim = scores.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span>(lim&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lim;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			os&lt;&lt;scores[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">4</span>) os&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">5</span>!=<span class="number">0</span>)</span><br><span class="line">			os&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="type">const</span> Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">	os&lt;&lt;stu.name&lt;&lt;endl;</span><br><span class="line">	stu.<span class="built_in">arr_out</span>(os);</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> &amp; Student::<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> scores[i];    引用返回的更快</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在包含main()函数的文件中一般还自定义函数</p>
</li>
</ol>
<h2 id="14-2-私有继承"><a href="#14-2-私有继承" class="headerlink" title="14.2 私有继承"></a>14.2 私有继承</h2><ol>
<li><p>另一种实现has-a关系的途径–私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，可以在派生类的成员函数中使用它们，<br>即只能在派生类的方法中使用基类的方法,has-a是使用接口，与包含的特性一致,也是将另外两个类的对象做为Student的成员，is-a是使用实现</p>
</li>
<li><p>访问限定符的默认类型是私有private</p>
</li>
<li><p>Student类应从两个类派生而来,使用多个基类的继承被称为多重继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">private</span> string,<span class="keyword">private</span> valarray&lt;<span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>包含与私有继承的区别：包含提供了两个对象成员，而私有继承提供了两个无名的子对象成员</p>
</li>
</ol>
<h3 id="14-2-1-初始化基类组件"><a href="#14-2-1-初始化基类组件" class="headerlink" title="14.2.1 初始化基类组件"></a>14.2.1 初始化基类组件</h3><ol>
<li><p>有隐式地继承组件和显式地包含组件</p>
</li>
<li><p>私有继承类的构造函数将使用类名来初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span> * str,<span class="type">const</span> <span class="type">double</span> * pd,<span class="type">int</span> n) ：<span class="built_in">string</span>(str),<span class="built_in">ArrayDb</span>(pd,n) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-2-2-访问基类的方法"><a href="#14-2-2-访问基类的方法" class="headerlink" title="14.2.2 访问基类的方法"></a>14.2.2 访问基类的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Student::Average</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ArrayDb::<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ArrayDb::<span class="built_in">sum</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有确定对象时可以使用类名和作用域解析运算符来调用基类的方法，但函数的作用域与方法的作用域不一致时，就使用解析运算符</p>
<h3 id="14-2-3-访问基类对象"><a href="#14-2-3-访问基类对象" class="headerlink" title="14.2.3 访问基类对象"></a>14.2.3 访问基类对象</h3><ol>
<li>使用强制类型转换，将Student对象转换为string对象，*this表示Student对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp; <span class="title">Student::Name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">const</span> string &amp;) *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为避免调用构造函数创建新的对象，可使用强制类型转换来创建一个引用</li>
</ol>
<h3 id="14-2-3-访问基类的友元函数"><a href="#14-2-3-访问基类的友元函数" class="headerlink" title="14.2.3 访问基类的友元函数"></a>14.2.3 访问基类的友元函数</h3><p>用类名显式地限定函数名不合适于友元函数，可以使用显示地转换为基类来调用正确的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="type">const</span> Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">	os&lt;&lt;(<span class="type">const</span> string &amp;)stu;      不修改的强制类型转换</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">cout&lt;&lt;plato;    调用时并不是输出Student类的全部成员，而只是string要进入函数里面去看过程</span><br></pre></td></tr></table></figure>

<h3 id="14-2-4-使用修改后的Student类"><a href="#14-2-4-使用修改后的Student类" class="headerlink" title="14.2.4 使用修改后的Student类"></a>14.2.4 使用修改后的Student类</h3><ol>
<li><p>两个版本的Student类的公有接口(方法)完全相同，因此可以使用同一个程序测试它们</p>
</li>
<li><p>使用包含比私有继承好，如果某个类需要3个string对象，可以使用包含声明3个独立的string成员，如果新类需要访问原有类的保护成员，<br>或需要重新定义虚函数，则应使用私有继承</p>
</li>
</ol>
<h3 id="14-2-5-保护继承"><a href="#14-2-5-保护继承" class="headerlink" title="14.2.5 保护继承"></a>14.2.5 保护继承</h3><p>第三代类体现出保护继承和私有继承的区别</p>
<h3 id="14-2-6-使用using重新定义访问权限"><a href="#14-2-6-使用using重新定义访问权限" class="headerlink" title="14.2.6 使用using重新定义访问权限"></a>14.2.6 使用using重新定义访问权限</h3><p>1.在派生类类外调用基类对象的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Student::sum</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> valarray&lt;<span class="type">double</span>&gt;::<span class="built_in">sum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用一个using声明来指出派生类可以使用特定的基类成员，即使采用的是私有派生<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">private</span> string,<span class="keyword">private</span> valarray&lt;<span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">using</span> valarray&lt;<span class="type">double</span>&gt;::min;</span><br><span class="line">		<span class="keyword">using</span> valarray&lt;<span class="type">double</span>&gt;::max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stu.min;  可以这样使用</span><br></pre></td></tr></table></figure>
using声明只使用成员名——没有圆括号，函数特征标和返回类型</li>
</ol>
<h2 id="14-3-多重继承"><a href="#14-3-多重继承" class="headerlink" title="14.3 多重继承"></a>14.3 多重继承</h2><h2 id="14-4-类模板"><a href="#14-4-类模板" class="headerlink" title="14.4 类模板"></a>14.4 类模板</h2><ol>
<li>不如编写一个泛型栈，然后将具体的类型作为参数传递给这个类，这样就可以使用不同类型的栈，例如int栈和string栈</li>
</ol>
<h3 id="14-4-1-定义模板类"><a href="#14-4-1-定义模板类" class="headerlink" title="14.4.1 定义模板类"></a>14.4.1 定义模板类</h3><ol start="2">
<li>templat为函数名，尖括号中的内容相当于函数的参数列表，class&#x2F;typename看作是变量的类型名，Type看作变量的名称<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br></pre></td></tr></table></figure>
可以使用模板成员函数替换原有类的类方法。每个函数头都将以相同模板声明打头</li>
</ol>
<p>应改为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Item items[MAX];--&gt;Type items[MAX];</span><br><span class="line">Stack::--&gt;Stack&lt;type&gt;::       作用域解析符与类名也要改</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;Type&gt;::<span class="built_in">isEmpty</span>(<span class="type">const</span> Type &amp; item) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果在类声明中定义了方法(内联定义)，则可以省略模板前缀和类限定符</p>
<ol start="3">
<li>不能将模板成员函数放在独立的实现文件中，由于模板不是函数，它们不能单独编译</li>
</ol>
<h3 id="14-4-2-使用类模板"><a href="#14-4-2-使用类模板" class="headerlink" title="14.4.2 使用类模板"></a>14.4.2 使用类模板</h3><ol>
<li>使用的算法必须与类型一致，一般int与string是可以用在同一个模板类中的，string栈与指针栈有相同的功能，但不能用在同一个模板类中</li>
</ol>
<h3 id="14-4-3-指针栈-x2F-指针模板"><a href="#14-4-3-指针栈-x2F-指针模板" class="headerlink" title="14.4.3 指针栈&#x2F;指针模板"></a>14.4.3 指针栈&#x2F;指针模板</h3><ol>
<li><p>使用一个指针数组，其中每个指针都指向不同的字符串，用使用动态数组</p>
</li>
<li><p>返回类型为类时也要使用Stack<Type></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Stack &amp; st);   这是缩写，只能在类中使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> Stack &amp; st) &#123;&#125;   </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-4-4-数组模板示例和非类型参数"><a href="#14-4-4-数组模板示例和非类型参数" class="headerlink" title="14.4.4 数组模板示例和非类型参数"></a>14.4.4 数组模板示例和非类型参数</h3><ol>
<li><p>模板常用作容器类，主要是为容器类提供可重用代码</p>
</li>
<li><p>数组模板的成员是数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br></pre></td></tr></table></figure>
<p>为类型参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayTP</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T ar[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为非类型或表达式参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">double</span>,<span class="number">12</span>&gt;eqqweights;</span><br></pre></td></tr></table></figure>
<p>编译器将使用double替换T，使用12替换n</p>
</li>
<li><p>表达式参数可以是整型，枚举，引用或指针，因此，double m是不合法的，但double *rm是合法的<br>模板代码不能修改参数的值，也不能使用参数的地址，如n++和&amp;n<br>用作参数的值必须是常量表达式</p>
</li>
<li><p>介绍一个允许指定数组大小的简单数组模板：<br>第一种：使用动态数组和构造函数参数来提供元素数目<br>第二种：使用模板参数来提供常规数组的大小，array就是这样做的</p>
</li>
<li><p>表达式参数方法的缺点：每种数组大小都将生成自己的模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">double</span>,<span class="number">12</span>&gt; eqqweights;</span><br><span class="line">ArrayTP&lt;<span class="type">double</span>,<span class="number">13</span>&gt; donuts;</span><br></pre></td></tr></table></figure>
<p>将生成两个独立的类声明</p>
</li>
<li><p>使用动态数组和构造函数参数的方法的优点：更通用，数组大小是作为类成员存储在定义中的，可以将一种大小的数组赋给另一种大小的数组</p>
</li>
</ol>
<h3 id="14-4-4-模板的多功能性"><a href="#14-4-4-模板的多功能性" class="headerlink" title="14.4.4 模板的多功能性"></a>14.4.4 模板的多功能性</h3><ol>
<li><p>模板类可用作基类，也可用作组件类，还可用作其他模板的类型参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T entry;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrowArray</span> : <span class="keyword">public</span> Array&lt;Type&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">	Array&lt;Tp&gt; ar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array&lt; Stack&lt;<span class="type">int</span>&gt; &gt; asi;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归使用模板：对于前面的数组模板定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt; ArrayTP&lt;<span class="type">int</span>,<span class="number">5</span>&gt; <span class="number">10</span>&gt; twodee;</span><br></pre></td></tr></table></figure>
<p>这使得twodee是一个包含10个元素的数组，其中每个元素都是一个包含5个int元素的数组，与之等价的常规数组声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> towdee[<span class="number">10</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>即使没有这样的函数也可以这样使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		twodee[i][j]=<span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制输出宽度的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">width</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用多个类型参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Pair&lt;string,<span class="type">int</span>&gt;</span><br></pre></td></tr></table></figure>
<p>模板类的类名是Pair&lt;string,int&gt;，而不是Pair</p>
</li>
<li><p>默认类型模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Top&#123;...&#125;</span><br><span class="line">Top&lt;<span class="type">double</span>&gt; m1;    T2为<span class="type">int</span>型</span><br><span class="line">Top&lt;<span class="type">double</span> <span class="type">double</span>&gt; m2;  T2为<span class="type">double</span>型</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-4-6-模板的具体化"><a href="#14-4-6-模板的具体化" class="headerlink" title="14.4.6 模板的具体化"></a>14.4.6 模板的具体化</h3><ol>
<li><p>隐式实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="type">int</span>,<span class="number">100</span>&gt; stuff;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显式实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">ArrayTP</span>&lt;string,<span class="number">100</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>之后将生成一个类</p>
</li>
<li><p>显式具体化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortedArray</span> &#123;....&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设模板使用&gt;运算符来对值进行比较，对于数字，这管用;如果T是const char *，将不管用，这将要求类定义使用strcmp()，而不是&gt;来对值进行比较，这种情况下<br>可以提供一个显式模板具体化，即为一种具体类型定义的模板，而不是泛型定义的模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">class</span> <span class="title class_">SortedArray</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;</span><br><span class="line"></span><br><span class="line">SortedArray&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line">SortedArray&lt;<span class="type">const</span> <span class="type">char</span> *&gt;dates;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>4.部分具体化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Feed</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>*&gt; <span class="keyword">class</span> <span class="title class_">Feed</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">Feed&lt;<span class="type">char</span>&gt; fb1;</span><br><span class="line">Feed&lt;<span class="type">char</span> *&gt; fb2;</span><br></pre></td></tr></table></figure>
<p>第二个声明使用通用模板时，将T转换为char *类型，如果是部分具体化，T将转换为char</p>
<ol start="5">
<li>模板该考虑的类型：常规类型，char，char *a， string，ArrayTP，ArrayTP&lt;int,5&gt;</li>
</ol>
<h3 id="14-4-7-成员模板"><a href="#14-4-7-成员模板" class="headerlink" title="14.4.7 成员模板"></a>14.4.7 成员模板</h3><p>模板可用作结构，类或模板类的成员</p>
<ol>
<li>在beta模板外定义hold类和blah方法，模板是嵌套的，还必须指出hold和blab是beta<T>类的成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V&gt;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">beta</span>&lt;T&gt;::hold &#123;...&#125;</span><br></pre></td></tr></table></figure>
而不能使用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> V&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="14-4-8-将模板用作参数"><a href="#14-4-8-将模板用作参数" class="headerlink" title="14.4.8 将模板用作参数"></a>14.4.8 将模板用作参数</h3><p>是可以将类进行更改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Thing</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crab</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Thing&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Crab&lt;Stack&gt; nebula;</span><br></pre></td></tr></table></figure>

<h3 id="14-4-8-模板类和友元"><a href="#14-4-8-模板类和友元" class="headerlink" title="14.4.8 模板类和友元"></a>14.4.8 模板类和友元</h3><h3 id="14-4-8-模板别名"><a href="#14-4-8-模板别名" class="headerlink" title="14.4.8 模板别名"></a>14.4.8 模板别名</h3><h1 id="第15章-友元、异常和其他"><a href="#第15章-友元、异常和其他" class="headerlink" title="第15章 友元、异常和其他"></a>第15章 友元、异常和其他</h1><h2 id="15-1-友元"><a href="#15-1-友元" class="headerlink" title="15.1 友元"></a>15.1 友元</h2><p>友元类的所有方法都可以访问原始类的私有成员和保护成员</p>
<h3 id="15-1-1-友元类"><a href="#15-1-1-友元类" class="headerlink" title="15.1.1 友元类"></a>15.1.1 友元类</h3><ol>
<li>编写一个模拟电视机和遥控器的简单程序，遥控器可以改变电视机的状态，而不是is-a,has-a的关系，因此将Romote类作为Tv类的一个友元，必须先定义Tv<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Remote</span>;</span><br><span class="line">		...    </span><br><span class="line">&#125;;   放在公有位置</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">volup</span><span class="params">(Tv &amp; t)</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">volup</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
满足的是一种先有电视再有遥控器的关系</li>
</ol>
<h3 id="15-1-2-友元成员函数"><a href="#15-1-2-友元成员函数" class="headerlink" title="15.1.2 友元成员函数"></a>15.1.2 友元成员函数</h3><ol>
<li><p>让特定是类成员成为另一个类的友元，而不必让整个类成为友元</p>
</li>
<li><p>让Remote::set_chan()成为Tv类的友元的方法是，在Tv类声明中将其声明为友元,set_chan()使用的是Tv类的成员，所以必须是友元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span></span>;</span><br><span class="line">		...    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>必须使用前向声明(forward declaration)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Remote声明中只包含方法声明，并将实际的定义放在Tv类之后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_mode</span><span class="params">(Tv &amp;t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Remote::set_chan</span><span class="params">(Tv &amp; t,<span class="type">int</span> c)</span> </span>&#123;t.channel = c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Remote::set_mode</span><span class="params">(Tv &amp;t)</span> </span>&#123;t.<span class="built_in">set_mode</span>();&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="15-1-3-其他友元关系"><a href="#15-1-3-其他友元关系" class="headerlink" title="15.1.3 其他友元关系"></a>15.1.3 其他友元关系</h3><h3 id="15-1-4-共同的友元"><a href="#15-1-4-共同的友元" class="headerlink" title="15.1.4 共同的友元"></a>15.1.4 共同的友元</h3><h2 id="15-2-嵌套类"><a href="#15-2-嵌套类" class="headerlink" title="15.2 嵌套类"></a>15.2 嵌套类</h2></article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.jingyingcaibao.club/2023/02/19/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++&amp;url=https://www.jingyingcaibao.club/2023/02/19/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/&amp;pic=https://img1.imgtp.com/2023/06/08/O3WKNAND.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img1.imgtp.com/2023/06/10/dmKgyzcd.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.jingyingcaibao.club/2023/02/19/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/">原创</a><a class="post-copyright-title"><span>C++</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"></span><a class="link" href="https://www.jingyingcaibao.club">Hjfeng🪂</a></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a class="link" href="https://www.jingyingcaibao.club/2023/02/19/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/">https://www.jingyingcaibao.club/2023/02/19/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</a></span><span class="copy-button" onclick="rm.copyPageUrl('https://www.jingyingcaibao.club/2023/02/19/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/)'"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.jingyingcaibao.club" target="_blank">Hjfeng🪂</a>！</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/19/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"><img class="prev-cover" src="https://img1.imgtp.com/2023/06/08/iLDZ1sDM.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/19/%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/"><img class="next-cover" src="https://img1.imgtp.com/2023/06/08/LLViZk7H.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Leetcode总结</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a></div><div class="comment-tips" id="comment-tips"><span>你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author-info-top"> <div class="card-info-avatar"><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="writing_hand" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270d.png">✍️</g-emoji><span>on Studying</span></div></div></div></div><div class="author-info__sayhi" id="author-info__sayhi"></div><h1 class="author-info__name">Hjfeng🪂</h1><div class="author-info__description">大好青年，事业有为。</div><div class="banner-button-group"><a class="banner-button" onclick="pjax.loadUrl(&quot;/about/&quot;)"><span class="banner-button-text">了解更多</span><i class="anzhiyufont anzhiyu-icon-arrow-circle-right" style="font-size: 1.5rem"></i></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/anzhiyu-c" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2268025923@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C"><span class="toc-number">1.</span> <span class="toc-text">C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">11.6类的自动转换和强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-1%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">11.6.1转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-2%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">11.6.2转换函数和友元函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number"></span> <span class="toc-text">第十二章 类和动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">12.1动态内存和类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-1%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">12.1.1开发一个动态内存类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-2-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">12.1.2 特殊成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-3-%E5%9B%9E%E5%88%B0Stringbad-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%93%AA%E9%87%8C%E5%87%BA%E4%BA%86%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">12.1.3 回到Stringbad: 复制构造函数的哪里出了问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-4-StringBad%E7%9A%84%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%EF%BC%9A%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">12.1.4 StringBad的其他问题：赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E6%96%B0Stirng%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">改进后的新Stirng类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-2%E6%AF%94%E8%BE%83%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">12.2.2比较成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-3%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">12.2.3使用中括号表示法访问字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-4-%E9%9D%99%E6%80%81%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">12.2.4 静态类成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-5-%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">12.2.5 进一步重载赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8new%E6%97%B6%E5%BA%94%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.</span> <span class="toc-text">12.3 在构造函数中使用new时应注意的事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-%E5%8C%85%E5%90%AB%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E7%9A%84%E9%80%90%E6%88%90%E5%91%98%E5%A4%8D%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">12.3.1 包含类成员的类的逐成员复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E6%9C%89%E5%85%B3%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">4.</span> <span class="toc-text">12.4 有关返回对象的说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-1-%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91const%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">12.4.1 返回指向const对象的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-2-%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E9%9D%9Econst%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">12.4.2 返回指向非const对象引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-3-%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.3.</span> <span class="toc-text">12.4.3 返回对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">5.</span> <span class="toc-text">12.5 使用指向对象的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-1-%E5%86%8D%E8%B0%88%E5%AE%9A%E4%BD%8Dnew%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.1.</span> <span class="toc-text">12.5.1 再谈定位new运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number"></span> <span class="toc-text">第13章 类继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">13.1 一个简单的基类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-1"><span class="toc-number">1.1.</span> <span class="toc-text">13.1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E8%80%83%E8%99%91"><span class="toc-number">1.2.</span> <span class="toc-text">13.1.2 构造函数：访问权限的考虑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-4-%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E7%89%B9%E6%AE%8A%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">13.1.4 派生类和基类之间的特殊关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E7%BB%A7%E6%89%BF%EF%BC%9Ais-a%E5%85%B3%E7%B3%BB"><span class="toc-number">2.</span> <span class="toc-text">13.2 继承：is-a关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-%E5%A4%9A%E6%80%81%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">13.3 多态公有继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-1-%E5%BC%80%E5%8F%91Brass%E7%B1%BB%E5%92%8CBrassPlus%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">13.3.1 开发Brass类和BrassPlus类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">4.</span> <span class="toc-text">13.4 静态联编和动态联编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-1-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">13.4.1 指针和引用类型的兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9Aprotected"><span class="toc-number">5.</span> <span class="toc-text">13.5 访问控制：protected</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB-ABC"><span class="toc-number">6.</span> <span class="toc-text">13.6 抽象基类(ABC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-1-%E5%BA%94%E7%94%A8ABC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">13.6.1 应用ABC概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">7.</span> <span class="toc-text">13.7 继承和动态内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-1-%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8D%E4%BD%BF%E7%94%A8new"><span class="toc-number">8.</span> <span class="toc-text">13.7.1 第一种情况：派生类不使用new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-2-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%BD%BF%E7%94%A8new"><span class="toc-number">9.</span> <span class="toc-text">13.7.2 第二种情况：派生类使用new</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-3-%E5%8F%8B%E5%85%83%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">9.1.</span> <span class="toc-text">13.7.3 友元的继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-c-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">第14章 c++中的代码重用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E5%8C%85%E5%90%AB%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">14.1 包含对象成员的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-1-valarray%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">14.1.1 valarray类简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-2-Student%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">14.1.2 Student类的设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">14.2 私有继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">14.2.1 初始化基类组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-2-%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">14.2.2 访问基类的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-3-%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.</span> <span class="toc-text">14.2.3 访问基类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-3-%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">14.2.3 访问基类的友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-4-%E4%BD%BF%E7%94%A8%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84Student%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">14.2.4 使用修改后的Student类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-5-%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="toc-number">2.6.</span> <span class="toc-text">14.2.5 保护继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-6-%E4%BD%BF%E7%94%A8using%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.7.</span> <span class="toc-text">14.2.6 使用using重新定义访问权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">14.3 多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.</span> <span class="toc-text">14.4 类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-1-%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">14.4.1 定义模板类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-2-%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.2.</span> <span class="toc-text">14.4.2 使用类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-3-%E6%8C%87%E9%92%88%E6%A0%88-x2F-%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.3.</span> <span class="toc-text">14.4.3 指针栈&#x2F;指针模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-4-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E7%A4%BA%E4%BE%8B%E5%92%8C%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">14.4.4 数组模板示例和非类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-4-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E6%80%A7"><span class="toc-number">4.5.</span> <span class="toc-text">14.4.4 模板的多功能性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-6-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%85%B7%E4%BD%93%E5%8C%96"><span class="toc-number">4.6.</span> <span class="toc-text">14.4.6 模板的具体化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-7-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.7.</span> <span class="toc-text">14.4.7 成员模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-8-%E5%B0%86%E6%A8%A1%E6%9D%BF%E7%94%A8%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">14.4.8 将模板用作参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-8-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E5%8F%8B%E5%85%83"><span class="toc-number">4.9.</span> <span class="toc-text">14.4.8 模板类和友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-8-%E6%A8%A1%E6%9D%BF%E5%88%AB%E5%90%8D"><span class="toc-number">4.10.</span> <span class="toc-text">14.4.8 模板别名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96"><span class="toc-number"></span> <span class="toc-text">第15章 友元、异常和其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E5%8F%8B%E5%85%83"><span class="toc-number">1.</span> <span class="toc-text">15.1 友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-1-%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">15.1.1 友元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-2-%E5%8F%8B%E5%85%83%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">15.1.2 友元成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-3-%E5%85%B6%E4%BB%96%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">15.1.3 其他友元关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-4-%E5%85%B1%E5%90%8C%E7%9A%84%E5%8F%8B%E5%85%83"><span class="toc-number">1.4.</span> <span class="toc-text">15.1.4 共同的友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">15.2 嵌套类</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/18/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="Markdown总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/06/08/OzVV3ETP.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Markdown总结"/></a><div class="content"><a class="title" href="/2023/05/18/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="Markdown总结">Markdown总结</a><time datetime="2023-05-18T04:00:00.000Z" title="发表于 2023-05-18 12:00:00">2023-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/18/%E7%AC%AC%E5%8D%81%E7%AF%87%E6%96%87%E7%AB%A0/" title="英语单词"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/06/08/sdyaVMkv.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="英语单词"/></a><div class="content"><a class="title" href="/2023/05/18/%E7%AC%AC%E5%8D%81%E7%AF%87%E6%96%87%E7%AB%A0/" title="英语单词">英语单词</a><time datetime="2023-05-18T04:00:00.000Z" title="发表于 2023-05-18 12:00:00">2023-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/19/%E7%AC%AC%E4%B8%83%E7%AF%87%E6%96%87%E7%AB%A0/" title="计算机网络编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/06/10/dmKgyzcd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络编程"/></a><div class="content"><a class="title" href="/2023/02/19/%E7%AC%AC%E4%B8%83%E7%AF%87%E6%96%87%E7%AB%A0/" title="计算机网络编程">计算机网络编程</a><time datetime="2023-02-19T04:00:00.000Z" title="发表于 2023-02-19 12:00:00">2023-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/19/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/" title="C语言"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/06/08/kVeLKM9c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言"/></a><div class="content"><a class="title" href="/2023/02/19/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/" title="C语言">C语言</a><time datetime="2023-02-19T04:00:00.000Z" title="发表于 2023-02-19 12:00:00">2023-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/19/%E7%AC%AC%E4%B9%9D%E7%AF%87%E6%96%87%E7%AB%A0/" title="二级C++语言程序设计"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/06/08/8VnXQbNg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二级C++语言程序设计"/></a><div class="content"><a class="title" href="/2023/02/19/%E7%AC%AC%E4%B9%9D%E7%AF%87%E6%96%87%E7%AB%A0/" title="二级C++语言程序设计">二级C++语言程序设计</a><time datetime="2023-02-19T04:00:00.000Z" title="发表于 2023-02-19 12:00:00">2023-02-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Hjfeng🪂</div><div id="workboard"><img class="workSituationImg boardsign" src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://anzhiy.cn/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a></p></div></footer></div></div></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://img1.imgtp.com/2023/06/08/xDFa6bJF.jpg"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
    Pace.restart()
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/06/08/KbbjqXPT.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8921687509&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/webroot/"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 小地址</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> AI</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/ChatGPT/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> ChatGPT</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 统计图</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch_commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button type="button" title="切换背景" onclick="toggleWinbox()"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="center-console" type="button" title="中控台"><i class="anzhiyufont anzhiyu-icon-fish"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><div id="console-music-bg"></div><meting-js id="8921687509" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="console"><div class="close-btn" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-xmark" style="font-size: 35px;"></i></div><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>1</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/Leetcode%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">Leetcode总结<sup>1</sup></a><a href="/tags/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">Linux操作系统<sup>1</sup></a><a href="/tags/STM32%E5%8D%95%E7%89%87%E6%9C%BA%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">STM32单片机编程<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8921687509&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@17.3.1/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>var meting_api = "https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r";
</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 1.3.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Hjfeng🪂 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2021 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
      img.title = "下班了就该开开心心的玩耍，嘿嘿~";
      img.alt = "下班了就该开开心心的玩耍，嘿嘿~";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.3.0/source/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://www.jinyincaibao.club/',
      region: '',
      onCommentLoaded: function () {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://www.jinyincaibao.club/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://npm.elemecdn.com/twikoo@1.6.16/dist/twikoo.all.min.js').then(runFn)
  }
  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://www.jinyincaibao.club/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://npm.elemecdn.com/twikoo@1.6.16/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick}</span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";</script><script>//动态标题
let leaveTitle = 'w(ﾟДﾟ)w 不要走！再看看嘛！';
let backTitle = '♪(^∇^*)欢迎肥来！';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script data-pjax="true">if (document.querySelector(".comment-barrage")){
  var commentBarrageConfig = {
    maxBarrage: 1,
    barrageTime: 4000,
    twikooUrl: "https://www.jinyincaibao.club/",
    accessToken: "",
    mailMd5: "",
    pageUrl: window.location.pathname,
    barrageTimer: [],
    barrageList: [],
    barrageIndex: 0,
    dom: document.querySelector(".comment-barrage"),
  };
  var commentInterval = null;
  var hoverOnCommentBarrage = false;
  
  document.querySelector(".comment-barrage").addEventListener("mouseenter", function() {
    hoverOnCommentBarrage = true;
  });
  document.querySelector(".comment-barrage").addEventListener("mouseleave", function() {
    hoverOnCommentBarrage = false;
  });

  function initCommentBarrage() {
    if (!commentBarrageConfig.dom) return;

    var data = JSON.stringify({
      event: "COMMENT_GET",
      "commentBarrageConfig.accessToken": commentBarrageConfig.accessToken,
      url: commentBarrageConfig.pageUrl,
    });
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;
    xhr.addEventListener("readystatechange", function () {
      if (this.readyState === 4 && this.responseText) {
        commentBarrageConfig.barrageList = commentLinkFilter(JSON.parse(this.responseText).data);
        commentBarrageConfig.dom.innerHTML = "";
      }
    });
    xhr.open("POST", commentBarrageConfig.twikooUrl);
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.send(data);

    clearInterval(commentInterval);
    commentInterval = null;

    commentInterval = setInterval(() => {
      if (commentBarrageConfig.barrageList.length && !hoverOnCommentBarrage) {
        popCommentBarrage(commentBarrageConfig.barrageList[commentBarrageConfig.barrageIndex]);
        commentBarrageConfig.barrageIndex += 1;
        commentBarrageConfig.barrageIndex %= commentBarrageConfig.barrageList.length;
      }
      if (
        commentBarrageConfig.barrageTimer.length >
          (commentBarrageConfig.barrageList.length > commentBarrageConfig.maxBarrage
            ? commentBarrageConfig.maxBarrage
            : commentBarrageConfig.barrageList.length) &&
        !hoverOnCommentBarrage
      ) {
        removeCommentBarrage(commentBarrageConfig.barrageTimer.shift());
      }
    }, commentBarrageConfig.barrageTime);
  }

  function commentLinkFilter(data) {
    data.sort((a, b) => {
      return a.created - b.created;
    });
    let newData = [];
    data.forEach(item => {
      newData.push(...getCommentReplies(item));
    });
    return newData;
  }

  function getCommentReplies(item) {
    if (item.replies) {
      let replies = [item];
      item.replies.forEach(item => {
        replies.push(...getCommentReplies(item));
      });
      return replies;
    } else {
      return [];
    }
  }

  function popCommentBarrage(data) {
    let barrage = document.createElement("div");
    barrage.className = "comment-barrage-item";
    barrage.innerHTML = `
        <div class="barrageHead">
          <a class="barrageTitle ${
            data.mailMd5 === commentBarrageConfig.mailMd5 ? "barrageBloggerTitle" : ""
          }" href="javascript:anzhiyu.scrollTo('#post-comment')"">
            ${data.mailMd5 === commentBarrageConfig.mailMd5 ? "博主" : "热评"}
          </a>
          <div class="barrageNick">${data.nick}</div>
          <img class="nolazyload barrageAvatar" src="https://cravatar.cn/avatar/${data.mailMd5}"/>
          <a class="comment-barrage-close" href="javascript:anzhiyu.switchCommentBarrage()"><i class="anzhiyufont anzhiyu-icon-xmark"></i></a>
        </div>
        <a class="barrageContent" href="#${data.id}">
          <object>${data.comment}</object>
        </a>
      `;
    commentBarrageConfig.barrageTimer.push(barrage);
    commentBarrageConfig.dom.append(barrage);
  }

  function removeCommentBarrage(barrage) {
    barrage.className = "comment-barrage-item out";

    setTimeout(() => {
      if (commentBarrageConfig.dom && commentBarrageConfig.dom.contains(barrage)) {
        commentBarrageConfig.dom.removeChild(barrage);
      }
      }, 1000);
    }

    // 自动隐藏
    const commentEntryCallback = (entries) => {
      const commentBarrage = document.querySelector(".comment-barrage");
      const postComment = document.getElementById("post-comment");

      entries.forEach(entry => {
        if (postComment && commentBarrage && document.body.clientWidth > 768) {
          commentBarrage.style.bottom = entry.isIntersecting ? "-200px" : "0";
        }
      });
    };
    // 创建IntersectionObserver实例
    const observer = new IntersectionObserver(commentEntryCallback, {
      root: null,
      rootMargin: "0px",
      threshold: 0
    });
    // 监视目标元素
    const postCommentTarget = document.getElementById("post-comment");
    if (postCommentTarget) {
      observer.observe(postCommentTarget);
    }

    initCommentBarrage();

    if (localStorage.getItem("commentBarrageSwitch") !== "false") {
      document.querySelector(".comment-barrage").style.display = "flex";
      document.querySelector(".menu-commentBarrage-text").textContent = "关闭热评";
    } else {
      document.querySelector(".comment-barrage").style.display = "none";
      document.querySelector(".menu-commentBarrage-text").textContent = "显示热评";
    }

    document.addEventListener("pjax:send", function () {
      clearInterval(commentInterval);
    });

  }</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | Hjfeng🪂")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();

anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.0/icon/ali_iconfont_css.css"><script src="/js/sakura.js"></script><script defer src="/live2d-widget/autoload.js"></script><script src="https://cdn.jsdelivr.net/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script src="/js/share.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/02/19/第七篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/06/10/dmKgyzcd.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/02/19/第七篇文章/&quot;);" href="javascript:void(0);" alt="">计算机网络编程</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/02/19/第七篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/02/19/第六篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/06/08/LLViZk7H.jpeg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/02/19/第六篇文章/&quot;);" href="javascript:void(0);" alt="">Leetcode总结</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/02/19/第六篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/02/19/第五篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.imgtp.com/2023/06/08/9vV9bt61.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/02/19/第五篇文章/&quot;);" href="javascript:void(0);" alt="">STM32单片机编程</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/02/19/第五篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<container><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></container>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/webroot/'|| '/webroot/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?Fomalhaut-Blog",['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'],'Fomalhaut-Blog')
    }
  </script><!-- hexo injector body_end end --></body></html>